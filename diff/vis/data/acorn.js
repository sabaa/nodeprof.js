let __diffs = [{"caller":{"fileName":"run.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/run.js","start":{"line":"1","column":"62"},"end":{"line":"119","column":"5"},"code":"\n  var driver = require(\"./driver.js\")\n  require(\"./tests.js\");\n  require(\"./tests-harmony.js\");\n  require(\"./tests-es7.js\");\n  require(\"./tests-asyncawait.js\");\n  require(\"./tests-await-top-level.js\");\n  require(\"./tests-trailing-commas-in-func.js\");\n  require(\"./tests-template-literal-revision.js\");\n  require(\"./tests-directive.js\");\n  require(\"./tests-rest-spread-properties.js\");\n  require(\"./tests-async-iteration.js\");\n  require(\"./tests-regexp.js\");\n  require(\"./tests-regexp-2018.js\");\n  require(\"./tests-json-superset.js\");\n  require(\"./tests-optional-catch-binding.js\");\n  require(\"./tests-bigint.js\");\n  require(\"./tests-dynamic-import.js\");\n  var acorn = require(\"../acorn\")\n  var acorn_loose = require(\"../acorn-loose\")\n\n  var htmlLog = typeof document === \"object\" && document.getElementById('log');\n  var htmlGroup = htmlLog;\n\n  function group(name) {\n    if (htmlGroup) {\n      var parentGroup = htmlGroup;\n      htmlGroup = document.createElement(\"ul\");\n      var item = document.createElement(\"li\");\n      item.textContent = name;\n      item.appendChild(htmlGroup);\n      parentGroup.appendChild(item);\n    }\n    if (typeof console === \"object\" && console.group) {\n      console.group(name);\n    }\n  }\n\n  function groupEnd() {\n    if (htmlGroup) {\n      htmlGroup = htmlGroup.parentElement.parentElement;\n    }\n    if (typeof console === \"object\" && console.groupEnd) {\n      console.groupEnd(name);\n    }\n  }\n\n  function log(title, message) {\n    if (htmlGroup) {\n      var elem = document.createElement(\"li\");\n      elem.innerHTML = \"<b>\" + title + \"</b> \" + message;\n      htmlGroup.appendChild(elem);\n    }\n    if (typeof console === \"object\") console.log(title, message);\n  }\n\n  var stats, modes = {\n    Normal: {\n      config: {\n        parse: acorn.parse\n      }\n    },\n    Loose: {\n      config: {\n        parse: acorn_loose.parse,\n        loose: true,\n        filter: function (test) {\n          var opts = test.options || {};\n          return opts.loose !== false;\n        }\n      }\n    }\n  };\n\n  function report(state, code, message) {\n    if (state != \"ok\") {++stats.failed; log(code, message);}\n    ++stats.testsRun;\n  }\n/*\n  group(\"Errors\");\n\n  for (var name in modes) {\n    group(name);\n    var mode = modes[name];\n    stats = mode.stats = {testsRun: 0, failed: 0};\n    var t0 = +new Date;\n    driver.runTests(mode.config, report);\n    mode.stats.duration = +new Date - t0;\n    groupEnd();\n  }\n\n  groupEnd();\n\n  function outputStats(name, stats) {\n    log(name + \":\", stats.testsRun + \" tests run in \" + stats.duration + \"ms; \" +\n      (stats.failed ? stats.failed + \" failures.\" : \"all passed.\"));\n  }\n\n  var total = {testsRun: 0, failed: 0, duration: 0};\n\n  group(\"Stats\");\n\n  for (var name in modes) {\n    var stats = modes[name].stats;\n    outputStats(name + \" parser\", stats);\n    for (var key in stats) total[key] += stats[key];\n  }\n\n  outputStats(\"Total\", total);\n\n  groupEnd();\n\n  if (total.failed && typeof process === \"object\") {\n    process.stdout.write(\"\", function() {\n      process.exit(1);\n    });\n  }\n  */\n})();\n","startIndex":3061,"endIndex":3061,"highlightLines":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118]},"callee":{"fileName":"run.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/run.js","start":{"line":"1","column":"63"},"end":{"line":"119","column":"2"},"code":"\n  var driver = require(\"./driver.js\")\n  require(\"./tests.js\");\n  require(\"./tests-harmony.js\");\n  require(\"./tests-es7.js\");\n  require(\"./tests-asyncawait.js\");\n  require(\"./tests-await-top-level.js\");\n  require(\"./tests-trailing-commas-in-func.js\");\n  require(\"./tests-template-literal-revision.js\");\n  require(\"./tests-directive.js\");\n  require(\"./tests-rest-spread-properties.js\");\n  require(\"./tests-async-iteration.js\");\n  require(\"./tests-regexp.js\");\n  require(\"./tests-regexp-2018.js\");\n  require(\"./tests-json-superset.js\");\n  require(\"./tests-optional-catch-binding.js\");\n  require(\"./tests-bigint.js\");\n  require(\"./tests-dynamic-import.js\");\n  var acorn = require(\"../acorn\")\n  var acorn_loose = require(\"../acorn-loose\")\n\n  var htmlLog = typeof document === \"object\" && document.getElementById('log');\n  var htmlGroup = htmlLog;\n\n  function group(name) {\n    if (htmlGroup) {\n      var parentGroup = htmlGroup;\n      htmlGroup = document.createElement(\"ul\");\n      var item = document.createElement(\"li\");\n      item.textContent = name;\n      item.appendChild(htmlGroup);\n      parentGroup.appendChild(item);\n    }\n    if (typeof console === \"object\" && console.group) {\n      console.group(name);\n    }\n  }\n\n  function groupEnd() {\n    if (htmlGroup) {\n      htmlGroup = htmlGroup.parentElement.parentElement;\n    }\n    if (typeof console === \"object\" && console.groupEnd) {\n      console.groupEnd(name);\n    }\n  }\n\n  function log(title, message) {\n    if (htmlGroup) {\n      var elem = document.createElement(\"li\");\n      elem.innerHTML = \"<b>\" + title + \"</b> \" + message;\n      htmlGroup.appendChild(elem);\n    }\n    if (typeof console === \"object\") console.log(title, message);\n  }\n\n  var stats, modes = {\n    Normal: {\n      config: {\n        parse: acorn.parse\n      }\n    },\n    Loose: {\n      config: {\n        parse: acorn_loose.parse,\n        loose: true,\n        filter: function (test) {\n          var opts = test.options || {};\n          return opts.loose !== false;\n        }\n      }\n    }\n  };\n\n  function report(state, code, message) {\n    if (state != \"ok\") {++stats.failed; log(code, message);}\n    ++stats.testsRun;\n  }\n/*\n  group(\"Errors\");\n\n  for (var name in modes) {\n    group(name);\n    var mode = modes[name];\n    stats = mode.stats = {testsRun: 0, failed: 0};\n    var t0 = +new Date;\n    driver.runTests(mode.config, report);\n    mode.stats.duration = +new Date - t0;\n    groupEnd();\n  }\n\n  groupEnd();\n\n  function outputStats(name, stats) {\n    log(name + \":\", stats.testsRun + \" tests run in \" + stats.duration + \"ms; \" +\n      (stats.failed ? stats.failed + \" failures.\" : \"all passed.\"));\n  }\n\n  var total = {testsRun: 0, failed: 0, duration: 0};\n\n  group(\"Stats\");\n\n  for (var name in modes) {\n    var stats = modes[name].stats;\n    outputStats(name + \" parser\", stats);\n    for (var key in stats) total[key] += stats[key];\n  }\n\n  outputStats(\"Total\", total);\n\n  groupEnd();\n\n  if (total.failed && typeof process === \"object\") {\n    process.stdout.write(\"\", function() {\n      process.exit(1);\n    });\n  }\n  */\n})\n","startIndex":3058,"endIndex":3058,"highlightLines":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"1","column":"62"},"end":{"line":"5001","column":"4"},"code":"\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.acorn = {}));\n}(this, function (exports) { 'use strict';\n\n  // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  };\n\n  // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\n  var keywords = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  };\n\n  var keywordRelationalOperator = /^in(stanceof)?$/;\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n  // Generated by `bin/generate-identifier-regex.js`.\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n  // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range. They were\n  // generated by bin/generate-identifier-regex.js\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\n\n  // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n      if (pos > code) { return false }\n      pos += set[i + 1];\n      if (pos >= code) { return true }\n    }\n  }\n\n  // Test whether a given character code starts an identifier.\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) { return code === 36 }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes)\n  }\n\n  // Test whether a given character is part of an identifier.\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) { return code === 36 }\n    if (code < 58) { return true }\n    if (code < 65) { return false }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n  }\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var TokenType = function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywords$1 = {};\n\n  // Succinct definitions of keyword token types\n  function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n\n  var types = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    eof: new TokenType(\"eof\"),\n\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n    prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {isLoop: true}),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {isLoop: true}),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n  };\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code, ecma2019String) {\n    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n  var ref = Object.prototype;\n  var hasOwnProperty = ref.hasOwnProperty;\n  var toString = ref.toString;\n\n  // Checks if an object has a property.\n\n  function has(obj, propName) {\n    return hasOwnProperty.call(obj, propName)\n  }\n\n  var isArray = Array.isArray || (function (obj) { return (\n    toString.call(obj) === \"[object Array]\"\n  ); });\n\n  function wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n\n  // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset (n) {\n    return new Position(this.line, this.column + n)\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) { this.source = p.sourceFile; }\n  };\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreakG.lastIndex = cur;\n      var match = lineBreakG.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else {\n        return new Position(line, offset - cur)\n      }\n    }\n  }\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n    // (2019). This influences support for strict mode, the set of\n    // reserved words, and support for new syntax features. The default\n    // is 10.\n    ecmaVersion: 10,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // the position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program.\n    allowImportExportEverywhere: false,\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: false,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n  };\n\n  // Interpret and default an options object\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions)\n      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n    if (options.ecmaVersion >= 2015)\n      { options.ecmaVersion -= 2009; }\n\n    if (options.allowReserved == null)\n      { options.allowReserved = options.ecmaVersion < 5; }\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n      options.onToken = function (token) { return tokens.push(token); };\n    }\n    if (isArray(options.onComment))\n      { options.onComment = pushComment(options, options.onComment); }\n\n    return options\n  }\n\n  function pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text,\n        start: start,\n        end: end\n      };\n      if (options.locations)\n        { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n      if (options.ranges)\n        { comment.range = [start, end]; }\n      array.push(comment);\n    }\n  }\n\n  // Each scope gets a bitset that may contain these flags\n  var\n      SCOPE_TOP = 1,\n      SCOPE_FUNCTION = 2,\n      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n      SCOPE_ASYNC = 4,\n      SCOPE_GENERATOR = 8,\n      SCOPE_ARROW = 16,\n      SCOPE_SIMPLE_CATCH = 32,\n      SCOPE_SUPER = 64,\n      SCOPE_DIRECT_SUPER = 128;\n\n  function functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n  }\n\n  // Used in checkLVal and declareName to determine the type of a binding\n  var\n      BIND_NONE = 0, // Not a binding\n      BIND_VAR = 1, // Var-style binding\n      BIND_LEXICAL = 2, // Let- or const-style binding\n      BIND_FUNCTION = 3, // Function declaration\n      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n      for (var v = options.ecmaVersion;; v--)\n        { if (reserved = reservedWords[v]) { break } }\n      if (options.sourceType === \"module\") { reserved += \" await\"; }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = types.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = {};\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n      { this.skipLineComment(2); }\n\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n\n    // For RegExp validation\n    this.regexpState = null;\n  };\n\n  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\n  Parser.prototype.parse = function parse () {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node)\n  };\n\n  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\n  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n  // Switch to a getter for 7.0.0.\n  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\n  Parser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  Parser.parse = function parse (input, options) {\n    return new this(options, input).parse()\n  };\n\n  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression()\n  };\n\n  Parser.tokenizer = function tokenizer (input, options) {\n    return new this(options, input)\n  };\n\n  Object.defineProperties( Parser.prototype, prototypeAccessors );\n\n  var pp = Parser.prototype;\n\n  // ## Parser utilities\n\n  var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\n  pp.strictDirective = function(start) {\n    for (;;) {\n      // Try to find string literal.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      var match = literal.exec(this.input.slice(start));\n      if (!match) { return false }\n      if ((match[1] || match[2]) === \"use strict\") { return true }\n      start += match[0].length;\n\n      // Skip semicolon, if any.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      if (this.input[start] === \";\")\n        { start++; }\n    }\n  };\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  pp.eat = function(type) {\n    if (this.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  // Tests whether parsed token is a contextual keyword.\n\n  pp.isContextual = function(name) {\n    return this.type === types.name && this.value === name && !this.containsEsc\n  };\n\n  // Consumes contextual keyword if possible.\n\n  pp.eatContextual = function(name) {\n    if (!this.isContextual(name)) { return false }\n    this.next();\n    return true\n  };\n\n  // Asserts that following token is given contextual keyword.\n\n  pp.expectContextual = function(name) {\n    if (!this.eatContextual(name)) { this.unexpected(); }\n  };\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  pp.canInsertSemicolon = function() {\n    return this.type === types.eof ||\n      this.type === types.braceR ||\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  pp.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon)\n        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n      return true\n    }\n  };\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  pp.semicolon = function() {\n    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n  };\n\n  pp.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n      if (this.options.onTrailingComma)\n        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n      if (!notNext)\n        { this.next(); }\n      return true\n    }\n  };\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  pp.expect = function(type) {\n    this.eat(type) || this.unexpected();\n  };\n\n  // Raise an unexpected token error.\n\n  pp.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  function DestructuringErrors() {\n    this.shorthandAssign =\n    this.trailingComma =\n    this.parenthesizedAssign =\n    this.parenthesizedBind =\n    this.doubleProto =\n      -1;\n  }\n\n  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) { return }\n    if (refDestructuringErrors.trailingComma > -1)\n      { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n  };\n\n  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) { return false }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n    if (shorthandAssign >= 0)\n      { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n    if (doubleProto >= 0)\n      { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n  };\n\n  pp.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n      { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n    if (this.awaitPos)\n      { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n  };\n\n  pp.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\")\n      { return this.isSimpleAssignTarget(expr.expression) }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n  };\n\n  var pp$1 = Parser.prototype;\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$1.parseTopLevel = function(node) {\n    var exports = {};\n    if (!node.body) { node.body = []; }\n    while (this.type !== types.eof) {\n      var stmt = this.parseStatement(null, true, exports);\n      node.body.push(stmt);\n    }\n    if (this.inModule)\n      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n        {\n          var name = list[i];\n\n          this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n        } }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\")\n  };\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  pp$1.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91) { return true } // '['\n    if (context) { return false }\n\n    if (nextCh === 123) { return true } // '{'\n    if (isIdentifierStart(nextCh, true)) {\n      var pos = next + 1;\n      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n      var ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) { return true }\n    }\n    return false\n  };\n\n  // check 'async [no LineTerminator here] function'\n  // - 'async /*foo*/ function' is OK.\n  // - 'async /*\\n*/ function' is invalid.\n  pp$1.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n      { return false }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length;\n    return !lineBreak.test(this.input.slice(this.pos, next)) &&\n      this.input.slice(next, next + 8) === \"function\" &&\n      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n  };\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n  pp$1.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n    case types._debugger: return this.parseDebuggerStatement(node)\n    case types._do: return this.parseDoStatement(node)\n    case types._for: return this.parseForStatement(node)\n    case types._function:\n      // Function as sole body of either an if statement or a labeled statement\n      // works, but not when it is part of a labeled statement that is the sole\n      // body of an if statement.\n      if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n      return this.parseFunctionStatement(node, false, !context)\n    case types._class:\n      if (context) { this.unexpected(); }\n      return this.parseClass(node, true)\n    case types._if: return this.parseIfStatement(node)\n    case types._return: return this.parseReturnStatement(node)\n    case types._switch: return this.parseSwitchStatement(node)\n    case types._throw: return this.parseThrowStatement(node)\n    case types._try: return this.parseTryStatement(node)\n    case types._const: case types._var:\n      kind = kind || this.value;\n      if (context && kind !== \"var\") { this.unexpected(); }\n      return this.parseVarStatement(node, kind)\n    case types._while: return this.parseWhileStatement(node)\n    case types._with: return this.parseWithStatement(node)\n    case types.braceL: return this.parseBlock(true, node)\n    case types.semi: return this.parseEmptyStatement(node)\n    case types._export:\n    case types._import:\n      if (this.options.ecmaVersion > 10 && starttype === types._import) {\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        if (nextCh === 40) // '('\n          { return this.parseExpressionStatement(node, this.parseExpression()) }\n      }\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel)\n          { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n        if (!this.inModule)\n          { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n      }\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n    default:\n      if (this.isAsyncFunction()) {\n        if (context) { this.unexpected(); }\n        this.next();\n        return this.parseFunctionStatement(node, true, !context)\n      }\n\n      var maybeName = this.value, expr = this.parseExpression();\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n        { return this.parseLabeledStatement(node, maybeName, expr, context) }\n      else { return this.parseExpressionStatement(node, expr) }\n    }\n  };\n\n  pp$1.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n    else if (this.type !== types.name) { this.unexpected(); }\n    else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    }\n\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for (; i < this.labels.length; ++i) {\n      var lab = this.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n        if (node.label && isBreak) { break }\n      }\n    }\n    if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n  };\n\n  pp$1.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\")\n  };\n\n  pp$1.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6)\n      { this.eat(types.semi); }\n    else\n      { this.semicolon(); }\n    return this.finishNode(node, \"DoWhileStatement\")\n  };\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  pp$1.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types.parenL);\n    if (this.type === types.semi) {\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, null)\n    }\n    var isLet = this.isLet();\n    if (this.type === types._var || this.type === types._const || isLet) {\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n        if (this.options.ecmaVersion >= 9) {\n          if (this.type === types._in) {\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\n          } else { node.await = awaitAt > -1; }\n        }\n        return this.parseForIn(node, init$1)\n      }\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, init$1)\n    }\n    var refDestructuringErrors = new DestructuringErrors;\n    var init = this.parseExpression(true, refDestructuringErrors);\n    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      this.toAssignable(init, false, refDestructuringErrors);\n      this.checkLVal(init);\n      return this.parseForIn(node, init)\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init)\n  };\n\n  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n  };\n\n  pp$1.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\")\n  };\n\n  pp$1.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n      { this.raise(this.start, \"'return' outside of function\"); }\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n    else { node.argument = this.parseExpression(); this.semicolon(); }\n    return this.finishNode(node, \"ReturnStatement\")\n  };\n\n  pp$1.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    var cur;\n    for (var sawDefault = false; this.type !== types.braceR;) {\n      if (this.type === types._case || this.type === types._default) {\n        var isCase = this.type === types._case;\n        if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(types.colon);\n      } else {\n        if (!cur) { this.unexpected(); }\n        cur.consequent.push(this.parseStatement(null));\n      }\n    }\n    this.exitScope();\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\")\n  };\n\n  pp$1.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n      { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\")\n  };\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  pp$1.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types._catch) {\n      var clause = this.startNode();\n      this.next();\n      if (this.eat(types.parenL)) {\n        clause.param = this.parseBindingAtom();\n        var simple = clause.param.type === \"Identifier\";\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(types.parenR);\n      } else {\n        if (this.options.ecmaVersion < 10) { this.unexpected(); }\n        clause.param = null;\n        this.enterScope(0);\n      }\n      clause.body = this.parseBlock(false);\n      this.exitScope();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer)\n      { this.raise(node.start, \"Missing catch or finally clause\"); }\n    return this.finishNode(node, \"TryStatement\")\n  };\n\n  pp$1.parseVarStatement = function(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  pp$1.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\")\n  };\n\n  pp$1.parseWithStatement = function(node) {\n    if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\")\n  };\n\n  pp$1.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\")\n  };\n\n  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n      {\n      var label = list[i$1];\n\n      if (label.name === maybeName)\n        { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    } }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n    for (var i = this.labels.length - 1; i >= 0; i--) {\n      var label$1 = this.labels[i];\n      if (label$1.statementStart === node.start) {\n        // Update information about previous labels on this node\n        label$1.statementStart = this.start;\n        label$1.kind = kind;\n      } else { break }\n    }\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\")\n  };\n\n  pp$1.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\")\n  };\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  pp$1.parseBlock = function(createNewLexicalScope, node) {\n    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n    if ( node === void 0 ) node = this.startNode();\n\n    node.body = [];\n    this.expect(types.braceL);\n    if (createNewLexicalScope) { this.enterScope(0); }\n    while (!this.eat(types.braceR)) {\n      var stmt = this.parseStatement(null);\n      node.body.push(stmt);\n    }\n    if (createNewLexicalScope) { this.exitScope(); }\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  pp$1.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.type === types.semi ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.type === types.parenR ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  pp$1.parseForIn = function(node, init) {\n    var isForIn = this.type === types._in;\n    this.next();\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (\n        !isForIn ||\n        this.options.ecmaVersion < 8 ||\n        this.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\"\n      )\n    ) {\n      this.raise(\n        init.start,\n        ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n      );\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, \"Invalid left-hand side in for-loop\");\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n  };\n\n  // Parse a list of variable declarations.\n\n  pp$1.parseVar = function(node, isFor, kind) {\n    node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      var decl = this.startNode();\n      this.parseVarId(decl, kind);\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n        this.unexpected();\n      } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n        this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) { break }\n    }\n    return node\n  };\n\n  pp$1.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n  };\n\n  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n  // Parse a function declaration or literal (depending on the\n  // `statement & FUNC_STATEMENT`).\n\n  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n        { this.unexpected(); }\n      node.generator = this.eat(types.star);\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    if (statement & FUNC_STATEMENT) {\n      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n      if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n        // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n    }\n\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n\n    if (!(statement & FUNC_STATEMENT))\n      { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  pp$1.parseFunctionParams = function(node) {\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n  };\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  pp$1.parseClass = function(node, isStatement) {\n    this.next();\n\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      var element = this.parseClassElement(node.superClass !== null);\n      if (element) {\n        classBody.body.push(element);\n        if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n          if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n          hadConstructor = true;\n        }\n      }\n    }\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.strict = oldStrict;\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  pp$1.parseClassElement = function(constructorAllowsSuper) {\n    var this$1 = this;\n\n    if (this.eat(types.semi)) { return null }\n\n    var method = this.startNode();\n    var tryContextual = function (k, noLineBreak) {\n      if ( noLineBreak === void 0 ) noLineBreak = false;\n\n      var start = this$1.start, startLoc = this$1.startLoc;\n      if (!this$1.eatContextual(k)) { return false }\n      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n      if (method.key) { this$1.unexpected(); }\n      method.computed = false;\n      method.key = this$1.startNodeAt(start, startLoc);\n      method.key.name = k;\n      this$1.finishNode(method.key, \"Identifier\");\n      return false\n    };\n\n    method.kind = \"method\";\n    method.static = tryContextual(\"static\");\n    var isGenerator = this.eat(types.star);\n    var isAsync = false;\n    if (!isGenerator) {\n      if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      } else if (tryContextual(\"get\")) {\n        method.kind = \"get\";\n      } else if (tryContextual(\"set\")) {\n        method.kind = \"set\";\n      }\n    }\n    if (!method.key) { this.parsePropertyName(method); }\n    var key = method.key;\n    var allowsDirectSuper = false;\n    if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n        key.type === \"Literal\" && key.value === \"constructor\")) {\n      if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n      if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n      if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n      method.kind = \"constructor\";\n      allowsDirectSuper = constructorAllowsSuper;\n    } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n    if (method.kind === \"get\" && method.value.params.length !== 0)\n      { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n    if (method.kind === \"set\" && method.value.params.length !== 1)\n      { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n    if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n    return method\n  };\n\n  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n    return this.finishNode(method, \"MethodDefinition\")\n  };\n\n  pp$1.parseClassId = function(node, isStatement) {\n    if (this.type === types.name) {\n      node.id = this.parseIdent();\n      if (isStatement)\n        { this.checkLVal(node.id, BIND_LEXICAL, false); }\n    } else {\n      if (isStatement === true)\n        { this.unexpected(); }\n      node.id = null;\n    }\n  };\n\n  pp$1.parseClassSuper = function(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  };\n\n  // Parses module export declaration.\n\n  pp$1.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types.star)) {\n      this.expectContextual(\"from\");\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n      this.semicolon();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(types._default)) { // export default ...\n      this.checkExport(exports, \"default\", this.lastTokStart);\n      var isAsync;\n      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n      } else if (this.type === types._class) {\n        var cNode = this.startNode();\n        node.declaration = this.parseClass(cNode, \"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(null);\n      if (node.declaration.type === \"VariableDeclaration\")\n        { this.checkVariableExport(exports, node.declaration.declarations); }\n      else\n        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n      node.specifiers = [];\n      node.source = null;\n    } else { // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers(exports);\n      if (this.eatContextual(\"from\")) {\n        if (this.type !== types.string) { this.unexpected(); }\n        node.source = this.parseExprAtom();\n      } else {\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n          // check for keywords used as local names\n          var spec = list[i];\n\n          this.checkUnreserved(spec.local);\n          // check if export is defined\n          this.checkLocalExport(spec.local);\n        }\n\n        node.source = null;\n      }\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  pp$1.checkExport = function(exports, name, pos) {\n    if (!exports) { return }\n    if (has(exports, name))\n      { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n    exports[name] = true;\n  };\n\n  pp$1.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\")\n      { this.checkExport(exports, pat.name, pat.start); }\n    else if (type === \"ObjectPattern\")\n      { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n        {\n          var prop = list[i];\n\n          this.checkPatternExport(exports, prop);\n        } }\n    else if (type === \"ArrayPattern\")\n      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n        var elt = list$1[i$1];\n\n          if (elt) { this.checkPatternExport(exports, elt); }\n      } }\n    else if (type === \"Property\")\n      { this.checkPatternExport(exports, pat.value); }\n    else if (type === \"AssignmentPattern\")\n      { this.checkPatternExport(exports, pat.left); }\n    else if (type === \"RestElement\")\n      { this.checkPatternExport(exports, pat.argument); }\n    else if (type === \"ParenthesizedExpression\")\n      { this.checkPatternExport(exports, pat.expression); }\n  };\n\n  pp$1.checkVariableExport = function(exports, decls) {\n    if (!exports) { return }\n    for (var i = 0, list = decls; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      this.checkPatternExport(exports, decl.id);\n    }\n  };\n\n  pp$1.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" ||\n      this.type.keyword === \"const\" ||\n      this.type.keyword === \"class\" ||\n      this.type.keyword === \"function\" ||\n      this.isLet() ||\n      this.isAsyncFunction()\n  };\n\n  // Parses a comma-separated list of module exports.\n\n  pp$1.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node = this.startNode();\n      node.local = this.parseIdent(true);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n      this.checkExport(exports, node.exported.name, node.exported.start);\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Parses import declaration.\n\n  pp$1.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === types.string) {\n      node.specifiers = empty;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  // Parses a comma-separated list of module imports.\n\n  pp$1.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode();\n      node.local = this.parseIdent();\n      this.checkLVal(node.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n      if (!this.eat(types.comma)) { return nodes }\n    }\n    if (this.type === types.star) {\n      var node$1 = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      node$1.local = this.parseIdent();\n      this.checkLVal(node$1.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n      return nodes\n    }\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node$2 = this.startNode();\n      node$2.imported = this.parseIdent(true);\n      if (this.eatContextual(\"as\")) {\n        node$2.local = this.parseIdent();\n      } else {\n        this.checkUnreserved(node$2.imported);\n        node$2.local = node$2.imported;\n      }\n      this.checkLVal(node$2.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Set `ExpressionStatement#directive` property for directive prologues.\n  pp$1.adaptDirectivePrologue = function(statements) {\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n  };\n  pp$1.isDirectiveCandidate = function(statement) {\n    return (\n      statement.type === \"ExpressionStatement\" &&\n      statement.expression.type === \"Literal\" &&\n      typeof statement.expression.value === \"string\" &&\n      // Reject parenthesized strings.\n      (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n    )\n  };\n\n  var pp$2 = Parser.prototype;\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\")\n          { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n        break\n\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"RestElement\":\n        break\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n\n        this.toAssignable(prop, isBinding);\n          // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n          if (\n            prop.type === \"RestElement\" &&\n            (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n          ) {\n            this.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n        break\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n        this.toAssignable(node.value, isBinding);\n        break\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        this.toAssignableList(node.elements, isBinding);\n        break\n\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n        if (node.argument.type === \"AssignmentPattern\")\n          { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n        break\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        // falls through to AssignmentPattern\n\n      case \"AssignmentPattern\":\n        break\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n        break\n\n      case \"MemberExpression\":\n        if (!isBinding) { break }\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n      }\n    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n    return node\n  };\n\n  // Convert list of expression atoms to binding list.\n\n  pp$2.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n      if (elt) { this.toAssignable(elt, isBinding); }\n    }\n    if (end) {\n      var last = exprList[end - 1];\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n        { this.unexpected(last.argument.start); }\n    }\n    return exprList\n  };\n\n  // Parses spread element.\n\n  pp$2.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\")\n  };\n\n  pp$2.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types.name)\n      { this.unexpected(); }\n\n    node.argument = this.parseBindingAtom();\n\n    return this.finishNode(node, \"RestElement\")\n  };\n\n  // Parses lvalue (assignable) atom.\n\n  pp$2.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n      switch (this.type) {\n      case types.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\")\n\n      case types.braceL:\n        return this.parseObj(true)\n      }\n    }\n    return this.parseIdent()\n  };\n\n  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (first) { first = false; }\n      else { this.expect(types.comma); }\n      if (allowEmpty && this.type === types.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n        break\n      } else if (this.type === types.ellipsis) {\n        var rest = this.parseRestBinding();\n        this.parseBindingListItem(rest);\n        elts.push(rest);\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        this.expect(close);\n        break\n      } else {\n        var elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        elts.push(elem);\n      }\n    }\n    return elts\n  };\n\n  pp$2.parseBindingListItem = function(param) {\n    return param\n  };\n\n  // Parses assignment pattern around given atom if possible.\n\n  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\")\n  };\n\n  // Verify that a node is an lval — something that can be assigned\n  // to.\n  // bindingType can be either:\n  // 'var' indicating that the lval creates a 'var' binding\n  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\n  pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    switch (expr.type) {\n    case \"Identifier\":\n      if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n        { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n        { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n      if (checkClashes) {\n        if (has(checkClashes, expr.name))\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n        checkClashes[expr.name] = true;\n      }\n      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n      break\n\n    case \"MemberExpression\":\n      if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n      break\n\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1)\n        {\n      var prop = list[i];\n\n      this.checkLVal(prop, bindingType, checkClashes);\n    }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLVal(expr.value, bindingType, checkClashes);\n      break\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n\n      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n      }\n      break\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, bindingType, checkClashes);\n      break\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, bindingType, checkClashes);\n      break\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, bindingType, checkClashes);\n      break\n\n    default:\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  };\n\n  // A recursive descent parser operates by defining functions for all\n\n  var pp$3 = Parser.prototype;\n\n  // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash —\n  // either with each other or with an init property — and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n      { return }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n      { return }\n    var key = prop.key;\n    var name;\n    switch (key.type) {\n    case \"Identifier\": name = key.name; break\n    case \"Literal\": name = String(key.value); break\n    default: return\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) {\n          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n          // Backwards-compat kludge. Can be removed in version 6.0\n          else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n        }\n        propHash.proto = true;\n      }\n      return\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n      var redefinition;\n      if (kind === \"init\") {\n        redefinition = this.strict && other.init || other.get || other.set;\n      } else {\n        redefinition = other.init || other[kind];\n      }\n      if (redefinition)\n        { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n    other[kind] = true;\n  };\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n  pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n    if (this.type === types.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n      if (this.inGenerator) { return this.parseYield(noIn) }\n      // The tokenizer will assume an expression is allowed after\n      // `yield`, but this isn't that kind of yield\n      else { this.exprAllowed = false; }\n    }\n\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n    if (refDestructuringErrors) {\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n      oldTrailingComma = refDestructuringErrors.trailingComma;\n      oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n    } else {\n      refDestructuringErrors = new DestructuringErrors;\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types.parenL || this.type === types.name)\n      { this.potentialArrowAt = this.start; }\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n    if (this.type.isAssign) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n      if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n      this.checkLVal(left);\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\")\n    } else {\n      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n    }\n    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n    if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n    return left\n  };\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    if (this.eat(types.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  // Start the precedence parser.\n\n  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n  };\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.type.binop;\n    if (prec != null && (!noIn || this.type !== types._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n        var op = this.value;\n        this.next();\n        var startPos = this.start, startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n      }\n    }\n    return left\n  };\n\n  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n  };\n\n  // Parse unary operators, both prefix and postfix.\n\n  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.type.prefix) {\n      var node = this.startNode(), update = this.type === types.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      if (update) { this.checkLVal(node.argument); }\n      else if (this.strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n      else { sawUnary = true; }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors);\n      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.operator = this.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(types.starstar))\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n    else\n      { return expr }\n  };\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  pp$3.parseExprSubscripts = function(refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors);\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n    var result = this.parseSubscripts(expr, startPos, startLoc);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n    }\n    return result\n  };\n\n  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n    while (true) {\n      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n      if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\n      base = element;\n    }\n  };\n\n  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n    var computed = this.eat(types.bracketL);\n    if (computed || this.eat(types.dot)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n      node.computed = !!computed;\n      if (computed) { this.expect(types.bracketR); }\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      this.awaitIdentPos = 0;\n      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        if (this.awaitIdentPos > 0)\n          { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types.backQuote) {\n      var node$2 = this.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this.parseTemplate({isTagged: true});\n      base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base\n  };\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  pp$3.parseExprAtom = function(refDestructuringErrors) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types.slash) { this.readRegexp(); }\n\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch (this.type) {\n    case types._super:\n      if (!this.allowSuper)\n        { this.raise(this.start, \"'super' keyword outside a method\"); }\n      node = this.startNode();\n      this.next();\n      if (this.type === types.parenL && !this.allowDirectSuper)\n        { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n      // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super ( Arguments )\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n        { this.unexpected(); }\n      return this.finishNode(node, \"Super\")\n\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\")\n\n    case types.name:\n      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n      var id = this.parseIdent(false);\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n          id = this.parseIdent(false);\n          if (this.canInsertSemicolon() || !this.eat(types.arrow))\n            { this.unexpected(); }\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n        }\n      }\n      return id\n\n    case types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {pattern: value.pattern, flags: value.flags};\n      return node\n\n    case types.num: case types.string:\n      return this.parseLiteral(this.value)\n\n    case types._null: case types._true: case types._false:\n      node = this.startNode();\n      node.value = this.type === types._null ? null : this.type === types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case types.parenL:\n      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n          { refDestructuringErrors.parenthesizedAssign = start; }\n        if (refDestructuringErrors.parenthesizedBind < 0)\n          { refDestructuringErrors.parenthesizedBind = start; }\n      }\n      return expr\n\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case types.braceL:\n      return this.parseObj(false, refDestructuringErrors)\n\n    case types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, 0)\n\n    case types._class:\n      return this.parseClass(this.startNode(), false)\n\n    case types._new:\n      return this.parseNew()\n\n    case types.backQuote:\n      return this.parseTemplate()\n\n    case types._import:\n      if (this.options.ecmaVersion >= 11) {\n        return this.parseExprImport()\n      } else {\n        return this.unexpected()\n      }\n\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$3.parseExprImport = function() {\n    var node = this.startNode();\n    this.next(); // skip `import`\n    switch (this.type) {\n    case types.parenL:\n      return this.parseDynamicImport(node)\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$3.parseDynamicImport = function(node) {\n    this.next(); // skip `(`\n\n    // Parse node.source.\n    node.source = this.parseMaybeAssign();\n\n    // Verify ending.\n    if (!this.eat(types.parenR)) {\n      var errorPos = this.start;\n      if (this.eat(types.comma) && this.eat(types.parenR)) {\n        this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n      } else {\n        this.unexpected(errorPos);\n      }\n    }\n\n    return this.finishNode(node, \"ImportExpression\")\n  };\n\n  pp$3.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n    this.next();\n    return this.finishNode(node, \"Literal\")\n  };\n\n  pp$3.parseParenExpression = function() {\n    this.expect(types.parenL);\n    var val = this.parseExpression();\n    this.expect(types.parenR);\n    return val\n  };\n\n  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n\n      var innerStartPos = this.start, innerStartLoc = this.startLoc;\n      var exprList = [], first = true, lastIsComma = false;\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      // Do not save awaitIdentPos to allow checking awaits nested in parameters\n      while (this.type !== types.parenR) {\n        first ? first = false : this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n          lastIsComma = true;\n          break\n        } else if (this.type === types.ellipsis) {\n          spreadStart = this.start;\n          exprList.push(this.parseParenItem(this.parseRestBinding()));\n          if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n          break\n        } else {\n          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n        }\n      }\n      var innerEndPos = this.start, innerEndLoc = this.startLoc;\n      this.expect(types.parenR);\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        return this.parseParenArrowList(startPos, startLoc, exprList)\n      }\n\n      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n      if (spreadStart) { this.unexpected(spreadStart); }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\")\n    } else {\n      return val\n    }\n  };\n\n  pp$3.parseParenItem = function(item) {\n    return item\n  };\n\n  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n  };\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n  var empty$1 = [];\n\n  pp$3.parseNew = function() {\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n      node.meta = meta;\n      var containsEsc = this.containsEsc;\n      node.property = this.parseIdent(true);\n      if (node.property.name !== \"target\" || containsEsc)\n        { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n      if (!this.inNonArrowFunction())\n        { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n    if (isImport && node.callee.type === \"ImportExpression\") {\n      this.raise(startPos, \"Cannot use new with import()\");\n    }\n    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n    else { node.arguments = empty$1; }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  // Parse template expression.\n\n  pp$3.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n\n    var elem = this.startNode();\n    if (this.type === types.invalidTemplate) {\n      if (!isTagged) {\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n      }\n      elem.value = {\n        raw: this.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n      };\n    }\n    this.next();\n    elem.tail = this.type === types.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  pp$3.parseTemplate = function(ref) {\n    if ( ref === void 0 ) ref = {};\n    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({isTagged: isTagged});\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  pp$3.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  // Parse an object literal or binding pattern.\n\n  pp$3.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var prop = this.parseProperty(isPattern, refDestructuringErrors);\n      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n      node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n  };\n\n  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n      if (isPattern) {\n        prop.argument = this.parseIdent(false);\n        if (this.type === types.comma) {\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\n        }\n        return this.finishNode(prop, \"RestElement\")\n      }\n      // To disallow parenthesized identifier via `this.toAssignable()`.\n      if (this.type === types.parenL && refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0) {\n          refDestructuringErrors.parenthesizedAssign = this.start;\n        }\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = this.start;\n        }\n      }\n      // Parse argument.\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n      // To disallow trailing comma via `this.toAssignable()`.\n      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this.start;\n      }\n      // Finish\n      return this.finishNode(prop, \"SpreadElement\")\n    }\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this.eat(types.star); }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      this.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\")\n  };\n\n  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types.colon)\n      { this.unexpected(); }\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n      if (isPattern) { this.unexpected(); }\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc &&\n               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type !== types.comma && this.type !== types.braceR)) {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\")\n          { this.raiseRecoverable(start, \"getter should have no params\"); }\n        else\n          { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n      } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n          { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n      }\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      this.checkUnreserved(prop.key);\n      if (prop.key.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = startPos; }\n      prop.kind = \"init\";\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else if (this.type === types.eq && refDestructuringErrors) {\n        if (refDestructuringErrors.shorthandAssign < 0)\n          { refDestructuringErrors.shorthandAssign = this.start; }\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else {\n        prop.value = prop.key;\n      }\n      prop.shorthand = true;\n    } else { this.unexpected(); }\n  };\n\n  pp$3.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(types.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(types.bracketR);\n        return prop.key\n      } else {\n        prop.computed = false;\n      }\n    }\n    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n  };\n\n  // Initialize empty function node.\n\n  pp$3.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n    if (this.options.ecmaVersion >= 8) { node.async = false; }\n  };\n\n  // Parse object or class method.\n\n  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  // Parse arrow function expression with given parameters.\n\n  pp$3.parseArrowExpression = function(node, params, isAsync) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  // Parse function body and check parameters.\n\n  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n    var isExpression = isArrowFunction && this.type !== types.braceL;\n    var oldStrict = this.strict, useStrict = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      node.expression = true;\n      this.checkParams(node, false);\n    } else {\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.end);\n        // If this is a strict mode function, verify that argument names\n        // are not repeated, and it does not try to bind the words `eval`\n        // or `arguments`.\n        if (useStrict && nonSimple)\n          { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n      }\n      // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n      var oldLabels = this.labels;\n      this.labels = [];\n      if (useStrict) { this.strict = true; }\n\n      // Add the params to varDeclaredNames to ensure that an error is thrown\n      // if a let/const declaration in the function clashes with one of the params.\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n      node.body = this.parseBlock(false);\n      node.expression = false;\n      this.adaptDirectivePrologue(node.body.body);\n      this.labels = oldLabels;\n    }\n    this.exitScope();\n\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n    this.strict = oldStrict;\n  };\n\n  pp$3.isSimpleParamList = function(params) {\n    for (var i = 0, list = params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      if (param.type !== \"Identifier\") { return false\n    } }\n    return true\n  };\n\n  // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n  pp$3.checkParams = function(node, allowDuplicates) {\n    var nameHash = {};\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n  };\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n      } else { first = false; }\n\n      var elt = (void 0);\n      if (allowEmpty && this.type === types.comma)\n        { elt = null; }\n      else if (this.type === types.ellipsis) {\n        elt = this.parseSpread(refDestructuringErrors);\n        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n          { refDestructuringErrors.trailingComma = this.start; }\n      } else {\n        elt = this.parseMaybeAssign(false, refDestructuringErrors);\n      }\n      elts.push(elt);\n    }\n    return elts\n  };\n\n  pp$3.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n\n    if (this.inGenerator && name === \"yield\")\n      { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n    if (this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n    if (this.keywords.test(name))\n      { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n    if (this.options.ecmaVersion < 6 &&\n      this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n      if (!this.inAsync && name === \"await\")\n        { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n      this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n    }\n  };\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  pp$3.parseIdent = function(liberal, isBinding) {\n    var node = this.startNode();\n    if (this.type === types.name) {\n      node.name = this.value;\n    } else if (this.type.keyword) {\n      node.name = this.type.keyword;\n\n      // To fix https://github.com/acornjs/acorn/issues/575\n      // `class` and `function` keywords push new context into this.context.\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n      if ((node.name === \"class\" || node.name === \"function\") &&\n          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n        this.context.pop();\n      }\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n      this.checkUnreserved(node);\n      if (node.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = node.start; }\n    }\n    return node\n  };\n\n  // Parses yield expression inside generator.\n\n  pp$3.parseYield = function(noIn) {\n    if (!this.yieldPos) { this.yieldPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign(noIn);\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  };\n\n  pp$3.parseAwait = function() {\n    if (!this.awaitPos) { this.awaitPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  var pp$4 = Parser.prototype;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n    throw err\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function() {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart)\n    }\n  };\n\n  var pp$5 = Parser.prototype;\n\n  var Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n  };\n\n  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n  pp$5.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n  };\n\n  pp$5.exitScope = function() {\n    this.scopeStack.pop();\n  };\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  pp$5.treatFunctionsAsVarInScope = function(scope) {\n    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n  };\n\n  pp$5.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n      var scope = this.currentScope();\n      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n      scope.lexical.push(name);\n      if (this.inModule && (scope.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n      var scope$1 = this.currentScope();\n      scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n      var scope$2 = this.currentScope();\n      if (this.treatFunctionsAsVar)\n        { redeclared = scope$2.lexical.indexOf(name) > -1; }\n      else\n        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n      scope$2.functions.push(name);\n    } else {\n      for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n        var scope$3 = this.scopeStack[i];\n        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n          redeclared = true;\n          break\n        }\n        scope$3.var.push(name);\n        if (this.inModule && (scope$3.flags & SCOPE_TOP))\n          { delete this.undefinedExports[name]; }\n        if (scope$3.flags & SCOPE_VAR) { break }\n      }\n    }\n    if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n  };\n\n  pp$5.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n        this.scopeStack[0].var.indexOf(id.name) === -1) {\n      this.undefinedExports[id.name] = id;\n    }\n  };\n\n  pp$5.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1]\n  };\n\n  pp$5.currentVarScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR) { return scope }\n    }\n  };\n\n  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  pp$5.currentThisScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n    }\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations)\n      { this.loc = new SourceLocation(parser, loc); }\n    if (parser.options.directSourceFile)\n      { this.sourceFile = parser.options.directSourceFile; }\n    if (parser.options.ranges)\n      { this.range = [pos, 0]; }\n  };\n\n  // Start an AST node, attaching a start offset.\n\n  var pp$6 = Parser.prototype;\n\n  pp$6.startNode = function() {\n    return new Node(this, this.start, this.startLoc)\n  };\n\n  pp$6.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc)\n  };\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations)\n      { node.loc.end = loc; }\n    if (this.options.ranges)\n      { node.range[1] = pos; }\n    return node\n  }\n\n  pp$6.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n  };\n\n  // Finish node at given position\n\n  pp$6.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc)\n  };\n\n  // The algorithm used to determine whether a regexp can appear at a\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n\n  var types$1 = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n  };\n\n  var pp$7 = Parser.prototype;\n\n  pp$7.initialContext = function() {\n    return [types$1.b_stat]\n  };\n\n  pp$7.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types$1.f_expr || parent === types$1.f_stat)\n      { return true }\n    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n      { return !parent.isExpr }\n\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types._return || prevType === types.name && this.exprAllowed)\n      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n      { return true }\n    if (prevType === types.braceL)\n      { return parent === types$1.b_stat }\n    if (prevType === types._var || prevType === types._const || prevType === types.name)\n      { return false }\n    return !this.exprAllowed\n  };\n\n  pp$7.inGeneratorContext = function() {\n    for (var i = this.context.length - 1; i >= 1; i--) {\n      var context = this.context[i];\n      if (context.token === \"function\")\n        { return context.generator }\n    }\n    return false\n  };\n\n  pp$7.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types.dot)\n      { this.exprAllowed = false; }\n    else if (update = type.updateContext)\n      { update.call(this, prevType); }\n    else\n      { this.exprAllowed = type.beforeExpr; }\n  };\n\n  // Token-specific context update code\n\n  types.parenR.updateContext = types.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n      this.exprAllowed = true;\n      return\n    }\n    var out = this.context.pop();\n    if (out === types$1.b_stat && this.curContext().token === \"function\") {\n      out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n  };\n\n  types.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n    this.exprAllowed = true;\n  };\n\n  types.dollarBraceL.updateContext = function() {\n    this.context.push(types$1.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  types.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n    this.exprAllowed = true;\n  };\n\n  types.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n  };\n\n  types._function.updateContext = types._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n      { this.context.push(types$1.f_expr); }\n    else\n      { this.context.push(types$1.f_stat); }\n    this.exprAllowed = false;\n  };\n\n  types.backQuote.updateContext = function() {\n    if (this.curContext() === types$1.q_tmpl)\n      { this.context.pop(); }\n    else\n      { this.context.push(types$1.q_tmpl); }\n    this.exprAllowed = false;\n  };\n\n  types.star.updateContext = function(prevType) {\n    if (prevType === types._function) {\n      var index = this.context.length - 1;\n      if (this.context[index] === types$1.f_expr)\n        { this.context[index] = types$1.f_expr_gen; }\n      else\n        { this.context[index] = types$1.f_gen; }\n    }\n    this.exprAllowed = true;\n  };\n\n  types.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n      if (this.value === \"of\" && !this.exprAllowed ||\n          this.value === \"yield\" && this.inGeneratorContext())\n        { allowed = true; }\n    }\n    this.exprAllowed = allowed;\n  };\n\n  // This file contains Unicode properties extracted from the ECMAScript\n  // specification. The lists are extracted like so:\n  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n  // #table-binary-unicode-properties\n  var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n  var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n  var ecma11BinaryProperties = ecma10BinaryProperties;\n  var unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties\n  };\n\n  // #table-unicode-general-category-values\n  var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n  // #table-unicode-script-values\n  var ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n  var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n  var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n  var unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues\n  };\n\n  var data = {};\n  function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n  buildUnicodeData(9);\n  buildUnicodeData(10);\n  buildUnicodeData(11);\n\n  var pp$8 = Parser.prototype;\n\n  var RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n  };\n\n  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  };\n\n  RegExpValidationState.prototype.raise = function raise (message) {\n    this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n  };\n\n  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n  RegExpValidationState.prototype.at = function at (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return -1\n    }\n    var c = s.charCodeAt(i);\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return c\n    }\n    return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00\n  };\n\n  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return l\n    }\n    var c = s.charCodeAt(i);\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return i + 1\n    }\n    return i + 2\n  };\n\n  RegExpValidationState.prototype.current = function current () {\n    return this.at(this.pos)\n  };\n\n  RegExpValidationState.prototype.lookahead = function lookahead () {\n    return this.at(this.nextIndex(this.pos))\n  };\n\n  RegExpValidationState.prototype.advance = function advance () {\n    this.pos = this.nextIndex(this.pos);\n  };\n\n  RegExpValidationState.prototype.eat = function eat (ch) {\n    if (this.current() === ch) {\n      this.advance();\n      return true\n    }\n    return false\n  };\n\n  function codePointToString(ch) {\n    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n    ch -= 0x10000;\n    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n  }\n\n  /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags.charAt(i);\n      if (validFlags.indexOf(flag) === -1) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n      }\n      if (flags.indexOf(flag, i + 1) > -1) {\n        this.raise(state.start, \"Duplicate regular expression flag\");\n      }\n    }\n  };\n\n  /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n      state.switchN = true;\n      this.regexp_pattern(state);\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n  pp$8.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n\n    this.regexp_disjunction(state);\n\n    if (state.pos !== state.source.length) {\n      // Make the same messages as V8.\n      if (state.eat(0x29 /* ) */)) {\n        state.raise(\"Unmatched ')'\");\n      }\n      if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n        state.raise(\"Lone quantifier brackets\");\n      }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n      state.raise(\"Invalid escape\");\n    }\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n      var name = list[i];\n\n      if (state.groupNames.indexOf(name) === -1) {\n        state.raise(\"Invalid named capture referenced\");\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n  pp$8.regexp_disjunction = function(state) {\n    this.regexp_alternative(state);\n    while (state.eat(0x7C /* | */)) {\n      this.regexp_alternative(state);\n    }\n\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n  pp$8.regexp_alternative = function(state) {\n    while (state.pos < state.source.length && this.regexp_eatTerm(state))\n      { }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n  pp$8.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n      // Handle `QuantifiableAssertion Quantifier` alternative.\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n      // is a QuantifiableAssertion.\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n        // Make the same message as V8.\n        if (state.switchU) {\n          state.raise(\"Invalid quantifier\");\n        }\n      }\n      return true\n    }\n\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n      this.regexp_eatQuantifier(state);\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n  pp$8.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n\n    // ^, $\n    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n      return true\n    }\n\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */)) {\n      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n      var lookbehind = false;\n      if (this.options.ecmaVersion >= 9) {\n        lookbehind = state.eat(0x3C /* < */);\n      }\n      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n        this.regexp_disjunction(state);\n        if (!state.eat(0x29 /* ) */)) {\n          state.raise(\"Unterminated group\");\n        }\n        state.lastAssertionIsQuantifiable = !lookbehind;\n        return true\n      }\n    }\n\n    state.pos = start;\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n  pp$8.regexp_eatQuantifier = function(state, noError) {\n    if ( noError === void 0 ) noError = false;\n\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n      state.eat(0x3F /* ? */);\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n    return (\n      state.eat(0x2A /* * */) ||\n      state.eat(0x2B /* + */) ||\n      state.eat(0x3F /* ? */) ||\n      this.regexp_eatBracedQuantifier(state, noError)\n    )\n  };\n  pp$8.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */)) {\n      var min = 0, max = -1;\n      if (this.regexp_eatDecimalDigits(state)) {\n        min = state.lastIntValue;\n        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n          max = state.lastIntValue;\n        }\n        if (state.eat(0x7D /* } */)) {\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n          if (max !== -1 && max < min && !noError) {\n            state.raise(\"numbers out of order in {} quantifier\");\n          }\n          return true\n        }\n      }\n      if (state.switchU && !noError) {\n        state.raise(\"Incomplete quantifier\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n  pp$8.regexp_eatAtom = function(state) {\n    return (\n      this.regexp_eatPatternCharacters(state) ||\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state)\n    )\n  };\n  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatAtomEscape(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */)) {\n      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */)) {\n          return true\n        }\n        state.raise(\"Unterminated group\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */)) {\n      if (this.options.ecmaVersion >= 9) {\n        this.regexp_groupSpecifier(state);\n      } else if (state.current() === 0x3F /* ? */) {\n        state.raise(\"Invalid group\");\n      }\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        state.numCapturingParens += 1;\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n  pp$8.regexp_eatExtendedAtom = function(state) {\n    return (\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state) ||\n      this.regexp_eatInvalidBracedQuantifier(state) ||\n      this.regexp_eatExtendedPatternCharacter(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n  pp$8.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isSyntaxCharacter(ch) {\n    return (\n      ch === 0x24 /* $ */ ||\n      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n      ch === 0x2E /* . */ ||\n      ch === 0x3F /* ? */ ||\n      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n  // But eat eager.\n  pp$8.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n      state.advance();\n    }\n    return state.pos !== start\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n  pp$8.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (\n      ch !== -1 &&\n      ch !== 0x24 /* $ */ &&\n      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n      ch !== 0x2E /* . */ &&\n      ch !== 0x3F /* ? */ &&\n      ch !== 0x5B /* [ */ &&\n      ch !== 0x5E /* ^ */ &&\n      ch !== 0x7C /* | */\n    ) {\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // GroupSpecifier[U] ::\n  //   [empty]\n  //   `?` GroupName[?U]\n  pp$8.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */)) {\n      if (this.regexp_eatGroupName(state)) {\n        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n          state.raise(\"Duplicate capture group name\");\n        }\n        state.groupNames.push(state.lastStringValue);\n        return\n      }\n      state.raise(\"Invalid group\");\n    }\n  };\n\n  // GroupName[U] ::\n  //   `<` RegExpIdentifierName[?U] `>`\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */)) {\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n        return true\n      }\n      state.raise(\"Invalid capture group name\");\n    }\n    return false\n  };\n\n  // RegExpIdentifierName[U] ::\n  //   RegExpIdentifierStart[?U]\n  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n      }\n      return true\n    }\n    return false\n  };\n\n  // RegExpIdentifierStart[U] ::\n  //   UnicodeIDStart\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  pp$8.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n  }\n\n  // RegExpIdentifierPart[U] ::\n  //   UnicodeIDContinue\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  //   <ZWNJ>\n  //   <ZWJ>\n  pp$8.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n  pp$8.regexp_eatAtomEscape = function(state) {\n    if (\n      this.regexp_eatBackReference(state) ||\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state) ||\n      (state.switchN && this.regexp_eatKGroupName(state))\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      if (state.current() === 0x63 /* c */) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    return false\n  };\n  pp$8.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n      var n = state.lastIntValue;\n      if (state.switchU) {\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n        if (n > state.maxBackReference) {\n          state.maxBackReference = n;\n        }\n        return true\n      }\n      if (n <= state.numCapturingParens) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */)) {\n      if (this.regexp_eatGroupName(state)) {\n        state.backReferenceNames.push(state.lastStringValue);\n        return true\n      }\n      state.raise(\"Invalid named reference\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n  pp$8.regexp_eatCharacterEscape = function(state) {\n    return (\n      this.regexp_eatControlEscape(state) ||\n      this.regexp_eatCControlLetter(state) ||\n      this.regexp_eatZero(state) ||\n      this.regexp_eatHexEscapeSequence(state) ||\n      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n      this.regexp_eatIdentityEscape(state)\n    )\n  };\n  pp$8.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */)) {\n      if (this.regexp_eatControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n      state.lastIntValue = 0;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n  pp$8.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */) {\n      state.lastIntValue = 0x09; /* \\t */\n      state.advance();\n      return true\n    }\n    if (ch === 0x6E /* n */) {\n      state.lastIntValue = 0x0A; /* \\n */\n      state.advance();\n      return true\n    }\n    if (ch === 0x76 /* v */) {\n      state.lastIntValue = 0x0B; /* \\v */\n      state.advance();\n      return true\n    }\n    if (ch === 0x66 /* f */) {\n      state.lastIntValue = 0x0C; /* \\f */\n      state.advance();\n      return true\n    }\n    if (ch === 0x72 /* r */) {\n      state.lastIntValue = 0x0D; /* \\r */\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n  pp$8.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isControlLetter(ch) {\n    return (\n      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x75 /* u */)) {\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\n        var lead = state.lastIntValue;\n        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n          var leadSurrogateEnd = state.pos;\n          if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n            var trail = state.lastIntValue;\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n              return true\n            }\n          }\n          state.pos = leadSurrogateEnd;\n          state.lastIntValue = lead;\n        }\n        return true\n      }\n      if (\n        state.switchU &&\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatHexDigits(state) &&\n        state.eat(0x7D /* } */) &&\n        isValidUnicode(state.lastIntValue)\n      ) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.pos = start;\n    }\n\n    return false\n  };\n  function isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n  pp$8.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n      if (this.regexp_eatSyntaxCharacter(state)) {\n        return true\n      }\n      if (state.eat(0x2F /* / */)) {\n        state.lastIntValue = 0x2F; /* / */\n        return true\n      }\n      return false\n    }\n\n    var ch = state.current();\n    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n  pp$8.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n      do {\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n        state.advance();\n      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n  pp$8.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n\n    if (isCharacterClassEscape(ch)) {\n      state.lastIntValue = -1;\n      state.advance();\n      return true\n    }\n\n    if (\n      state.switchU &&\n      this.options.ecmaVersion >= 9 &&\n      (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n    ) {\n      state.lastIntValue = -1;\n      state.advance();\n      if (\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatUnicodePropertyValueExpression(state) &&\n        state.eat(0x7D /* } */)\n      ) {\n        return true\n      }\n      state.raise(\"Invalid property name\");\n    }\n\n    return false\n  };\n  function isCharacterClassEscape(ch) {\n    return (\n      ch === 0x64 /* d */ ||\n      ch === 0x44 /* D */ ||\n      ch === 0x73 /* s */ ||\n      ch === 0x53 /* S */ ||\n      ch === 0x77 /* w */ ||\n      ch === 0x57 /* W */\n    )\n  }\n\n  // UnicodePropertyValueExpression ::\n  //   UnicodePropertyName `=` UnicodePropertyValue\n  //   LoneUnicodePropertyNameOrValue\n  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n      var name = state.lastStringValue;\n      if (this.regexp_eatUnicodePropertyValue(state)) {\n        var value = state.lastStringValue;\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n        return true\n      }\n    }\n    state.pos = start;\n\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n      var nameOrValue = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n      return true\n    }\n    return false\n  };\n  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!has(state.unicodeProperties.nonBinary, name))\n      { state.raise(\"Invalid property name\"); }\n    if (!state.unicodeProperties.nonBinary[name].test(value))\n      { state.raise(\"Invalid property value\"); }\n  };\n  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (!state.unicodeProperties.binary.test(nameOrValue))\n      { state.raise(\"Invalid property name\"); }\n  };\n\n  // UnicodePropertyName ::\n  //   UnicodePropertyNameCharacters\n  pp$8.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */\n  }\n\n  // UnicodePropertyValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n  }\n\n  // LoneUnicodePropertyNameOrValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state)\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n  pp$8.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */)) {\n      state.eat(0x5E /* ^ */);\n      this.regexp_classRanges(state);\n      if (state.eat(0x5D /* [ */)) {\n        return true\n      }\n      // Unreachable since it threw \"unterminated regular expression\" error before.\n      state.raise(\"Unterminated character class\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n  pp$8.regexp_classRanges = function(state) {\n    while (this.regexp_eatClassAtom(state)) {\n      var left = state.lastIntValue;\n      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n        var right = state.lastIntValue;\n        if (state.switchU && (left === -1 || right === -1)) {\n          state.raise(\"Invalid character class\");\n        }\n        if (left !== -1 && right !== -1 && left > right) {\n          state.raise(\"Range out of order in character class\");\n        }\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n  pp$8.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatClassEscape(state)) {\n        return true\n      }\n      if (state.switchU) {\n        // Make the same message as V8.\n        var ch$1 = state.current();\n        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n          state.raise(\"Invalid class escape\");\n        }\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n\n    var ch = state.current();\n    if (ch !== 0x5D /* [ */) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n  pp$8.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n\n    if (state.switchU && state.eat(0x2D /* - */)) {\n      state.lastIntValue = 0x2D; /* - */\n      return true\n    }\n\n    if (!state.switchU && state.eat(0x63 /* c */)) {\n      if (this.regexp_eatClassControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    return (\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n  pp$8.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */)) {\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n  pp$8.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isDecimalDigit(ch = state.current())) {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n  pp$8.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isHexDigit(ch = state.current())) {\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isHexDigit(ch) {\n    return (\n      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n    )\n  }\n  function hexToInt(ch) {\n    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n      return 10 + (ch - 0x41 /* A */)\n    }\n    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n      return 10 + (ch - 0x61 /* a */)\n    }\n    return ch - 0x30 /* 0 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\n  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n      var n1 = state.lastIntValue;\n      if (this.regexp_eatOctalDigit(state)) {\n        var n2 = state.lastIntValue;\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n        } else {\n          state.lastIntValue = n1 * 8 + n2;\n        }\n      } else {\n        state.lastIntValue = n1;\n      }\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n  pp$8.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n      state.lastIntValue = ch - 0x30; /* 0 */\n      state.advance();\n      return true\n    }\n    state.lastIntValue = 0;\n    return false\n  };\n  function isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for (var i = 0; i < length; ++i) {\n      var ch = state.current();\n      if (!isHexDigit(ch)) {\n        state.pos = start;\n        return false\n      }\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return true\n  };\n\n  // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations)\n      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n    if (p.options.ranges)\n      { this.range = [p.start, p.end]; }\n  };\n\n  // ## Tokenizer\n\n  var pp$9 = Parser.prototype;\n\n  // Move to the next token\n\n  pp$9.next = function() {\n    if (this.options.onToken)\n      { this.options.onToken(new Token(this)); }\n\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp$9.getToken = function() {\n    this.next();\n    return new Token(this)\n  };\n\n  // If we're in an ES6 environment, make parsers iterable\n  if (typeof Symbol !== \"undefined\")\n    { pp$9[Symbol.iterator] = function() {\n      var this$1 = this;\n\n      return {\n        next: function () {\n          var token = this$1.getToken();\n          return {\n            done: token.type === types.eof,\n            value: token\n          }\n        }\n      }\n    }; }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  pp$9.curContext = function() {\n    return this.context[this.context.length - 1]\n  };\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  pp$9.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n    this.start = this.pos;\n    if (this.options.locations) { this.startLoc = this.curPosition(); }\n    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n    if (curContext.override) { return curContext.override(this) }\n    else { this.readToken(this.fullCharCodeAtPos()); }\n  };\n\n  pp$9.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n      { return this.readWord() }\n\n    return this.getTokenFromCode(code)\n  };\n\n  pp$9.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xe000) { return code }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return (code << 10) + next - 0x35fdc00\n  };\n\n  pp$9.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n    this.pos = end + 2;\n    if (this.options.locations) {\n      lineBreakG.lastIndex = start;\n      var match;\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n        ++this.curLine;\n        this.lineStart = match.index + match[0].length;\n      }\n    }\n    if (this.options.onComment)\n      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  pp$9.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while (this.pos < this.input.length && !isNewLine(ch)) {\n      ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment)\n      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  pp$9.skipSpace = function() {\n    loop: while (this.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.pos);\n      switch (ch) {\n      case 32: case 160: // ' '\n        ++this.pos;\n        break\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n      case 10: case 8232: case 8233:\n        ++this.pos;\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        break\n      case 47: // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n        case 42: // '*'\n          this.skipBlockComment();\n          break\n        case 47:\n          this.skipLineComment(2);\n          break\n        default:\n          break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop\n        }\n      }\n    }\n  };\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  pp$9.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) { this.endLoc = this.curPosition(); }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n\n    this.updateContext(prevType);\n  };\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  pp$9.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) { return this.readNumber(true) }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(types.ellipsis)\n    } else {\n      ++this.pos;\n      return this.finishToken(types.dot)\n    }\n  };\n\n  pp$9.readToken_slash = function() { // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.slash, 1)\n  };\n\n  pp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types.star : types.modulo;\n\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n      ++size;\n      tokentype = types.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(tokentype, size)\n  };\n\n  pp$9.readToken_pipe_amp = function(code) { // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n  };\n\n  pp$9.readToken_caret = function() { // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.bitwiseXOR, 1)\n  };\n\n  pp$9.readToken_plus_min = function(code) { // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken()\n      }\n      return this.finishOp(types.incDec, 2)\n    }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.plusMin, 1)\n  };\n\n  pp$9.readToken_lt_gt = function(code) { // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n      return this.finishOp(types.bitShift, size)\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n        this.input.charCodeAt(this.pos + 3) === 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    if (next === 61) { size = 2; }\n    return this.finishOp(types.relational, size)\n  };\n\n  pp$9.readToken_eq_excl = function(code) { // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n      this.pos += 2;\n      return this.finishToken(types.arrow)\n    }\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n  };\n\n  pp$9.getTokenFromCode = function(code) {\n    switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46: // '.'\n      return this.readToken_dot()\n\n    // Punctuation tokens.\n    case 40: ++this.pos; return this.finishToken(types.parenL)\n    case 41: ++this.pos; return this.finishToken(types.parenR)\n    case 59: ++this.pos; return this.finishToken(types.semi)\n    case 44: ++this.pos; return this.finishToken(types.comma)\n    case 91: ++this.pos; return this.finishToken(types.bracketL)\n    case 93: ++this.pos; return this.finishToken(types.bracketR)\n    case 123: ++this.pos; return this.finishToken(types.braceL)\n    case 125: ++this.pos; return this.finishToken(types.braceR)\n    case 58: ++this.pos; return this.finishToken(types.colon)\n    case 63: ++this.pos; return this.finishToken(types.question)\n\n    case 96: // '`'\n      if (this.options.ecmaVersion < 6) { break }\n      ++this.pos;\n      return this.finishToken(types.backQuote)\n\n    case 48: // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return this.readNumber(false)\n\n    // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47: // '/'\n      return this.readToken_slash()\n\n    case 37: case 42: // '%*'\n      return this.readToken_mult_modulo_exp(code)\n\n    case 124: case 38: // '|&'\n      return this.readToken_pipe_amp(code)\n\n    case 94: // '^'\n      return this.readToken_caret()\n\n    case 43: case 45: // '+-'\n      return this.readToken_plus_min(code)\n\n    case 60: case 62: // '<>'\n      return this.readToken_lt_gt(code)\n\n    case 61: case 33: // '=!'\n      return this.readToken_eq_excl(code)\n\n    case 126: // '~'\n      return this.finishOp(types.prefix, 1)\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n  };\n\n  pp$9.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str)\n  };\n\n  pp$9.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n      var ch = this.input.charAt(this.pos);\n      if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n      if (!escaped) {\n        if (ch === \"[\") { inClass = true; }\n        else if (ch === \"]\" && inClass) { inClass = false; }\n        else if (ch === \"/\" && !inClass) { break }\n        escaped = ch === \"\\\\\";\n      } else { escaped = false; }\n      ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) { this.unexpected(flagsStart); }\n\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n\n    // Create Literal#value property value.\n    var value = null;\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      // ESTree requires null if it failed to instantiate RegExp object.\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n\n    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n  };\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  pp$9.readInt = function(radix, len) {\n    var start = this.pos, total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this.input.charCodeAt(this.pos), val = (void 0);\n      if (code >= 97) { val = code - 97 + 10; } // a\n      else if (code >= 65) { val = code - 65 + 10; } // A\n      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n      else { val = Infinity; }\n      if (val >= radix) { break }\n      ++this.pos;\n      total = total * radix + val;\n    }\n    if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n    return total\n  };\n\n  pp$9.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n      val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n      ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val)\n  };\n\n  // Read an integer, octal integer, or floating-point number.\n\n  pp$9.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n      var str$1 = this.input.slice(start, this.pos);\n      var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n      ++this.pos;\n      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n      return this.finishToken(types.num, val$1)\n    }\n    if (next === 46 && !octal) { // '.'\n      ++this.pos;\n      this.readInt(10);\n      next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) { // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n      if (next === 43 || next === 45) { ++this.pos; } // '+-'\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n    var str = this.input.slice(start, this.pos);\n    var val = octal ? parseInt(str, 8) : parseFloat(str);\n    return this.finishToken(types.num, val)\n  };\n\n  // Read a string value, interpreting backslash-escapes.\n\n  pp$9.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n\n    if (ch === 123) { // '{'\n      if (this.options.ecmaVersion < 6) { this.unexpected(); }\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n      ++this.pos;\n      if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n    } else {\n      code = this.readHexChar(4);\n    }\n    return code\n  };\n\n  function codePointToString$1(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) { return String.fromCharCode(code) }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n  }\n\n  pp$9.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === quote) { break }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.pos;\n      } else {\n        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n        ++this.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types.string, out)\n  };\n\n  // Reads template string tokens.\n\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\n  pp$9.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n      this.readTmplToken();\n    } catch (err) {\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n        this.readInvalidTemplateToken();\n      } else {\n        throw err\n      }\n    }\n\n    this.inTemplateElement = false;\n  };\n\n  pp$9.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n      throw INVALID_TEMPLATE_ESCAPE_ERROR\n    } else {\n      this.raise(position, message);\n    }\n  };\n\n  pp$9.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n          if (ch === 36) {\n            this.pos += 2;\n            return this.finishToken(types.dollarBraceL)\n          } else {\n            ++this.pos;\n            return this.finishToken(types.backQuote)\n          }\n        }\n        out += this.input.slice(chunkStart, this.pos);\n        return this.finishToken(types.template, out)\n      }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(true);\n        chunkStart = this.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.pos);\n        ++this.pos;\n        switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n        case 10:\n          out += \"\\n\";\n          break\n        default:\n          out += String.fromCharCode(ch);\n          break\n        }\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        chunkStart = this.pos;\n      } else {\n        ++this.pos;\n      }\n    }\n  };\n\n  // Reads a template token to search for the end, without validating any escape sequences\n  pp$9.readInvalidTemplateToken = function() {\n    for (; this.pos < this.input.length; this.pos++) {\n      switch (this.input[this.pos]) {\n      case \"\\\\\":\n        ++this.pos;\n        break\n\n      case \"$\":\n        if (this.input[this.pos + 1] !== \"{\") {\n          break\n        }\n      // falls through\n\n      case \"`\":\n        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n      // no default\n      }\n    }\n    this.raise(this.start, \"Unterminated template\");\n  };\n\n  // Used to read escaped characters\n\n  pp$9.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch (ch) {\n    case 110: return \"\\n\" // 'n' -> '\\n'\n    case 114: return \"\\r\" // 'r' -> '\\r'\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n    case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n    case 116: return \"\\t\" // 't' -> '\\t'\n    case 98: return \"\\b\" // 'b' -> '\\b'\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n    case 102: return \"\\f\" // 'f' -> '\\f'\n    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n    case 10: // ' \\n'\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n      return \"\"\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(\n            this.pos - 1 - octalStr.length,\n            inTemplate\n              ? \"Octal literal in template string\"\n              : \"Octal literal in strict mode\"\n          );\n        }\n        return String.fromCharCode(octal)\n      }\n      if (isNewLine(ch)) {\n        // Unicode new line characters after \\ get removed from output in both\n        // template literals and strings\n        return \"\"\n      }\n      return String.fromCharCode(ch)\n    }\n  };\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  pp$9.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n    return n\n  };\n\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  pp$9.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while (this.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n      if (isIdentifierChar(ch, astral)) {\n        this.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) { // \"\\\"\n        this.containsEsc = true;\n        word += this.input.slice(chunkStart, this.pos);\n        var escStart = this.pos;\n        if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n          { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n        ++this.pos;\n        var esc = this.readCodePoint();\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n          { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n        word += codePointToString$1(esc);\n        chunkStart = this.pos;\n      } else {\n        break\n      }\n      first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos)\n  };\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  pp$9.readWord = function() {\n    var word = this.readWord1();\n    var type = types.name;\n    if (this.keywords.test(word)) {\n      if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n      type = keywords$1[word];\n    }\n    return this.finishToken(type, word)\n  };\n\n  // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\n  var version = \"7.1.0\";\n\n  Parser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types,\n    keywordTypes: keywords$1,\n    TokContext: TokContext,\n    tokContexts: types$1,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n  };\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return Parser.parse(input, options)\n  }\n\n  // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n  function parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options)\n  }\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n  function tokenizer(input, options) {\n    return Parser.tokenizer(input, options)\n  }\n\n  exports.Node = Node;\n  exports.Parser = Parser;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.TokContext = TokContext;\n  exports.Token = Token;\n  exports.TokenType = TokenType;\n  exports.defaultOptions = defaultOptions;\n  exports.getLineInfo = getLineInfo;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.isNewLine = isNewLine;\n  exports.keywordTypes = keywords$1;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokContexts = types$1;\n  exports.tokTypes = types;\n  exports.tokenizer = tokenizer;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","startIndex":192393,"endIndex":192393,"highlightLines":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049,2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099,2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149,2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199,2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249,2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299,2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349,2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399,2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449,2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499,2500,2501,2502,2503,2504,2505,2506,2507,2508,2509,2510,2511,2512,2513,2514,2515,2516,2517,2518,2519,2520,2521,2522,2523,2524,2525,2526,2527,2528,2529,2530,2531,2532,2533,2534,2535,2536,2537,2538,2539,2540,2541,2542,2543,2544,2545,2546,2547,2548,2549,2550,2551,2552,2553,2554,2555,2556,2557,2558,2559,2560,2561,2562,2563,2564,2565,2566,2567,2568,2569,2570,2571,2572,2573,2574,2575,2576,2577,2578,2579,2580,2581,2582,2583,2584,2585,2586,2587,2588,2589,2590,2591,2592,2593,2594,2595,2596,2597,2598,2599,2600,2601,2602,2603,2604,2605,2606,2607,2608,2609,2610,2611,2612,2613,2614,2615,2616,2617,2618,2619,2620,2621,2622,2623,2624,2625,2626,2627,2628,2629,2630,2631,2632,2633,2634,2635,2636,2637,2638,2639,2640,2641,2642,2643,2644,2645,2646,2647,2648,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,2659,2660,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670,2671,2672,2673,2674,2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2686,2687,2688,2689,2690,2691,2692,2693,2694,2695,2696,2697,2698,2699,2700,2701,2702,2703,2704,2705,2706,2707,2708,2709,2710,2711,2712,2713,2714,2715,2716,2717,2718,2719,2720,2721,2722,2723,2724,2725,2726,2727,2728,2729,2730,2731,2732,2733,2734,2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,2751,2752,2753,2754,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765,2766,2767,2768,2769,2770,2771,2772,2773,2774,2775,2776,2777,2778,2779,2780,2781,2782,2783,2784,2785,2786,2787,2788,2789,2790,2791,2792,2793,2794,2795,2796,2797,2798,2799,2800,2801,2802,2803,2804,2805,2806,2807,2808,2809,2810,2811,2812,2813,2814,2815,2816,2817,2818,2819,2820,2821,2822,2823,2824,2825,2826,2827,2828,2829,2830,2831,2832,2833,2834,2835,2836,2837,2838,2839,2840,2841,2842,2843,2844,2845,2846,2847,2848,2849,2850,2851,2852,2853,2854,2855,2856,2857,2858,2859,2860,2861,2862,2863,2864,2865,2866,2867,2868,2869,2870,2871,2872,2873,2874,2875,2876,2877,2878,2879,2880,2881,2882,2883,2884,2885,2886,2887,2888,2889,2890,2891,2892,2893,2894,2895,2896,2897,2898,2899,2900,2901,2902,2903,2904,2905,2906,2907,2908,2909,2910,2911,2912,2913,2914,2915,2916,2917,2918,2919,2920,2921,2922,2923,2924,2925,2926,2927,2928,2929,2930,2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,2944,2945,2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,2962,2963,2964,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2992,2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,3009,3010,3011,3012,3013,3014,3015,3016,3017,3018,3019,3020,3021,3022,3023,3024,3025,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3037,3038,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,3051,3052,3053,3054,3055,3056,3057,3058,3059,3060,3061,3062,3063,3064,3065,3066,3067,3068,3069,3070,3071,3072,3073,3074,3075,3076,3077,3078,3079,3080,3081,3082,3083,3084,3085,3086,3087,3088,3089,3090,3091,3092,3093,3094,3095,3096,3097,3098,3099,3100,3101,3102,3103,3104,3105,3106,3107,3108,3109,3110,3111,3112,3113,3114,3115,3116,3117,3118,3119,3120,3121,3122,3123,3124,3125,3126,3127,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,3141,3142,3143,3144,3145,3146,3147,3148,3149,3150,3151,3152,3153,3154,3155,3156,3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168,3169,3170,3171,3172,3173,3174,3175,3176,3177,3178,3179,3180,3181,3182,3183,3184,3185,3186,3187,3188,3189,3190,3191,3192,3193,3194,3195,3196,3197,3198,3199,3200,3201,3202,3203,3204,3205,3206,3207,3208,3209,3210,3211,3212,3213,3214,3215,3216,3217,3218,3219,3220,3221,3222,3223,3224,3225,3226,3227,3228,3229,3230,3231,3232,3233,3234,3235,3236,3237,3238,3239,3240,3241,3242,3243,3244,3245,3246,3247,3248,3249,3250,3251,3252,3253,3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,3278,3279,3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,3296,3297,3298,3299,3300,3301,3302,3303,3304,3305,3306,3307,3308,3309,3310,3311,3312,3313,3314,3315,3316,3317,3318,3319,3320,3321,3322,3323,3324,3325,3326,3327,3328,3329,3330,3331,3332,3333,3334,3335,3336,3337,3338,3339,3340,3341,3342,3343,3344,3345,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,3360,3361,3362,3363,3364,3365,3366,3367,3368,3369,3370,3371,3372,3373,3374,3375,3376,3377,3378,3379,3380,3381,3382,3383,3384,3385,3386,3387,3388,3389,3390,3391,3392,3393,3394,3395,3396,3397,3398,3399,3400,3401,3402,3403,3404,3405,3406,3407,3408,3409,3410,3411,3412,3413,3414,3415,3416,3417,3418,3419,3420,3421,3422,3423,3424,3425,3426,3427,3428,3429,3430,3431,3432,3433,3434,3435,3436,3437,3438,3439,3440,3441,3442,3443,3444,3445,3446,3447,3448,3449,3450,3451,3452,3453,3454,3455,3456,3457,3458,3459,3460,3461,3462,3463,3464,3465,3466,3467,3468,3469,3470,3471,3472,3473,3474,3475,3476,3477,3478,3479,3480,3481,3482,3483,3484,3485,3486,3487,3488,3489,3490,3491,3492,3493,3494,3495,3496,3497,3498,3499,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3510,3511,3512,3513,3514,3515,3516,3517,3518,3519,3520,3521,3522,3523,3524,3525,3526,3527,3528,3529,3530,3531,3532,3533,3534,3535,3536,3537,3538,3539,3540,3541,3542,3543,3544,3545,3546,3547,3548,3549,3550,3551,3552,3553,3554,3555,3556,3557,3558,3559,3560,3561,3562,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,3574,3575,3576,3577,3578,3579,3580,3581,3582,3583,3584,3585,3586,3587,3588,3589,3590,3591,3592,3593,3594,3595,3596,3597,3598,3599,3600,3601,3602,3603,3604,3605,3606,3607,3608,3609,3610,3611,3612,3613,3614,3615,3616,3617,3618,3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3629,3630,3631,3632,3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,3643,3644,3645,3646,3647,3648,3649,3650,3651,3652,3653,3654,3655,3656,3657,3658,3659,3660,3661,3662,3663,3664,3665,3666,3667,3668,3669,3670,3671,3672,3673,3674,3675,3676,3677,3678,3679,3680,3681,3682,3683,3684,3685,3686,3687,3688,3689,3690,3691,3692,3693,3694,3695,3696,3697,3698,3699,3700,3701,3702,3703,3704,3705,3706,3707,3708,3709,3710,3711,3712,3713,3714,3715,3716,3717,3718,3719,3720,3721,3722,3723,3724,3725,3726,3727,3728,3729,3730,3731,3732,3733,3734,3735,3736,3737,3738,3739,3740,3741,3742,3743,3744,3745,3746,3747,3748,3749,3750,3751,3752,3753,3754,3755,3756,3757,3758,3759,3760,3761,3762,3763,3764,3765,3766,3767,3768,3769,3770,3771,3772,3773,3774,3775,3776,3777,3778,3779,3780,3781,3782,3783,3784,3785,3786,3787,3788,3789,3790,3791,3792,3793,3794,3795,3796,3797,3798,3799,3800,3801,3802,3803,3804,3805,3806,3807,3808,3809,3810,3811,3812,3813,3814,3815,3816,3817,3818,3819,3820,3821,3822,3823,3824,3825,3826,3827,3828,3829,3830,3831,3832,3833,3834,3835,3836,3837,3838,3839,3840,3841,3842,3843,3844,3845,3846,3847,3848,3849,3850,3851,3852,3853,3854,3855,3856,3857,3858,3859,3860,3861,3862,3863,3864,3865,3866,3867,3868,3869,3870,3871,3872,3873,3874,3875,3876,3877,3878,3879,3880,3881,3882,3883,3884,3885,3886,3887,3888,3889,3890,3891,3892,3893,3894,3895,3896,3897,3898,3899,3900,3901,3902,3903,3904,3905,3906,3907,3908,3909,3910,3911,3912,3913,3914,3915,3916,3917,3918,3919,3920,3921,3922,3923,3924,3925,3926,3927,3928,3929,3930,3931,3932,3933,3934,3935,3936,3937,3938,3939,3940,3941,3942,3943,3944,3945,3946,3947,3948,3949,3950,3951,3952,3953,3954,3955,3956,3957,3958,3959,3960,3961,3962,3963,3964,3965,3966,3967,3968,3969,3970,3971,3972,3973,3974,3975,3976,3977,3978,3979,3980,3981,3982,3983,3984,3985,3986,3987,3988,3989,3990,3991,3992,3993,3994,3995,3996,3997,3998,3999,4000,4001,4002,4003,4004,4005,4006,4007,4008,4009,4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4020,4021,4022,4023,4024,4025,4026,4027,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4039,4040,4041,4042,4043,4044,4045,4046,4047,4048,4049,4050,4051,4052,4053,4054,4055,4056,4057,4058,4059,4060,4061,4062,4063,4064,4065,4066,4067,4068,4069,4070,4071,4072,4073,4074,4075,4076,4077,4078,4079,4080,4081,4082,4083,4084,4085,4086,4087,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,4109,4110,4111,4112,4113,4114,4115,4116,4117,4118,4119,4120,4121,4122,4123,4124,4125,4126,4127,4128,4129,4130,4131,4132,4133,4134,4135,4136,4137,4138,4139,4140,4141,4142,4143,4144,4145,4146,4147,4148,4149,4150,4151,4152,4153,4154,4155,4156,4157,4158,4159,4160,4161,4162,4163,4164,4165,4166,4167,4168,4169,4170,4171,4172,4173,4174,4175,4176,4177,4178,4179,4180,4181,4182,4183,4184,4185,4186,4187,4188,4189,4190,4191,4192,4193,4194,4195,4196,4197,4198,4199,4200,4201,4202,4203,4204,4205,4206,4207,4208,4209,4210,4211,4212,4213,4214,4215,4216,4217,4218,4219,4220,4221,4222,4223,4224,4225,4226,4227,4228,4229,4230,4231,4232,4233,4234,4235,4236,4237,4238,4239,4240,4241,4242,4243,4244,4245,4246,4247,4248,4249,4250,4251,4252,4253,4254,4255,4256,4257,4258,4259,4260,4261,4262,4263,4264,4265,4266,4267,4268,4269,4270,4271,4272,4273,4274,4275,4276,4277,4278,4279,4280,4281,4282,4283,4284,4285,4286,4287,4288,4289,4290,4291,4292,4293,4294,4295,4296,4297,4298,4299,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,4311,4312,4313,4314,4315,4316,4317,4318,4319,4320,4321,4322,4323,4324,4325,4326,4327,4328,4329,4330,4331,4332,4333,4334,4335,4336,4337,4338,4339,4340,4341,4342,4343,4344,4345,4346,4347,4348,4349,4350,4351,4352,4353,4354,4355,4356,4357,4358,4359,4360,4361,4362,4363,4364,4365,4366,4367,4368,4369,4370,4371,4372,4373,4374,4375,4376,4377,4378,4379,4380,4381,4382,4383,4384,4385,4386,4387,4388,4389,4390,4391,4392,4393,4394,4395,4396,4397,4398,4399,4400,4401,4402,4403,4404,4405,4406,4407,4408,4409,4410,4411,4412,4413,4414,4415,4416,4417,4418,4419,4420,4421,4422,4423,4424,4425,4426,4427,4428,4429,4430,4431,4432,4433,4434,4435,4436,4437,4438,4439,4440,4441,4442,4443,4444,4445,4446,4447,4448,4449,4450,4451,4452,4453,4454,4455,4456,4457,4458,4459,4460,4461,4462,4463,4464,4465,4466,4467,4468,4469,4470,4471,4472,4473,4474,4475,4476,4477,4478,4479,4480,4481,4482,4483,4484,4485,4486,4487,4488,4489,4490,4491,4492,4493,4494,4495,4496,4497,4498,4499,4500,4501,4502,4503,4504,4505,4506,4507,4508,4509,4510,4511,4512,4513,4514,4515,4516,4517,4518,4519,4520,4521,4522,4523,4524,4525,4526,4527,4528,4529,4530,4531,4532,4533,4534,4535,4536,4537,4538,4539,4540,4541,4542,4543,4544,4545,4546,4547,4548,4549,4550,4551,4552,4553,4554,4555,4556,4557,4558,4559,4560,4561,4562,4563,4564,4565,4566,4567,4568,4569,4570,4571,4572,4573,4574,4575,4576,4577,4578,4579,4580,4581,4582,4583,4584,4585,4586,4587,4588,4589,4590,4591,4592,4593,4594,4595,4596,4597,4598,4599,4600,4601,4602,4603,4604,4605,4606,4607,4608,4609,4610,4611,4612,4613,4614,4615,4616,4617,4618,4619,4620,4621,4622,4623,4624,4625,4626,4627,4628,4629,4630,4631,4632,4633,4634,4635,4636,4637,4638,4639,4640,4641,4642,4643,4644,4645,4646,4647,4648,4649,4650,4651,4652,4653,4654,4655,4656,4657,4658,4659,4660,4661,4662,4663,4664,4665,4666,4667,4668,4669,4670,4671,4672,4673,4674,4675,4676,4677,4678,4679,4680,4681,4682,4683,4684,4685,4686,4687,4688,4689,4690,4691,4692,4693,4694,4695,4696,4697,4698,4699,4700,4701,4702,4703,4704,4705,4706,4707,4708,4709,4710,4711,4712,4713,4714,4715,4716,4717,4718,4719,4720,4721,4722,4723,4724,4725,4726,4727,4728,4729,4730,4731,4732,4733,4734,4735,4736,4737,4738,4739,4740,4741,4742,4743,4744,4745,4746,4747,4748,4749,4750,4751,4752,4753,4754,4755,4756,4757,4758,4759,4760,4761,4762,4763,4764,4765,4766,4767,4768,4769,4770,4771,4772,4773,4774,4775,4776,4777,4778,4779,4780,4781,4782,4783,4784,4785,4786,4787,4788,4789,4790,4791,4792,4793,4794,4795,4796,4797,4798,4799,4800,4801,4802,4803,4804,4805,4806,4807,4808,4809,4810,4811,4812,4813,4814,4815,4816,4817,4818,4819,4820,4821,4822,4823,4824,4825,4826,4827,4828,4829,4830,4831,4832,4833,4834,4835,4836,4837,4838,4839,4840,4841,4842,4843,4844,4845,4846,4847,4848,4849,4850,4851,4852,4853,4854,4855,4856,4857,4858,4859,4860,4861,4862,4863,4864,4865,4866,4867,4868,4869,4870,4871,4872,4873,4874,4875,4876,4877,4878,4879,4880,4881,4882,4883,4884,4885,4886,4887,4888,4889,4890,4891,4892,4893,4894,4895,4896,4897,4898,4899,4900,4901,4902,4903,4904,4905,4906,4907,4908,4909,4910,4911,4912,4913,4914,4915,4916,4917,4918,4919,4920,4921,4922,4923,4924,4925,4926,4927,4928,4929,4930,4931,4932,4933,4934,4935,4936,4937,4938,4939,4940,4941,4942,4943,4944,4945,4946,4947,4948,4949,4950,4951,4952,4953,4954,4955,4956,4957,4958,4959,4960,4961,4962,4963,4964,4965,4966,4967,4968,4969,4970,4971,4972,4973,4974,4975,4976,4977,4978,4979,4980,4981,4982,4983,4984,4985,4986,4987,4988,4989,4990,4991,4992,4993,4994,4995,4996,4997,4998,4999,5000]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"1","column":"63"},"end":{"line":"5","column":"2"},"code":"\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.acorn = {}));\n}(\n","startIndex":221,"endIndex":221,"highlightLines":[0,1,2,3,4]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2","column":"66"},"end":{"line":"2","column":"82"},"code":"factory(exports) \n","startIndex":16,"endIndex":16,"highlightLines":[1]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"5","column":"9"},"end":{"line":"5001","column":"2"},"code":"function (exports) { 'use strict';\n\n  // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  };\n\n  // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\n  var keywords = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  };\n\n  var keywordRelationalOperator = /^in(stanceof)?$/;\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n  // Generated by `bin/generate-identifier-regex.js`.\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n  // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range. They were\n  // generated by bin/generate-identifier-regex.js\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\n\n  // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n      if (pos > code) { return false }\n      pos += set[i + 1];\n      if (pos >= code) { return true }\n    }\n  }\n\n  // Test whether a given character code starts an identifier.\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) { return code === 36 }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes)\n  }\n\n  // Test whether a given character is part of an identifier.\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) { return code === 36 }\n    if (code < 58) { return true }\n    if (code < 65) { return false }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n  }\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var TokenType = function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywords$1 = {};\n\n  // Succinct definitions of keyword token types\n  function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n\n  var types = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    eof: new TokenType(\"eof\"),\n\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n    prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {isLoop: true}),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {isLoop: true}),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n  };\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code, ecma2019String) {\n    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n  var ref = Object.prototype;\n  var hasOwnProperty = ref.hasOwnProperty;\n  var toString = ref.toString;\n\n  // Checks if an object has a property.\n\n  function has(obj, propName) {\n    return hasOwnProperty.call(obj, propName)\n  }\n\n  var isArray = Array.isArray || (function (obj) { return (\n    toString.call(obj) === \"[object Array]\"\n  ); });\n\n  function wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n\n  // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset (n) {\n    return new Position(this.line, this.column + n)\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) { this.source = p.sourceFile; }\n  };\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreakG.lastIndex = cur;\n      var match = lineBreakG.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else {\n        return new Position(line, offset - cur)\n      }\n    }\n  }\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n    // (2019). This influences support for strict mode, the set of\n    // reserved words, and support for new syntax features. The default\n    // is 10.\n    ecmaVersion: 10,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // the position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program.\n    allowImportExportEverywhere: false,\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: false,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n  };\n\n  // Interpret and default an options object\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions)\n      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n    if (options.ecmaVersion >= 2015)\n      { options.ecmaVersion -= 2009; }\n\n    if (options.allowReserved == null)\n      { options.allowReserved = options.ecmaVersion < 5; }\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n      options.onToken = function (token) { return tokens.push(token); };\n    }\n    if (isArray(options.onComment))\n      { options.onComment = pushComment(options, options.onComment); }\n\n    return options\n  }\n\n  function pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text,\n        start: start,\n        end: end\n      };\n      if (options.locations)\n        { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n      if (options.ranges)\n        { comment.range = [start, end]; }\n      array.push(comment);\n    }\n  }\n\n  // Each scope gets a bitset that may contain these flags\n  var\n      SCOPE_TOP = 1,\n      SCOPE_FUNCTION = 2,\n      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n      SCOPE_ASYNC = 4,\n      SCOPE_GENERATOR = 8,\n      SCOPE_ARROW = 16,\n      SCOPE_SIMPLE_CATCH = 32,\n      SCOPE_SUPER = 64,\n      SCOPE_DIRECT_SUPER = 128;\n\n  function functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n  }\n\n  // Used in checkLVal and declareName to determine the type of a binding\n  var\n      BIND_NONE = 0, // Not a binding\n      BIND_VAR = 1, // Var-style binding\n      BIND_LEXICAL = 2, // Let- or const-style binding\n      BIND_FUNCTION = 3, // Function declaration\n      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n      for (var v = options.ecmaVersion;; v--)\n        { if (reserved = reservedWords[v]) { break } }\n      if (options.sourceType === \"module\") { reserved += \" await\"; }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = types.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = {};\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n      { this.skipLineComment(2); }\n\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n\n    // For RegExp validation\n    this.regexpState = null;\n  };\n\n  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\n  Parser.prototype.parse = function parse () {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node)\n  };\n\n  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\n  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n  // Switch to a getter for 7.0.0.\n  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\n  Parser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  Parser.parse = function parse (input, options) {\n    return new this(options, input).parse()\n  };\n\n  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression()\n  };\n\n  Parser.tokenizer = function tokenizer (input, options) {\n    return new this(options, input)\n  };\n\n  Object.defineProperties( Parser.prototype, prototypeAccessors );\n\n  var pp = Parser.prototype;\n\n  // ## Parser utilities\n\n  var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\n  pp.strictDirective = function(start) {\n    for (;;) {\n      // Try to find string literal.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      var match = literal.exec(this.input.slice(start));\n      if (!match) { return false }\n      if ((match[1] || match[2]) === \"use strict\") { return true }\n      start += match[0].length;\n\n      // Skip semicolon, if any.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      if (this.input[start] === \";\")\n        { start++; }\n    }\n  };\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  pp.eat = function(type) {\n    if (this.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  // Tests whether parsed token is a contextual keyword.\n\n  pp.isContextual = function(name) {\n    return this.type === types.name && this.value === name && !this.containsEsc\n  };\n\n  // Consumes contextual keyword if possible.\n\n  pp.eatContextual = function(name) {\n    if (!this.isContextual(name)) { return false }\n    this.next();\n    return true\n  };\n\n  // Asserts that following token is given contextual keyword.\n\n  pp.expectContextual = function(name) {\n    if (!this.eatContextual(name)) { this.unexpected(); }\n  };\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  pp.canInsertSemicolon = function() {\n    return this.type === types.eof ||\n      this.type === types.braceR ||\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  pp.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon)\n        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n      return true\n    }\n  };\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  pp.semicolon = function() {\n    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n  };\n\n  pp.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n      if (this.options.onTrailingComma)\n        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n      if (!notNext)\n        { this.next(); }\n      return true\n    }\n  };\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  pp.expect = function(type) {\n    this.eat(type) || this.unexpected();\n  };\n\n  // Raise an unexpected token error.\n\n  pp.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  function DestructuringErrors() {\n    this.shorthandAssign =\n    this.trailingComma =\n    this.parenthesizedAssign =\n    this.parenthesizedBind =\n    this.doubleProto =\n      -1;\n  }\n\n  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) { return }\n    if (refDestructuringErrors.trailingComma > -1)\n      { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n  };\n\n  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) { return false }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n    if (shorthandAssign >= 0)\n      { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n    if (doubleProto >= 0)\n      { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n  };\n\n  pp.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n      { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n    if (this.awaitPos)\n      { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n  };\n\n  pp.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\")\n      { return this.isSimpleAssignTarget(expr.expression) }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n  };\n\n  var pp$1 = Parser.prototype;\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$1.parseTopLevel = function(node) {\n    var exports = {};\n    if (!node.body) { node.body = []; }\n    while (this.type !== types.eof) {\n      var stmt = this.parseStatement(null, true, exports);\n      node.body.push(stmt);\n    }\n    if (this.inModule)\n      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n        {\n          var name = list[i];\n\n          this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n        } }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\")\n  };\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  pp$1.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91) { return true } // '['\n    if (context) { return false }\n\n    if (nextCh === 123) { return true } // '{'\n    if (isIdentifierStart(nextCh, true)) {\n      var pos = next + 1;\n      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n      var ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) { return true }\n    }\n    return false\n  };\n\n  // check 'async [no LineTerminator here] function'\n  // - 'async /*foo*/ function' is OK.\n  // - 'async /*\\n*/ function' is invalid.\n  pp$1.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n      { return false }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length;\n    return !lineBreak.test(this.input.slice(this.pos, next)) &&\n      this.input.slice(next, next + 8) === \"function\" &&\n      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n  };\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n  pp$1.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n    case types._debugger: return this.parseDebuggerStatement(node)\n    case types._do: return this.parseDoStatement(node)\n    case types._for: return this.parseForStatement(node)\n    case types._function:\n      // Function as sole body of either an if statement or a labeled statement\n      // works, but not when it is part of a labeled statement that is the sole\n      // body of an if statement.\n      if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n      return this.parseFunctionStatement(node, false, !context)\n    case types._class:\n      if (context) { this.unexpected(); }\n      return this.parseClass(node, true)\n    case types._if: return this.parseIfStatement(node)\n    case types._return: return this.parseReturnStatement(node)\n    case types._switch: return this.parseSwitchStatement(node)\n    case types._throw: return this.parseThrowStatement(node)\n    case types._try: return this.parseTryStatement(node)\n    case types._const: case types._var:\n      kind = kind || this.value;\n      if (context && kind !== \"var\") { this.unexpected(); }\n      return this.parseVarStatement(node, kind)\n    case types._while: return this.parseWhileStatement(node)\n    case types._with: return this.parseWithStatement(node)\n    case types.braceL: return this.parseBlock(true, node)\n    case types.semi: return this.parseEmptyStatement(node)\n    case types._export:\n    case types._import:\n      if (this.options.ecmaVersion > 10 && starttype === types._import) {\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        if (nextCh === 40) // '('\n          { return this.parseExpressionStatement(node, this.parseExpression()) }\n      }\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel)\n          { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n        if (!this.inModule)\n          { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n      }\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n    default:\n      if (this.isAsyncFunction()) {\n        if (context) { this.unexpected(); }\n        this.next();\n        return this.parseFunctionStatement(node, true, !context)\n      }\n\n      var maybeName = this.value, expr = this.parseExpression();\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n        { return this.parseLabeledStatement(node, maybeName, expr, context) }\n      else { return this.parseExpressionStatement(node, expr) }\n    }\n  };\n\n  pp$1.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n    else if (this.type !== types.name) { this.unexpected(); }\n    else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    }\n\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for (; i < this.labels.length; ++i) {\n      var lab = this.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n        if (node.label && isBreak) { break }\n      }\n    }\n    if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n  };\n\n  pp$1.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\")\n  };\n\n  pp$1.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6)\n      { this.eat(types.semi); }\n    else\n      { this.semicolon(); }\n    return this.finishNode(node, \"DoWhileStatement\")\n  };\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  pp$1.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types.parenL);\n    if (this.type === types.semi) {\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, null)\n    }\n    var isLet = this.isLet();\n    if (this.type === types._var || this.type === types._const || isLet) {\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n        if (this.options.ecmaVersion >= 9) {\n          if (this.type === types._in) {\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\n          } else { node.await = awaitAt > -1; }\n        }\n        return this.parseForIn(node, init$1)\n      }\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, init$1)\n    }\n    var refDestructuringErrors = new DestructuringErrors;\n    var init = this.parseExpression(true, refDestructuringErrors);\n    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      this.toAssignable(init, false, refDestructuringErrors);\n      this.checkLVal(init);\n      return this.parseForIn(node, init)\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init)\n  };\n\n  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n  };\n\n  pp$1.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\")\n  };\n\n  pp$1.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n      { this.raise(this.start, \"'return' outside of function\"); }\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n    else { node.argument = this.parseExpression(); this.semicolon(); }\n    return this.finishNode(node, \"ReturnStatement\")\n  };\n\n  pp$1.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    var cur;\n    for (var sawDefault = false; this.type !== types.braceR;) {\n      if (this.type === types._case || this.type === types._default) {\n        var isCase = this.type === types._case;\n        if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(types.colon);\n      } else {\n        if (!cur) { this.unexpected(); }\n        cur.consequent.push(this.parseStatement(null));\n      }\n    }\n    this.exitScope();\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\")\n  };\n\n  pp$1.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n      { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\")\n  };\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  pp$1.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types._catch) {\n      var clause = this.startNode();\n      this.next();\n      if (this.eat(types.parenL)) {\n        clause.param = this.parseBindingAtom();\n        var simple = clause.param.type === \"Identifier\";\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(types.parenR);\n      } else {\n        if (this.options.ecmaVersion < 10) { this.unexpected(); }\n        clause.param = null;\n        this.enterScope(0);\n      }\n      clause.body = this.parseBlock(false);\n      this.exitScope();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer)\n      { this.raise(node.start, \"Missing catch or finally clause\"); }\n    return this.finishNode(node, \"TryStatement\")\n  };\n\n  pp$1.parseVarStatement = function(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  pp$1.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\")\n  };\n\n  pp$1.parseWithStatement = function(node) {\n    if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\")\n  };\n\n  pp$1.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\")\n  };\n\n  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n      {\n      var label = list[i$1];\n\n      if (label.name === maybeName)\n        { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    } }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n    for (var i = this.labels.length - 1; i >= 0; i--) {\n      var label$1 = this.labels[i];\n      if (label$1.statementStart === node.start) {\n        // Update information about previous labels on this node\n        label$1.statementStart = this.start;\n        label$1.kind = kind;\n      } else { break }\n    }\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\")\n  };\n\n  pp$1.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\")\n  };\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  pp$1.parseBlock = function(createNewLexicalScope, node) {\n    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n    if ( node === void 0 ) node = this.startNode();\n\n    node.body = [];\n    this.expect(types.braceL);\n    if (createNewLexicalScope) { this.enterScope(0); }\n    while (!this.eat(types.braceR)) {\n      var stmt = this.parseStatement(null);\n      node.body.push(stmt);\n    }\n    if (createNewLexicalScope) { this.exitScope(); }\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  pp$1.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.type === types.semi ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.type === types.parenR ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  pp$1.parseForIn = function(node, init) {\n    var isForIn = this.type === types._in;\n    this.next();\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (\n        !isForIn ||\n        this.options.ecmaVersion < 8 ||\n        this.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\"\n      )\n    ) {\n      this.raise(\n        init.start,\n        ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n      );\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, \"Invalid left-hand side in for-loop\");\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n  };\n\n  // Parse a list of variable declarations.\n\n  pp$1.parseVar = function(node, isFor, kind) {\n    node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      var decl = this.startNode();\n      this.parseVarId(decl, kind);\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n        this.unexpected();\n      } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n        this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) { break }\n    }\n    return node\n  };\n\n  pp$1.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n  };\n\n  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n  // Parse a function declaration or literal (depending on the\n  // `statement & FUNC_STATEMENT`).\n\n  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n        { this.unexpected(); }\n      node.generator = this.eat(types.star);\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    if (statement & FUNC_STATEMENT) {\n      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n      if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n        // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n    }\n\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n\n    if (!(statement & FUNC_STATEMENT))\n      { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  pp$1.parseFunctionParams = function(node) {\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n  };\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  pp$1.parseClass = function(node, isStatement) {\n    this.next();\n\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      var element = this.parseClassElement(node.superClass !== null);\n      if (element) {\n        classBody.body.push(element);\n        if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n          if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n          hadConstructor = true;\n        }\n      }\n    }\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.strict = oldStrict;\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  pp$1.parseClassElement = function(constructorAllowsSuper) {\n    var this$1 = this;\n\n    if (this.eat(types.semi)) { return null }\n\n    var method = this.startNode();\n    var tryContextual = function (k, noLineBreak) {\n      if ( noLineBreak === void 0 ) noLineBreak = false;\n\n      var start = this$1.start, startLoc = this$1.startLoc;\n      if (!this$1.eatContextual(k)) { return false }\n      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n      if (method.key) { this$1.unexpected(); }\n      method.computed = false;\n      method.key = this$1.startNodeAt(start, startLoc);\n      method.key.name = k;\n      this$1.finishNode(method.key, \"Identifier\");\n      return false\n    };\n\n    method.kind = \"method\";\n    method.static = tryContextual(\"static\");\n    var isGenerator = this.eat(types.star);\n    var isAsync = false;\n    if (!isGenerator) {\n      if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      } else if (tryContextual(\"get\")) {\n        method.kind = \"get\";\n      } else if (tryContextual(\"set\")) {\n        method.kind = \"set\";\n      }\n    }\n    if (!method.key) { this.parsePropertyName(method); }\n    var key = method.key;\n    var allowsDirectSuper = false;\n    if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n        key.type === \"Literal\" && key.value === \"constructor\")) {\n      if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n      if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n      if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n      method.kind = \"constructor\";\n      allowsDirectSuper = constructorAllowsSuper;\n    } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n    if (method.kind === \"get\" && method.value.params.length !== 0)\n      { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n    if (method.kind === \"set\" && method.value.params.length !== 1)\n      { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n    if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n    return method\n  };\n\n  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n    return this.finishNode(method, \"MethodDefinition\")\n  };\n\n  pp$1.parseClassId = function(node, isStatement) {\n    if (this.type === types.name) {\n      node.id = this.parseIdent();\n      if (isStatement)\n        { this.checkLVal(node.id, BIND_LEXICAL, false); }\n    } else {\n      if (isStatement === true)\n        { this.unexpected(); }\n      node.id = null;\n    }\n  };\n\n  pp$1.parseClassSuper = function(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  };\n\n  // Parses module export declaration.\n\n  pp$1.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types.star)) {\n      this.expectContextual(\"from\");\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n      this.semicolon();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(types._default)) { // export default ...\n      this.checkExport(exports, \"default\", this.lastTokStart);\n      var isAsync;\n      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n      } else if (this.type === types._class) {\n        var cNode = this.startNode();\n        node.declaration = this.parseClass(cNode, \"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(null);\n      if (node.declaration.type === \"VariableDeclaration\")\n        { this.checkVariableExport(exports, node.declaration.declarations); }\n      else\n        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n      node.specifiers = [];\n      node.source = null;\n    } else { // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers(exports);\n      if (this.eatContextual(\"from\")) {\n        if (this.type !== types.string) { this.unexpected(); }\n        node.source = this.parseExprAtom();\n      } else {\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n          // check for keywords used as local names\n          var spec = list[i];\n\n          this.checkUnreserved(spec.local);\n          // check if export is defined\n          this.checkLocalExport(spec.local);\n        }\n\n        node.source = null;\n      }\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  pp$1.checkExport = function(exports, name, pos) {\n    if (!exports) { return }\n    if (has(exports, name))\n      { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n    exports[name] = true;\n  };\n\n  pp$1.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\")\n      { this.checkExport(exports, pat.name, pat.start); }\n    else if (type === \"ObjectPattern\")\n      { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n        {\n          var prop = list[i];\n\n          this.checkPatternExport(exports, prop);\n        } }\n    else if (type === \"ArrayPattern\")\n      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n        var elt = list$1[i$1];\n\n          if (elt) { this.checkPatternExport(exports, elt); }\n      } }\n    else if (type === \"Property\")\n      { this.checkPatternExport(exports, pat.value); }\n    else if (type === \"AssignmentPattern\")\n      { this.checkPatternExport(exports, pat.left); }\n    else if (type === \"RestElement\")\n      { this.checkPatternExport(exports, pat.argument); }\n    else if (type === \"ParenthesizedExpression\")\n      { this.checkPatternExport(exports, pat.expression); }\n  };\n\n  pp$1.checkVariableExport = function(exports, decls) {\n    if (!exports) { return }\n    for (var i = 0, list = decls; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      this.checkPatternExport(exports, decl.id);\n    }\n  };\n\n  pp$1.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" ||\n      this.type.keyword === \"const\" ||\n      this.type.keyword === \"class\" ||\n      this.type.keyword === \"function\" ||\n      this.isLet() ||\n      this.isAsyncFunction()\n  };\n\n  // Parses a comma-separated list of module exports.\n\n  pp$1.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node = this.startNode();\n      node.local = this.parseIdent(true);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n      this.checkExport(exports, node.exported.name, node.exported.start);\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Parses import declaration.\n\n  pp$1.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === types.string) {\n      node.specifiers = empty;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  // Parses a comma-separated list of module imports.\n\n  pp$1.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode();\n      node.local = this.parseIdent();\n      this.checkLVal(node.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n      if (!this.eat(types.comma)) { return nodes }\n    }\n    if (this.type === types.star) {\n      var node$1 = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      node$1.local = this.parseIdent();\n      this.checkLVal(node$1.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n      return nodes\n    }\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node$2 = this.startNode();\n      node$2.imported = this.parseIdent(true);\n      if (this.eatContextual(\"as\")) {\n        node$2.local = this.parseIdent();\n      } else {\n        this.checkUnreserved(node$2.imported);\n        node$2.local = node$2.imported;\n      }\n      this.checkLVal(node$2.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Set `ExpressionStatement#directive` property for directive prologues.\n  pp$1.adaptDirectivePrologue = function(statements) {\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n  };\n  pp$1.isDirectiveCandidate = function(statement) {\n    return (\n      statement.type === \"ExpressionStatement\" &&\n      statement.expression.type === \"Literal\" &&\n      typeof statement.expression.value === \"string\" &&\n      // Reject parenthesized strings.\n      (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n    )\n  };\n\n  var pp$2 = Parser.prototype;\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\")\n          { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n        break\n\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"RestElement\":\n        break\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n\n        this.toAssignable(prop, isBinding);\n          // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n          if (\n            prop.type === \"RestElement\" &&\n            (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n          ) {\n            this.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n        break\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n        this.toAssignable(node.value, isBinding);\n        break\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        this.toAssignableList(node.elements, isBinding);\n        break\n\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n        if (node.argument.type === \"AssignmentPattern\")\n          { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n        break\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        // falls through to AssignmentPattern\n\n      case \"AssignmentPattern\":\n        break\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n        break\n\n      case \"MemberExpression\":\n        if (!isBinding) { break }\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n      }\n    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n    return node\n  };\n\n  // Convert list of expression atoms to binding list.\n\n  pp$2.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n      if (elt) { this.toAssignable(elt, isBinding); }\n    }\n    if (end) {\n      var last = exprList[end - 1];\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n        { this.unexpected(last.argument.start); }\n    }\n    return exprList\n  };\n\n  // Parses spread element.\n\n  pp$2.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\")\n  };\n\n  pp$2.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types.name)\n      { this.unexpected(); }\n\n    node.argument = this.parseBindingAtom();\n\n    return this.finishNode(node, \"RestElement\")\n  };\n\n  // Parses lvalue (assignable) atom.\n\n  pp$2.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n      switch (this.type) {\n      case types.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\")\n\n      case types.braceL:\n        return this.parseObj(true)\n      }\n    }\n    return this.parseIdent()\n  };\n\n  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (first) { first = false; }\n      else { this.expect(types.comma); }\n      if (allowEmpty && this.type === types.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n        break\n      } else if (this.type === types.ellipsis) {\n        var rest = this.parseRestBinding();\n        this.parseBindingListItem(rest);\n        elts.push(rest);\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        this.expect(close);\n        break\n      } else {\n        var elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        elts.push(elem);\n      }\n    }\n    return elts\n  };\n\n  pp$2.parseBindingListItem = function(param) {\n    return param\n  };\n\n  // Parses assignment pattern around given atom if possible.\n\n  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\")\n  };\n\n  // Verify that a node is an lval — something that can be assigned\n  // to.\n  // bindingType can be either:\n  // 'var' indicating that the lval creates a 'var' binding\n  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\n  pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    switch (expr.type) {\n    case \"Identifier\":\n      if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n        { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n        { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n      if (checkClashes) {\n        if (has(checkClashes, expr.name))\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n        checkClashes[expr.name] = true;\n      }\n      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n      break\n\n    case \"MemberExpression\":\n      if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n      break\n\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1)\n        {\n      var prop = list[i];\n\n      this.checkLVal(prop, bindingType, checkClashes);\n    }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLVal(expr.value, bindingType, checkClashes);\n      break\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n\n      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n      }\n      break\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, bindingType, checkClashes);\n      break\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, bindingType, checkClashes);\n      break\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, bindingType, checkClashes);\n      break\n\n    default:\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  };\n\n  // A recursive descent parser operates by defining functions for all\n\n  var pp$3 = Parser.prototype;\n\n  // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash —\n  // either with each other or with an init property — and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n      { return }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n      { return }\n    var key = prop.key;\n    var name;\n    switch (key.type) {\n    case \"Identifier\": name = key.name; break\n    case \"Literal\": name = String(key.value); break\n    default: return\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) {\n          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n          // Backwards-compat kludge. Can be removed in version 6.0\n          else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n        }\n        propHash.proto = true;\n      }\n      return\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n      var redefinition;\n      if (kind === \"init\") {\n        redefinition = this.strict && other.init || other.get || other.set;\n      } else {\n        redefinition = other.init || other[kind];\n      }\n      if (redefinition)\n        { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n    other[kind] = true;\n  };\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n  pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n    if (this.type === types.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n      if (this.inGenerator) { return this.parseYield(noIn) }\n      // The tokenizer will assume an expression is allowed after\n      // `yield`, but this isn't that kind of yield\n      else { this.exprAllowed = false; }\n    }\n\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n    if (refDestructuringErrors) {\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n      oldTrailingComma = refDestructuringErrors.trailingComma;\n      oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n    } else {\n      refDestructuringErrors = new DestructuringErrors;\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types.parenL || this.type === types.name)\n      { this.potentialArrowAt = this.start; }\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n    if (this.type.isAssign) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n      if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n      this.checkLVal(left);\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\")\n    } else {\n      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n    }\n    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n    if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n    return left\n  };\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    if (this.eat(types.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  // Start the precedence parser.\n\n  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n  };\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.type.binop;\n    if (prec != null && (!noIn || this.type !== types._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n        var op = this.value;\n        this.next();\n        var startPos = this.start, startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n      }\n    }\n    return left\n  };\n\n  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n  };\n\n  // Parse unary operators, both prefix and postfix.\n\n  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.type.prefix) {\n      var node = this.startNode(), update = this.type === types.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      if (update) { this.checkLVal(node.argument); }\n      else if (this.strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n      else { sawUnary = true; }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors);\n      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.operator = this.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(types.starstar))\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n    else\n      { return expr }\n  };\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  pp$3.parseExprSubscripts = function(refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors);\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n    var result = this.parseSubscripts(expr, startPos, startLoc);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n    }\n    return result\n  };\n\n  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n    while (true) {\n      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n      if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\n      base = element;\n    }\n  };\n\n  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n    var computed = this.eat(types.bracketL);\n    if (computed || this.eat(types.dot)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n      node.computed = !!computed;\n      if (computed) { this.expect(types.bracketR); }\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      this.awaitIdentPos = 0;\n      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        if (this.awaitIdentPos > 0)\n          { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types.backQuote) {\n      var node$2 = this.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this.parseTemplate({isTagged: true});\n      base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base\n  };\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  pp$3.parseExprAtom = function(refDestructuringErrors) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types.slash) { this.readRegexp(); }\n\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch (this.type) {\n    case types._super:\n      if (!this.allowSuper)\n        { this.raise(this.start, \"'super' keyword outside a method\"); }\n      node = this.startNode();\n      this.next();\n      if (this.type === types.parenL && !this.allowDirectSuper)\n        { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n      // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super ( Arguments )\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n        { this.unexpected(); }\n      return this.finishNode(node, \"Super\")\n\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\")\n\n    case types.name:\n      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n      var id = this.parseIdent(false);\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n          id = this.parseIdent(false);\n          if (this.canInsertSemicolon() || !this.eat(types.arrow))\n            { this.unexpected(); }\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n        }\n      }\n      return id\n\n    case types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {pattern: value.pattern, flags: value.flags};\n      return node\n\n    case types.num: case types.string:\n      return this.parseLiteral(this.value)\n\n    case types._null: case types._true: case types._false:\n      node = this.startNode();\n      node.value = this.type === types._null ? null : this.type === types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case types.parenL:\n      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n          { refDestructuringErrors.parenthesizedAssign = start; }\n        if (refDestructuringErrors.parenthesizedBind < 0)\n          { refDestructuringErrors.parenthesizedBind = start; }\n      }\n      return expr\n\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case types.braceL:\n      return this.parseObj(false, refDestructuringErrors)\n\n    case types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, 0)\n\n    case types._class:\n      return this.parseClass(this.startNode(), false)\n\n    case types._new:\n      return this.parseNew()\n\n    case types.backQuote:\n      return this.parseTemplate()\n\n    case types._import:\n      if (this.options.ecmaVersion >= 11) {\n        return this.parseExprImport()\n      } else {\n        return this.unexpected()\n      }\n\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$3.parseExprImport = function() {\n    var node = this.startNode();\n    this.next(); // skip `import`\n    switch (this.type) {\n    case types.parenL:\n      return this.parseDynamicImport(node)\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$3.parseDynamicImport = function(node) {\n    this.next(); // skip `(`\n\n    // Parse node.source.\n    node.source = this.parseMaybeAssign();\n\n    // Verify ending.\n    if (!this.eat(types.parenR)) {\n      var errorPos = this.start;\n      if (this.eat(types.comma) && this.eat(types.parenR)) {\n        this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n      } else {\n        this.unexpected(errorPos);\n      }\n    }\n\n    return this.finishNode(node, \"ImportExpression\")\n  };\n\n  pp$3.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n    this.next();\n    return this.finishNode(node, \"Literal\")\n  };\n\n  pp$3.parseParenExpression = function() {\n    this.expect(types.parenL);\n    var val = this.parseExpression();\n    this.expect(types.parenR);\n    return val\n  };\n\n  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n\n      var innerStartPos = this.start, innerStartLoc = this.startLoc;\n      var exprList = [], first = true, lastIsComma = false;\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      // Do not save awaitIdentPos to allow checking awaits nested in parameters\n      while (this.type !== types.parenR) {\n        first ? first = false : this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n          lastIsComma = true;\n          break\n        } else if (this.type === types.ellipsis) {\n          spreadStart = this.start;\n          exprList.push(this.parseParenItem(this.parseRestBinding()));\n          if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n          break\n        } else {\n          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n        }\n      }\n      var innerEndPos = this.start, innerEndLoc = this.startLoc;\n      this.expect(types.parenR);\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        return this.parseParenArrowList(startPos, startLoc, exprList)\n      }\n\n      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n      if (spreadStart) { this.unexpected(spreadStart); }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\")\n    } else {\n      return val\n    }\n  };\n\n  pp$3.parseParenItem = function(item) {\n    return item\n  };\n\n  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n  };\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n  var empty$1 = [];\n\n  pp$3.parseNew = function() {\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n      node.meta = meta;\n      var containsEsc = this.containsEsc;\n      node.property = this.parseIdent(true);\n      if (node.property.name !== \"target\" || containsEsc)\n        { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n      if (!this.inNonArrowFunction())\n        { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n    if (isImport && node.callee.type === \"ImportExpression\") {\n      this.raise(startPos, \"Cannot use new with import()\");\n    }\n    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n    else { node.arguments = empty$1; }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  // Parse template expression.\n\n  pp$3.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n\n    var elem = this.startNode();\n    if (this.type === types.invalidTemplate) {\n      if (!isTagged) {\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n      }\n      elem.value = {\n        raw: this.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n      };\n    }\n    this.next();\n    elem.tail = this.type === types.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  pp$3.parseTemplate = function(ref) {\n    if ( ref === void 0 ) ref = {};\n    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({isTagged: isTagged});\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  pp$3.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  // Parse an object literal or binding pattern.\n\n  pp$3.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var prop = this.parseProperty(isPattern, refDestructuringErrors);\n      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n      node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n  };\n\n  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n      if (isPattern) {\n        prop.argument = this.parseIdent(false);\n        if (this.type === types.comma) {\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\n        }\n        return this.finishNode(prop, \"RestElement\")\n      }\n      // To disallow parenthesized identifier via `this.toAssignable()`.\n      if (this.type === types.parenL && refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0) {\n          refDestructuringErrors.parenthesizedAssign = this.start;\n        }\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = this.start;\n        }\n      }\n      // Parse argument.\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n      // To disallow trailing comma via `this.toAssignable()`.\n      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this.start;\n      }\n      // Finish\n      return this.finishNode(prop, \"SpreadElement\")\n    }\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this.eat(types.star); }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      this.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\")\n  };\n\n  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types.colon)\n      { this.unexpected(); }\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n      if (isPattern) { this.unexpected(); }\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc &&\n               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type !== types.comma && this.type !== types.braceR)) {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\")\n          { this.raiseRecoverable(start, \"getter should have no params\"); }\n        else\n          { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n      } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n          { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n      }\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      this.checkUnreserved(prop.key);\n      if (prop.key.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = startPos; }\n      prop.kind = \"init\";\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else if (this.type === types.eq && refDestructuringErrors) {\n        if (refDestructuringErrors.shorthandAssign < 0)\n          { refDestructuringErrors.shorthandAssign = this.start; }\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else {\n        prop.value = prop.key;\n      }\n      prop.shorthand = true;\n    } else { this.unexpected(); }\n  };\n\n  pp$3.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(types.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(types.bracketR);\n        return prop.key\n      } else {\n        prop.computed = false;\n      }\n    }\n    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n  };\n\n  // Initialize empty function node.\n\n  pp$3.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n    if (this.options.ecmaVersion >= 8) { node.async = false; }\n  };\n\n  // Parse object or class method.\n\n  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  // Parse arrow function expression with given parameters.\n\n  pp$3.parseArrowExpression = function(node, params, isAsync) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  // Parse function body and check parameters.\n\n  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n    var isExpression = isArrowFunction && this.type !== types.braceL;\n    var oldStrict = this.strict, useStrict = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      node.expression = true;\n      this.checkParams(node, false);\n    } else {\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.end);\n        // If this is a strict mode function, verify that argument names\n        // are not repeated, and it does not try to bind the words `eval`\n        // or `arguments`.\n        if (useStrict && nonSimple)\n          { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n      }\n      // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n      var oldLabels = this.labels;\n      this.labels = [];\n      if (useStrict) { this.strict = true; }\n\n      // Add the params to varDeclaredNames to ensure that an error is thrown\n      // if a let/const declaration in the function clashes with one of the params.\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n      node.body = this.parseBlock(false);\n      node.expression = false;\n      this.adaptDirectivePrologue(node.body.body);\n      this.labels = oldLabels;\n    }\n    this.exitScope();\n\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n    this.strict = oldStrict;\n  };\n\n  pp$3.isSimpleParamList = function(params) {\n    for (var i = 0, list = params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      if (param.type !== \"Identifier\") { return false\n    } }\n    return true\n  };\n\n  // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n  pp$3.checkParams = function(node, allowDuplicates) {\n    var nameHash = {};\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n  };\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n      } else { first = false; }\n\n      var elt = (void 0);\n      if (allowEmpty && this.type === types.comma)\n        { elt = null; }\n      else if (this.type === types.ellipsis) {\n        elt = this.parseSpread(refDestructuringErrors);\n        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n          { refDestructuringErrors.trailingComma = this.start; }\n      } else {\n        elt = this.parseMaybeAssign(false, refDestructuringErrors);\n      }\n      elts.push(elt);\n    }\n    return elts\n  };\n\n  pp$3.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n\n    if (this.inGenerator && name === \"yield\")\n      { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n    if (this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n    if (this.keywords.test(name))\n      { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n    if (this.options.ecmaVersion < 6 &&\n      this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n      if (!this.inAsync && name === \"await\")\n        { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n      this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n    }\n  };\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  pp$3.parseIdent = function(liberal, isBinding) {\n    var node = this.startNode();\n    if (this.type === types.name) {\n      node.name = this.value;\n    } else if (this.type.keyword) {\n      node.name = this.type.keyword;\n\n      // To fix https://github.com/acornjs/acorn/issues/575\n      // `class` and `function` keywords push new context into this.context.\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n      if ((node.name === \"class\" || node.name === \"function\") &&\n          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n        this.context.pop();\n      }\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n      this.checkUnreserved(node);\n      if (node.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = node.start; }\n    }\n    return node\n  };\n\n  // Parses yield expression inside generator.\n\n  pp$3.parseYield = function(noIn) {\n    if (!this.yieldPos) { this.yieldPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign(noIn);\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  };\n\n  pp$3.parseAwait = function() {\n    if (!this.awaitPos) { this.awaitPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  var pp$4 = Parser.prototype;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n    throw err\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function() {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart)\n    }\n  };\n\n  var pp$5 = Parser.prototype;\n\n  var Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n  };\n\n  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n  pp$5.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n  };\n\n  pp$5.exitScope = function() {\n    this.scopeStack.pop();\n  };\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  pp$5.treatFunctionsAsVarInScope = function(scope) {\n    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n  };\n\n  pp$5.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n      var scope = this.currentScope();\n      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n      scope.lexical.push(name);\n      if (this.inModule && (scope.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n      var scope$1 = this.currentScope();\n      scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n      var scope$2 = this.currentScope();\n      if (this.treatFunctionsAsVar)\n        { redeclared = scope$2.lexical.indexOf(name) > -1; }\n      else\n        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n      scope$2.functions.push(name);\n    } else {\n      for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n        var scope$3 = this.scopeStack[i];\n        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n          redeclared = true;\n          break\n        }\n        scope$3.var.push(name);\n        if (this.inModule && (scope$3.flags & SCOPE_TOP))\n          { delete this.undefinedExports[name]; }\n        if (scope$3.flags & SCOPE_VAR) { break }\n      }\n    }\n    if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n  };\n\n  pp$5.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n        this.scopeStack[0].var.indexOf(id.name) === -1) {\n      this.undefinedExports[id.name] = id;\n    }\n  };\n\n  pp$5.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1]\n  };\n\n  pp$5.currentVarScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR) { return scope }\n    }\n  };\n\n  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  pp$5.currentThisScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n    }\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations)\n      { this.loc = new SourceLocation(parser, loc); }\n    if (parser.options.directSourceFile)\n      { this.sourceFile = parser.options.directSourceFile; }\n    if (parser.options.ranges)\n      { this.range = [pos, 0]; }\n  };\n\n  // Start an AST node, attaching a start offset.\n\n  var pp$6 = Parser.prototype;\n\n  pp$6.startNode = function() {\n    return new Node(this, this.start, this.startLoc)\n  };\n\n  pp$6.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc)\n  };\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations)\n      { node.loc.end = loc; }\n    if (this.options.ranges)\n      { node.range[1] = pos; }\n    return node\n  }\n\n  pp$6.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n  };\n\n  // Finish node at given position\n\n  pp$6.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc)\n  };\n\n  // The algorithm used to determine whether a regexp can appear at a\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n\n  var types$1 = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n  };\n\n  var pp$7 = Parser.prototype;\n\n  pp$7.initialContext = function() {\n    return [types$1.b_stat]\n  };\n\n  pp$7.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types$1.f_expr || parent === types$1.f_stat)\n      { return true }\n    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n      { return !parent.isExpr }\n\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types._return || prevType === types.name && this.exprAllowed)\n      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n      { return true }\n    if (prevType === types.braceL)\n      { return parent === types$1.b_stat }\n    if (prevType === types._var || prevType === types._const || prevType === types.name)\n      { return false }\n    return !this.exprAllowed\n  };\n\n  pp$7.inGeneratorContext = function() {\n    for (var i = this.context.length - 1; i >= 1; i--) {\n      var context = this.context[i];\n      if (context.token === \"function\")\n        { return context.generator }\n    }\n    return false\n  };\n\n  pp$7.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types.dot)\n      { this.exprAllowed = false; }\n    else if (update = type.updateContext)\n      { update.call(this, prevType); }\n    else\n      { this.exprAllowed = type.beforeExpr; }\n  };\n\n  // Token-specific context update code\n\n  types.parenR.updateContext = types.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n      this.exprAllowed = true;\n      return\n    }\n    var out = this.context.pop();\n    if (out === types$1.b_stat && this.curContext().token === \"function\") {\n      out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n  };\n\n  types.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n    this.exprAllowed = true;\n  };\n\n  types.dollarBraceL.updateContext = function() {\n    this.context.push(types$1.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  types.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n    this.exprAllowed = true;\n  };\n\n  types.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n  };\n\n  types._function.updateContext = types._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n      { this.context.push(types$1.f_expr); }\n    else\n      { this.context.push(types$1.f_stat); }\n    this.exprAllowed = false;\n  };\n\n  types.backQuote.updateContext = function() {\n    if (this.curContext() === types$1.q_tmpl)\n      { this.context.pop(); }\n    else\n      { this.context.push(types$1.q_tmpl); }\n    this.exprAllowed = false;\n  };\n\n  types.star.updateContext = function(prevType) {\n    if (prevType === types._function) {\n      var index = this.context.length - 1;\n      if (this.context[index] === types$1.f_expr)\n        { this.context[index] = types$1.f_expr_gen; }\n      else\n        { this.context[index] = types$1.f_gen; }\n    }\n    this.exprAllowed = true;\n  };\n\n  types.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n      if (this.value === \"of\" && !this.exprAllowed ||\n          this.value === \"yield\" && this.inGeneratorContext())\n        { allowed = true; }\n    }\n    this.exprAllowed = allowed;\n  };\n\n  // This file contains Unicode properties extracted from the ECMAScript\n  // specification. The lists are extracted like so:\n  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n  // #table-binary-unicode-properties\n  var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n  var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n  var ecma11BinaryProperties = ecma10BinaryProperties;\n  var unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties\n  };\n\n  // #table-unicode-general-category-values\n  var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n  // #table-unicode-script-values\n  var ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n  var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n  var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n  var unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues\n  };\n\n  var data = {};\n  function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n  buildUnicodeData(9);\n  buildUnicodeData(10);\n  buildUnicodeData(11);\n\n  var pp$8 = Parser.prototype;\n\n  var RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n  };\n\n  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  };\n\n  RegExpValidationState.prototype.raise = function raise (message) {\n    this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n  };\n\n  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n  RegExpValidationState.prototype.at = function at (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return -1\n    }\n    var c = s.charCodeAt(i);\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return c\n    }\n    return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00\n  };\n\n  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return l\n    }\n    var c = s.charCodeAt(i);\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return i + 1\n    }\n    return i + 2\n  };\n\n  RegExpValidationState.prototype.current = function current () {\n    return this.at(this.pos)\n  };\n\n  RegExpValidationState.prototype.lookahead = function lookahead () {\n    return this.at(this.nextIndex(this.pos))\n  };\n\n  RegExpValidationState.prototype.advance = function advance () {\n    this.pos = this.nextIndex(this.pos);\n  };\n\n  RegExpValidationState.prototype.eat = function eat (ch) {\n    if (this.current() === ch) {\n      this.advance();\n      return true\n    }\n    return false\n  };\n\n  function codePointToString(ch) {\n    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n    ch -= 0x10000;\n    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n  }\n\n  /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags.charAt(i);\n      if (validFlags.indexOf(flag) === -1) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n      }\n      if (flags.indexOf(flag, i + 1) > -1) {\n        this.raise(state.start, \"Duplicate regular expression flag\");\n      }\n    }\n  };\n\n  /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n      state.switchN = true;\n      this.regexp_pattern(state);\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n  pp$8.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n\n    this.regexp_disjunction(state);\n\n    if (state.pos !== state.source.length) {\n      // Make the same messages as V8.\n      if (state.eat(0x29 /* ) */)) {\n        state.raise(\"Unmatched ')'\");\n      }\n      if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n        state.raise(\"Lone quantifier brackets\");\n      }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n      state.raise(\"Invalid escape\");\n    }\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n      var name = list[i];\n\n      if (state.groupNames.indexOf(name) === -1) {\n        state.raise(\"Invalid named capture referenced\");\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n  pp$8.regexp_disjunction = function(state) {\n    this.regexp_alternative(state);\n    while (state.eat(0x7C /* | */)) {\n      this.regexp_alternative(state);\n    }\n\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n  pp$8.regexp_alternative = function(state) {\n    while (state.pos < state.source.length && this.regexp_eatTerm(state))\n      { }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n  pp$8.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n      // Handle `QuantifiableAssertion Quantifier` alternative.\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n      // is a QuantifiableAssertion.\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n        // Make the same message as V8.\n        if (state.switchU) {\n          state.raise(\"Invalid quantifier\");\n        }\n      }\n      return true\n    }\n\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n      this.regexp_eatQuantifier(state);\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n  pp$8.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n\n    // ^, $\n    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n      return true\n    }\n\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */)) {\n      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n      var lookbehind = false;\n      if (this.options.ecmaVersion >= 9) {\n        lookbehind = state.eat(0x3C /* < */);\n      }\n      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n        this.regexp_disjunction(state);\n        if (!state.eat(0x29 /* ) */)) {\n          state.raise(\"Unterminated group\");\n        }\n        state.lastAssertionIsQuantifiable = !lookbehind;\n        return true\n      }\n    }\n\n    state.pos = start;\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n  pp$8.regexp_eatQuantifier = function(state, noError) {\n    if ( noError === void 0 ) noError = false;\n\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n      state.eat(0x3F /* ? */);\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n    return (\n      state.eat(0x2A /* * */) ||\n      state.eat(0x2B /* + */) ||\n      state.eat(0x3F /* ? */) ||\n      this.regexp_eatBracedQuantifier(state, noError)\n    )\n  };\n  pp$8.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */)) {\n      var min = 0, max = -1;\n      if (this.regexp_eatDecimalDigits(state)) {\n        min = state.lastIntValue;\n        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n          max = state.lastIntValue;\n        }\n        if (state.eat(0x7D /* } */)) {\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n          if (max !== -1 && max < min && !noError) {\n            state.raise(\"numbers out of order in {} quantifier\");\n          }\n          return true\n        }\n      }\n      if (state.switchU && !noError) {\n        state.raise(\"Incomplete quantifier\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n  pp$8.regexp_eatAtom = function(state) {\n    return (\n      this.regexp_eatPatternCharacters(state) ||\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state)\n    )\n  };\n  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatAtomEscape(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */)) {\n      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */)) {\n          return true\n        }\n        state.raise(\"Unterminated group\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */)) {\n      if (this.options.ecmaVersion >= 9) {\n        this.regexp_groupSpecifier(state);\n      } else if (state.current() === 0x3F /* ? */) {\n        state.raise(\"Invalid group\");\n      }\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        state.numCapturingParens += 1;\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n  pp$8.regexp_eatExtendedAtom = function(state) {\n    return (\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state) ||\n      this.regexp_eatInvalidBracedQuantifier(state) ||\n      this.regexp_eatExtendedPatternCharacter(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n  pp$8.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isSyntaxCharacter(ch) {\n    return (\n      ch === 0x24 /* $ */ ||\n      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n      ch === 0x2E /* . */ ||\n      ch === 0x3F /* ? */ ||\n      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n  // But eat eager.\n  pp$8.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n      state.advance();\n    }\n    return state.pos !== start\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n  pp$8.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (\n      ch !== -1 &&\n      ch !== 0x24 /* $ */ &&\n      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n      ch !== 0x2E /* . */ &&\n      ch !== 0x3F /* ? */ &&\n      ch !== 0x5B /* [ */ &&\n      ch !== 0x5E /* ^ */ &&\n      ch !== 0x7C /* | */\n    ) {\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // GroupSpecifier[U] ::\n  //   [empty]\n  //   `?` GroupName[?U]\n  pp$8.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */)) {\n      if (this.regexp_eatGroupName(state)) {\n        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n          state.raise(\"Duplicate capture group name\");\n        }\n        state.groupNames.push(state.lastStringValue);\n        return\n      }\n      state.raise(\"Invalid group\");\n    }\n  };\n\n  // GroupName[U] ::\n  //   `<` RegExpIdentifierName[?U] `>`\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */)) {\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n        return true\n      }\n      state.raise(\"Invalid capture group name\");\n    }\n    return false\n  };\n\n  // RegExpIdentifierName[U] ::\n  //   RegExpIdentifierStart[?U]\n  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n      }\n      return true\n    }\n    return false\n  };\n\n  // RegExpIdentifierStart[U] ::\n  //   UnicodeIDStart\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  pp$8.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n  }\n\n  // RegExpIdentifierPart[U] ::\n  //   UnicodeIDContinue\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  //   <ZWNJ>\n  //   <ZWJ>\n  pp$8.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n  pp$8.regexp_eatAtomEscape = function(state) {\n    if (\n      this.regexp_eatBackReference(state) ||\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state) ||\n      (state.switchN && this.regexp_eatKGroupName(state))\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      if (state.current() === 0x63 /* c */) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    return false\n  };\n  pp$8.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n      var n = state.lastIntValue;\n      if (state.switchU) {\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n        if (n > state.maxBackReference) {\n          state.maxBackReference = n;\n        }\n        return true\n      }\n      if (n <= state.numCapturingParens) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */)) {\n      if (this.regexp_eatGroupName(state)) {\n        state.backReferenceNames.push(state.lastStringValue);\n        return true\n      }\n      state.raise(\"Invalid named reference\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n  pp$8.regexp_eatCharacterEscape = function(state) {\n    return (\n      this.regexp_eatControlEscape(state) ||\n      this.regexp_eatCControlLetter(state) ||\n      this.regexp_eatZero(state) ||\n      this.regexp_eatHexEscapeSequence(state) ||\n      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n      this.regexp_eatIdentityEscape(state)\n    )\n  };\n  pp$8.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */)) {\n      if (this.regexp_eatControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n      state.lastIntValue = 0;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n  pp$8.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */) {\n      state.lastIntValue = 0x09; /* \\t */\n      state.advance();\n      return true\n    }\n    if (ch === 0x6E /* n */) {\n      state.lastIntValue = 0x0A; /* \\n */\n      state.advance();\n      return true\n    }\n    if (ch === 0x76 /* v */) {\n      state.lastIntValue = 0x0B; /* \\v */\n      state.advance();\n      return true\n    }\n    if (ch === 0x66 /* f */) {\n      state.lastIntValue = 0x0C; /* \\f */\n      state.advance();\n      return true\n    }\n    if (ch === 0x72 /* r */) {\n      state.lastIntValue = 0x0D; /* \\r */\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n  pp$8.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isControlLetter(ch) {\n    return (\n      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x75 /* u */)) {\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\n        var lead = state.lastIntValue;\n        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n          var leadSurrogateEnd = state.pos;\n          if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n            var trail = state.lastIntValue;\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n              return true\n            }\n          }\n          state.pos = leadSurrogateEnd;\n          state.lastIntValue = lead;\n        }\n        return true\n      }\n      if (\n        state.switchU &&\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatHexDigits(state) &&\n        state.eat(0x7D /* } */) &&\n        isValidUnicode(state.lastIntValue)\n      ) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.pos = start;\n    }\n\n    return false\n  };\n  function isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n  pp$8.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n      if (this.regexp_eatSyntaxCharacter(state)) {\n        return true\n      }\n      if (state.eat(0x2F /* / */)) {\n        state.lastIntValue = 0x2F; /* / */\n        return true\n      }\n      return false\n    }\n\n    var ch = state.current();\n    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n  pp$8.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n      do {\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n        state.advance();\n      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n  pp$8.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n\n    if (isCharacterClassEscape(ch)) {\n      state.lastIntValue = -1;\n      state.advance();\n      return true\n    }\n\n    if (\n      state.switchU &&\n      this.options.ecmaVersion >= 9 &&\n      (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n    ) {\n      state.lastIntValue = -1;\n      state.advance();\n      if (\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatUnicodePropertyValueExpression(state) &&\n        state.eat(0x7D /* } */)\n      ) {\n        return true\n      }\n      state.raise(\"Invalid property name\");\n    }\n\n    return false\n  };\n  function isCharacterClassEscape(ch) {\n    return (\n      ch === 0x64 /* d */ ||\n      ch === 0x44 /* D */ ||\n      ch === 0x73 /* s */ ||\n      ch === 0x53 /* S */ ||\n      ch === 0x77 /* w */ ||\n      ch === 0x57 /* W */\n    )\n  }\n\n  // UnicodePropertyValueExpression ::\n  //   UnicodePropertyName `=` UnicodePropertyValue\n  //   LoneUnicodePropertyNameOrValue\n  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n      var name = state.lastStringValue;\n      if (this.regexp_eatUnicodePropertyValue(state)) {\n        var value = state.lastStringValue;\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n        return true\n      }\n    }\n    state.pos = start;\n\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n      var nameOrValue = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n      return true\n    }\n    return false\n  };\n  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!has(state.unicodeProperties.nonBinary, name))\n      { state.raise(\"Invalid property name\"); }\n    if (!state.unicodeProperties.nonBinary[name].test(value))\n      { state.raise(\"Invalid property value\"); }\n  };\n  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (!state.unicodeProperties.binary.test(nameOrValue))\n      { state.raise(\"Invalid property name\"); }\n  };\n\n  // UnicodePropertyName ::\n  //   UnicodePropertyNameCharacters\n  pp$8.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */\n  }\n\n  // UnicodePropertyValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n  }\n\n  // LoneUnicodePropertyNameOrValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state)\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n  pp$8.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */)) {\n      state.eat(0x5E /* ^ */);\n      this.regexp_classRanges(state);\n      if (state.eat(0x5D /* [ */)) {\n        return true\n      }\n      // Unreachable since it threw \"unterminated regular expression\" error before.\n      state.raise(\"Unterminated character class\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n  pp$8.regexp_classRanges = function(state) {\n    while (this.regexp_eatClassAtom(state)) {\n      var left = state.lastIntValue;\n      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n        var right = state.lastIntValue;\n        if (state.switchU && (left === -1 || right === -1)) {\n          state.raise(\"Invalid character class\");\n        }\n        if (left !== -1 && right !== -1 && left > right) {\n          state.raise(\"Range out of order in character class\");\n        }\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n  pp$8.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatClassEscape(state)) {\n        return true\n      }\n      if (state.switchU) {\n        // Make the same message as V8.\n        var ch$1 = state.current();\n        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n          state.raise(\"Invalid class escape\");\n        }\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n\n    var ch = state.current();\n    if (ch !== 0x5D /* [ */) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n  pp$8.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n\n    if (state.switchU && state.eat(0x2D /* - */)) {\n      state.lastIntValue = 0x2D; /* - */\n      return true\n    }\n\n    if (!state.switchU && state.eat(0x63 /* c */)) {\n      if (this.regexp_eatClassControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    return (\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n  pp$8.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */)) {\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n  pp$8.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isDecimalDigit(ch = state.current())) {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n  pp$8.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isHexDigit(ch = state.current())) {\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isHexDigit(ch) {\n    return (\n      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n    )\n  }\n  function hexToInt(ch) {\n    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n      return 10 + (ch - 0x41 /* A */)\n    }\n    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n      return 10 + (ch - 0x61 /* a */)\n    }\n    return ch - 0x30 /* 0 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\n  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n      var n1 = state.lastIntValue;\n      if (this.regexp_eatOctalDigit(state)) {\n        var n2 = state.lastIntValue;\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n        } else {\n          state.lastIntValue = n1 * 8 + n2;\n        }\n      } else {\n        state.lastIntValue = n1;\n      }\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n  pp$8.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n      state.lastIntValue = ch - 0x30; /* 0 */\n      state.advance();\n      return true\n    }\n    state.lastIntValue = 0;\n    return false\n  };\n  function isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for (var i = 0; i < length; ++i) {\n      var ch = state.current();\n      if (!isHexDigit(ch)) {\n        state.pos = start;\n        return false\n      }\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return true\n  };\n\n  // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations)\n      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n    if (p.options.ranges)\n      { this.range = [p.start, p.end]; }\n  };\n\n  // ## Tokenizer\n\n  var pp$9 = Parser.prototype;\n\n  // Move to the next token\n\n  pp$9.next = function() {\n    if (this.options.onToken)\n      { this.options.onToken(new Token(this)); }\n\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp$9.getToken = function() {\n    this.next();\n    return new Token(this)\n  };\n\n  // If we're in an ES6 environment, make parsers iterable\n  if (typeof Symbol !== \"undefined\")\n    { pp$9[Symbol.iterator] = function() {\n      var this$1 = this;\n\n      return {\n        next: function () {\n          var token = this$1.getToken();\n          return {\n            done: token.type === types.eof,\n            value: token\n          }\n        }\n      }\n    }; }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  pp$9.curContext = function() {\n    return this.context[this.context.length - 1]\n  };\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  pp$9.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n    this.start = this.pos;\n    if (this.options.locations) { this.startLoc = this.curPosition(); }\n    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n    if (curContext.override) { return curContext.override(this) }\n    else { this.readToken(this.fullCharCodeAtPos()); }\n  };\n\n  pp$9.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n      { return this.readWord() }\n\n    return this.getTokenFromCode(code)\n  };\n\n  pp$9.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xe000) { return code }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return (code << 10) + next - 0x35fdc00\n  };\n\n  pp$9.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n    this.pos = end + 2;\n    if (this.options.locations) {\n      lineBreakG.lastIndex = start;\n      var match;\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n        ++this.curLine;\n        this.lineStart = match.index + match[0].length;\n      }\n    }\n    if (this.options.onComment)\n      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  pp$9.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while (this.pos < this.input.length && !isNewLine(ch)) {\n      ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment)\n      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  pp$9.skipSpace = function() {\n    loop: while (this.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.pos);\n      switch (ch) {\n      case 32: case 160: // ' '\n        ++this.pos;\n        break\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n      case 10: case 8232: case 8233:\n        ++this.pos;\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        break\n      case 47: // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n        case 42: // '*'\n          this.skipBlockComment();\n          break\n        case 47:\n          this.skipLineComment(2);\n          break\n        default:\n          break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop\n        }\n      }\n    }\n  };\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  pp$9.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) { this.endLoc = this.curPosition(); }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n\n    this.updateContext(prevType);\n  };\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  pp$9.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) { return this.readNumber(true) }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(types.ellipsis)\n    } else {\n      ++this.pos;\n      return this.finishToken(types.dot)\n    }\n  };\n\n  pp$9.readToken_slash = function() { // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.slash, 1)\n  };\n\n  pp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types.star : types.modulo;\n\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n      ++size;\n      tokentype = types.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(tokentype, size)\n  };\n\n  pp$9.readToken_pipe_amp = function(code) { // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n  };\n\n  pp$9.readToken_caret = function() { // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.bitwiseXOR, 1)\n  };\n\n  pp$9.readToken_plus_min = function(code) { // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken()\n      }\n      return this.finishOp(types.incDec, 2)\n    }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.plusMin, 1)\n  };\n\n  pp$9.readToken_lt_gt = function(code) { // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n      return this.finishOp(types.bitShift, size)\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n        this.input.charCodeAt(this.pos + 3) === 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    if (next === 61) { size = 2; }\n    return this.finishOp(types.relational, size)\n  };\n\n  pp$9.readToken_eq_excl = function(code) { // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n      this.pos += 2;\n      return this.finishToken(types.arrow)\n    }\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n  };\n\n  pp$9.getTokenFromCode = function(code) {\n    switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46: // '.'\n      return this.readToken_dot()\n\n    // Punctuation tokens.\n    case 40: ++this.pos; return this.finishToken(types.parenL)\n    case 41: ++this.pos; return this.finishToken(types.parenR)\n    case 59: ++this.pos; return this.finishToken(types.semi)\n    case 44: ++this.pos; return this.finishToken(types.comma)\n    case 91: ++this.pos; return this.finishToken(types.bracketL)\n    case 93: ++this.pos; return this.finishToken(types.bracketR)\n    case 123: ++this.pos; return this.finishToken(types.braceL)\n    case 125: ++this.pos; return this.finishToken(types.braceR)\n    case 58: ++this.pos; return this.finishToken(types.colon)\n    case 63: ++this.pos; return this.finishToken(types.question)\n\n    case 96: // '`'\n      if (this.options.ecmaVersion < 6) { break }\n      ++this.pos;\n      return this.finishToken(types.backQuote)\n\n    case 48: // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return this.readNumber(false)\n\n    // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47: // '/'\n      return this.readToken_slash()\n\n    case 37: case 42: // '%*'\n      return this.readToken_mult_modulo_exp(code)\n\n    case 124: case 38: // '|&'\n      return this.readToken_pipe_amp(code)\n\n    case 94: // '^'\n      return this.readToken_caret()\n\n    case 43: case 45: // '+-'\n      return this.readToken_plus_min(code)\n\n    case 60: case 62: // '<>'\n      return this.readToken_lt_gt(code)\n\n    case 61: case 33: // '=!'\n      return this.readToken_eq_excl(code)\n\n    case 126: // '~'\n      return this.finishOp(types.prefix, 1)\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n  };\n\n  pp$9.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str)\n  };\n\n  pp$9.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n      var ch = this.input.charAt(this.pos);\n      if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n      if (!escaped) {\n        if (ch === \"[\") { inClass = true; }\n        else if (ch === \"]\" && inClass) { inClass = false; }\n        else if (ch === \"/\" && !inClass) { break }\n        escaped = ch === \"\\\\\";\n      } else { escaped = false; }\n      ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) { this.unexpected(flagsStart); }\n\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n\n    // Create Literal#value property value.\n    var value = null;\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      // ESTree requires null if it failed to instantiate RegExp object.\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n\n    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n  };\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  pp$9.readInt = function(radix, len) {\n    var start = this.pos, total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this.input.charCodeAt(this.pos), val = (void 0);\n      if (code >= 97) { val = code - 97 + 10; } // a\n      else if (code >= 65) { val = code - 65 + 10; } // A\n      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n      else { val = Infinity; }\n      if (val >= radix) { break }\n      ++this.pos;\n      total = total * radix + val;\n    }\n    if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n    return total\n  };\n\n  pp$9.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n      val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n      ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val)\n  };\n\n  // Read an integer, octal integer, or floating-point number.\n\n  pp$9.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n      var str$1 = this.input.slice(start, this.pos);\n      var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n      ++this.pos;\n      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n      return this.finishToken(types.num, val$1)\n    }\n    if (next === 46 && !octal) { // '.'\n      ++this.pos;\n      this.readInt(10);\n      next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) { // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n      if (next === 43 || next === 45) { ++this.pos; } // '+-'\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n    var str = this.input.slice(start, this.pos);\n    var val = octal ? parseInt(str, 8) : parseFloat(str);\n    return this.finishToken(types.num, val)\n  };\n\n  // Read a string value, interpreting backslash-escapes.\n\n  pp$9.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n\n    if (ch === 123) { // '{'\n      if (this.options.ecmaVersion < 6) { this.unexpected(); }\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n      ++this.pos;\n      if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n    } else {\n      code = this.readHexChar(4);\n    }\n    return code\n  };\n\n  function codePointToString$1(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) { return String.fromCharCode(code) }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n  }\n\n  pp$9.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === quote) { break }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.pos;\n      } else {\n        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n        ++this.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types.string, out)\n  };\n\n  // Reads template string tokens.\n\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\n  pp$9.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n      this.readTmplToken();\n    } catch (err) {\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n        this.readInvalidTemplateToken();\n      } else {\n        throw err\n      }\n    }\n\n    this.inTemplateElement = false;\n  };\n\n  pp$9.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n      throw INVALID_TEMPLATE_ESCAPE_ERROR\n    } else {\n      this.raise(position, message);\n    }\n  };\n\n  pp$9.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n          if (ch === 36) {\n            this.pos += 2;\n            return this.finishToken(types.dollarBraceL)\n          } else {\n            ++this.pos;\n            return this.finishToken(types.backQuote)\n          }\n        }\n        out += this.input.slice(chunkStart, this.pos);\n        return this.finishToken(types.template, out)\n      }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(true);\n        chunkStart = this.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.pos);\n        ++this.pos;\n        switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n        case 10:\n          out += \"\\n\";\n          break\n        default:\n          out += String.fromCharCode(ch);\n          break\n        }\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        chunkStart = this.pos;\n      } else {\n        ++this.pos;\n      }\n    }\n  };\n\n  // Reads a template token to search for the end, without validating any escape sequences\n  pp$9.readInvalidTemplateToken = function() {\n    for (; this.pos < this.input.length; this.pos++) {\n      switch (this.input[this.pos]) {\n      case \"\\\\\":\n        ++this.pos;\n        break\n\n      case \"$\":\n        if (this.input[this.pos + 1] !== \"{\") {\n          break\n        }\n      // falls through\n\n      case \"`\":\n        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n      // no default\n      }\n    }\n    this.raise(this.start, \"Unterminated template\");\n  };\n\n  // Used to read escaped characters\n\n  pp$9.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch (ch) {\n    case 110: return \"\\n\" // 'n' -> '\\n'\n    case 114: return \"\\r\" // 'r' -> '\\r'\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n    case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n    case 116: return \"\\t\" // 't' -> '\\t'\n    case 98: return \"\\b\" // 'b' -> '\\b'\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n    case 102: return \"\\f\" // 'f' -> '\\f'\n    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n    case 10: // ' \\n'\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n      return \"\"\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(\n            this.pos - 1 - octalStr.length,\n            inTemplate\n              ? \"Octal literal in template string\"\n              : \"Octal literal in strict mode\"\n          );\n        }\n        return String.fromCharCode(octal)\n      }\n      if (isNewLine(ch)) {\n        // Unicode new line characters after \\ get removed from output in both\n        // template literals and strings\n        return \"\"\n      }\n      return String.fromCharCode(ch)\n    }\n  };\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  pp$9.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n    return n\n  };\n\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  pp$9.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while (this.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n      if (isIdentifierChar(ch, astral)) {\n        this.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) { // \"\\\"\n        this.containsEsc = true;\n        word += this.input.slice(chunkStart, this.pos);\n        var escStart = this.pos;\n        if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n          { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n        ++this.pos;\n        var esc = this.readCodePoint();\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n          { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n        word += codePointToString$1(esc);\n        chunkStart = this.pos;\n      } else {\n        break\n      }\n      first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos)\n  };\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  pp$9.readWord = function() {\n    var word = this.readWord1();\n    var type = types.name;\n    if (this.keywords.test(word)) {\n      if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n      type = keywords$1[word];\n    }\n    return this.finishToken(type, word)\n  };\n\n  // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\n  var version = \"7.1.0\";\n\n  Parser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types,\n    keywordTypes: keywords$1,\n    TokContext: TokContext,\n    tokContexts: types$1,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n  };\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return Parser.parse(input, options)\n  }\n\n  // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n  function parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options)\n  }\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n  function tokenizer(input, options) {\n    return Parser.tokenizer(input, options)\n  }\n\n  exports.Node = Node;\n  exports.Parser = Parser;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.TokContext = TokContext;\n  exports.Token = Token;\n  exports.TokenType = TokenType;\n  exports.defaultOptions = defaultOptions;\n  exports.getLineInfo = getLineInfo;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.isNewLine = isNewLine;\n  exports.keywordTypes = keywords$1;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokContexts = types$1;\n  exports.tokTypes = types;\n  exports.tokenizer = tokenizer;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n})\n","startIndex":192163,"endIndex":192163,"highlightLines":[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,289,290,291,292,293,294,295,296,297,298,299,300,301,302,303,304,305,306,307,308,309,310,311,312,313,314,315,316,317,318,319,320,321,322,323,324,325,326,327,328,329,330,331,332,333,334,335,336,337,338,339,340,341,342,343,344,345,346,347,348,349,350,351,352,353,354,355,356,357,358,359,360,361,362,363,364,365,366,367,368,369,370,371,372,373,374,375,376,377,378,379,380,381,382,383,384,385,386,387,388,389,390,391,392,393,394,395,396,397,398,399,400,401,402,403,404,405,406,407,408,409,410,411,412,413,414,415,416,417,418,419,420,421,422,423,424,425,426,427,428,429,430,431,432,433,434,435,436,437,438,439,440,441,442,443,444,445,446,447,448,449,450,451,452,453,454,455,456,457,458,459,460,461,462,463,464,465,466,467,468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,504,505,506,507,508,509,510,511,512,513,514,515,516,517,518,519,520,521,522,523,524,525,526,527,528,529,530,531,532,533,534,535,536,537,538,539,540,541,542,543,544,545,546,547,548,549,550,551,552,553,554,555,556,557,558,559,560,561,562,563,564,565,566,567,568,569,570,571,572,573,574,575,576,577,578,579,580,581,582,583,584,585,586,587,588,589,590,591,592,593,594,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,633,634,635,636,637,638,639,640,641,642,643,644,645,646,647,648,649,650,651,652,653,654,655,656,657,658,659,660,661,662,663,664,665,666,667,668,669,670,671,672,673,674,675,676,677,678,679,680,681,682,683,684,685,686,687,688,689,690,691,692,693,694,695,696,697,698,699,700,701,702,703,704,705,706,707,708,709,710,711,712,713,714,715,716,717,718,719,720,721,722,723,724,725,726,727,728,729,730,731,732,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,786,787,788,789,790,791,792,793,794,795,796,797,798,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,850,851,852,853,854,855,856,857,858,859,860,861,862,863,864,865,866,867,868,869,870,871,872,873,874,875,876,877,878,879,880,881,882,883,884,885,886,887,888,889,890,891,892,893,894,895,896,897,898,899,900,901,902,903,904,905,906,907,908,909,910,911,912,913,914,915,916,917,918,919,920,921,922,923,924,925,926,927,928,929,930,931,932,933,934,935,936,937,938,939,940,941,942,943,944,945,946,947,948,949,950,951,952,953,954,955,956,957,958,959,960,961,962,963,964,965,966,967,968,969,970,971,972,973,974,975,976,977,978,979,980,981,982,983,984,985,986,987,988,989,990,991,992,993,994,995,996,997,998,999,1000,1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1011,1012,1013,1014,1015,1016,1017,1018,1019,1020,1021,1022,1023,1024,1025,1026,1027,1028,1029,1030,1031,1032,1033,1034,1035,1036,1037,1038,1039,1040,1041,1042,1043,1044,1045,1046,1047,1048,1049,1050,1051,1052,1053,1054,1055,1056,1057,1058,1059,1060,1061,1062,1063,1064,1065,1066,1067,1068,1069,1070,1071,1072,1073,1074,1075,1076,1077,1078,1079,1080,1081,1082,1083,1084,1085,1086,1087,1088,1089,1090,1091,1092,1093,1094,1095,1096,1097,1098,1099,1100,1101,1102,1103,1104,1105,1106,1107,1108,1109,1110,1111,1112,1113,1114,1115,1116,1117,1118,1119,1120,1121,1122,1123,1124,1125,1126,1127,1128,1129,1130,1131,1132,1133,1134,1135,1136,1137,1138,1139,1140,1141,1142,1143,1144,1145,1146,1147,1148,1149,1150,1151,1152,1153,1154,1155,1156,1157,1158,1159,1160,1161,1162,1163,1164,1165,1166,1167,1168,1169,1170,1171,1172,1173,1174,1175,1176,1177,1178,1179,1180,1181,1182,1183,1184,1185,1186,1187,1188,1189,1190,1191,1192,1193,1194,1195,1196,1197,1198,1199,1200,1201,1202,1203,1204,1205,1206,1207,1208,1209,1210,1211,1212,1213,1214,1215,1216,1217,1218,1219,1220,1221,1222,1223,1224,1225,1226,1227,1228,1229,1230,1231,1232,1233,1234,1235,1236,1237,1238,1239,1240,1241,1242,1243,1244,1245,1246,1247,1248,1249,1250,1251,1252,1253,1254,1255,1256,1257,1258,1259,1260,1261,1262,1263,1264,1265,1266,1267,1268,1269,1270,1271,1272,1273,1274,1275,1276,1277,1278,1279,1280,1281,1282,1283,1284,1285,1286,1287,1288,1289,1290,1291,1292,1293,1294,1295,1296,1297,1298,1299,1300,1301,1302,1303,1304,1305,1306,1307,1308,1309,1310,1311,1312,1313,1314,1315,1316,1317,1318,1319,1320,1321,1322,1323,1324,1325,1326,1327,1328,1329,1330,1331,1332,1333,1334,1335,1336,1337,1338,1339,1340,1341,1342,1343,1344,1345,1346,1347,1348,1349,1350,1351,1352,1353,1354,1355,1356,1357,1358,1359,1360,1361,1362,1363,1364,1365,1366,1367,1368,1369,1370,1371,1372,1373,1374,1375,1376,1377,1378,1379,1380,1381,1382,1383,1384,1385,1386,1387,1388,1389,1390,1391,1392,1393,1394,1395,1396,1397,1398,1399,1400,1401,1402,1403,1404,1405,1406,1407,1408,1409,1410,1411,1412,1413,1414,1415,1416,1417,1418,1419,1420,1421,1422,1423,1424,1425,1426,1427,1428,1429,1430,1431,1432,1433,1434,1435,1436,1437,1438,1439,1440,1441,1442,1443,1444,1445,1446,1447,1448,1449,1450,1451,1452,1453,1454,1455,1456,1457,1458,1459,1460,1461,1462,1463,1464,1465,1466,1467,1468,1469,1470,1471,1472,1473,1474,1475,1476,1477,1478,1479,1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490,1491,1492,1493,1494,1495,1496,1497,1498,1499,1500,1501,1502,1503,1504,1505,1506,1507,1508,1509,1510,1511,1512,1513,1514,1515,1516,1517,1518,1519,1520,1521,1522,1523,1524,1525,1526,1527,1528,1529,1530,1531,1532,1533,1534,1535,1536,1537,1538,1539,1540,1541,1542,1543,1544,1545,1546,1547,1548,1549,1550,1551,1552,1553,1554,1555,1556,1557,1558,1559,1560,1561,1562,1563,1564,1565,1566,1567,1568,1569,1570,1571,1572,1573,1574,1575,1576,1577,1578,1579,1580,1581,1582,1583,1584,1585,1586,1587,1588,1589,1590,1591,1592,1593,1594,1595,1596,1597,1598,1599,1600,1601,1602,1603,1604,1605,1606,1607,1608,1609,1610,1611,1612,1613,1614,1615,1616,1617,1618,1619,1620,1621,1622,1623,1624,1625,1626,1627,1628,1629,1630,1631,1632,1633,1634,1635,1636,1637,1638,1639,1640,1641,1642,1643,1644,1645,1646,1647,1648,1649,1650,1651,1652,1653,1654,1655,1656,1657,1658,1659,1660,1661,1662,1663,1664,1665,1666,1667,1668,1669,1670,1671,1672,1673,1674,1675,1676,1677,1678,1679,1680,1681,1682,1683,1684,1685,1686,1687,1688,1689,1690,1691,1692,1693,1694,1695,1696,1697,1698,1699,1700,1701,1702,1703,1704,1705,1706,1707,1708,1709,1710,1711,1712,1713,1714,1715,1716,1717,1718,1719,1720,1721,1722,1723,1724,1725,1726,1727,1728,1729,1730,1731,1732,1733,1734,1735,1736,1737,1738,1739,1740,1741,1742,1743,1744,1745,1746,1747,1748,1749,1750,1751,1752,1753,1754,1755,1756,1757,1758,1759,1760,1761,1762,1763,1764,1765,1766,1767,1768,1769,1770,1771,1772,1773,1774,1775,1776,1777,1778,1779,1780,1781,1782,1783,1784,1785,1786,1787,1788,1789,1790,1791,1792,1793,1794,1795,1796,1797,1798,1799,1800,1801,1802,1803,1804,1805,1806,1807,1808,1809,1810,1811,1812,1813,1814,1815,1816,1817,1818,1819,1820,1821,1822,1823,1824,1825,1826,1827,1828,1829,1830,1831,1832,1833,1834,1835,1836,1837,1838,1839,1840,1841,1842,1843,1844,1845,1846,1847,1848,1849,1850,1851,1852,1853,1854,1855,1856,1857,1858,1859,1860,1861,1862,1863,1864,1865,1866,1867,1868,1869,1870,1871,1872,1873,1874,1875,1876,1877,1878,1879,1880,1881,1882,1883,1884,1885,1886,1887,1888,1889,1890,1891,1892,1893,1894,1895,1896,1897,1898,1899,1900,1901,1902,1903,1904,1905,1906,1907,1908,1909,1910,1911,1912,1913,1914,1915,1916,1917,1918,1919,1920,1921,1922,1923,1924,1925,1926,1927,1928,1929,1930,1931,1932,1933,1934,1935,1936,1937,1938,1939,1940,1941,1942,1943,1944,1945,1946,1947,1948,1949,1950,1951,1952,1953,1954,1955,1956,1957,1958,1959,1960,1961,1962,1963,1964,1965,1966,1967,1968,1969,1970,1971,1972,1973,1974,1975,1976,1977,1978,1979,1980,1981,1982,1983,1984,1985,1986,1987,1988,1989,1990,1991,1992,1993,1994,1995,1996,1997,1998,1999,2000,2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,2041,2042,2043,2044,2045,2046,2047,2048,2049,2050,2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,2081,2082,2083,2084,2085,2086,2087,2088,2089,2090,2091,2092,2093,2094,2095,2096,2097,2098,2099,2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,2110,2111,2112,2113,2114,2115,2116,2117,2118,2119,2120,2121,2122,2123,2124,2125,2126,2127,2128,2129,2130,2131,2132,2133,2134,2135,2136,2137,2138,2139,2140,2141,2142,2143,2144,2145,2146,2147,2148,2149,2150,2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,2181,2182,2183,2184,2185,2186,2187,2188,2189,2190,2191,2192,2193,2194,2195,2196,2197,2198,2199,2200,2201,2202,2203,2204,2205,2206,2207,2208,2209,2210,2211,2212,2213,2214,2215,2216,2217,2218,2219,2220,2221,2222,2223,2224,2225,2226,2227,2228,2229,2230,2231,2232,2233,2234,2235,2236,2237,2238,2239,2240,2241,2242,2243,2244,2245,2246,2247,2248,2249,2250,2251,2252,2253,2254,2255,2256,2257,2258,2259,2260,2261,2262,2263,2264,2265,2266,2267,2268,2269,2270,2271,2272,2273,2274,2275,2276,2277,2278,2279,2280,2281,2282,2283,2284,2285,2286,2287,2288,2289,2290,2291,2292,2293,2294,2295,2296,2297,2298,2299,2300,2301,2302,2303,2304,2305,2306,2307,2308,2309,2310,2311,2312,2313,2314,2315,2316,2317,2318,2319,2320,2321,2322,2323,2324,2325,2326,2327,2328,2329,2330,2331,2332,2333,2334,2335,2336,2337,2338,2339,2340,2341,2342,2343,2344,2345,2346,2347,2348,2349,2350,2351,2352,2353,2354,2355,2356,2357,2358,2359,2360,2361,2362,2363,2364,2365,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2384,2385,2386,2387,2388,2389,2390,2391,2392,2393,2394,2395,2396,2397,2398,2399,2400,2401,2402,2403,2404,2405,2406,2407,2408,2409,2410,2411,2412,2413,2414,2415,2416,2417,2418,2419,2420,2421,2422,2423,2424,2425,2426,2427,2428,2429,2430,2431,2432,2433,2434,2435,2436,2437,2438,2439,2440,2441,2442,2443,2444,2445,2446,2447,2448,2449,2450,2451,2452,2453,2454,2455,2456,2457,2458,2459,2460,2461,2462,2463,2464,2465,2466,2467,2468,2469,2470,2471,2472,2473,2474,2475,2476,2477,2478,2479,2480,2481,2482,2483,2484,2485,2486,2487,2488,2489,2490,2491,2492,2493,2494,2495,2496,2497,2498,2499,2500,2501,2502,2503,2504,2505,2506,2507,2508,2509,2510,2511,2512,2513,2514,2515,2516,2517,2518,2519,2520,2521,2522,2523,2524,2525,2526,2527,2528,2529,2530,2531,2532,2533,2534,2535,2536,2537,2538,2539,2540,2541,2542,2543,2544,2545,2546,2547,2548,2549,2550,2551,2552,2553,2554,2555,2556,2557,2558,2559,2560,2561,2562,2563,2564,2565,2566,2567,2568,2569,2570,2571,2572,2573,2574,2575,2576,2577,2578,2579,2580,2581,2582,2583,2584,2585,2586,2587,2588,2589,2590,2591,2592,2593,2594,2595,2596,2597,2598,2599,2600,2601,2602,2603,2604,2605,2606,2607,2608,2609,2610,2611,2612,2613,2614,2615,2616,2617,2618,2619,2620,2621,2622,2623,2624,2625,2626,2627,2628,2629,2630,2631,2632,2633,2634,2635,2636,2637,2638,2639,2640,2641,2642,2643,2644,2645,2646,2647,2648,2649,2650,2651,2652,2653,2654,2655,2656,2657,2658,2659,2660,2661,2662,2663,2664,2665,2666,2667,2668,2669,2670,2671,2672,2673,2674,2675,2676,2677,2678,2679,2680,2681,2682,2683,2684,2685,2686,2687,2688,2689,2690,2691,2692,2693,2694,2695,2696,2697,2698,2699,2700,2701,2702,2703,2704,2705,2706,2707,2708,2709,2710,2711,2712,2713,2714,2715,2716,2717,2718,2719,2720,2721,2722,2723,2724,2725,2726,2727,2728,2729,2730,2731,2732,2733,2734,2735,2736,2737,2738,2739,2740,2741,2742,2743,2744,2745,2746,2747,2748,2749,2750,2751,2752,2753,2754,2755,2756,2757,2758,2759,2760,2761,2762,2763,2764,2765,2766,2767,2768,2769,2770,2771,2772,2773,2774,2775,2776,2777,2778,2779,2780,2781,2782,2783,2784,2785,2786,2787,2788,2789,2790,2791,2792,2793,2794,2795,2796,2797,2798,2799,2800,2801,2802,2803,2804,2805,2806,2807,2808,2809,2810,2811,2812,2813,2814,2815,2816,2817,2818,2819,2820,2821,2822,2823,2824,2825,2826,2827,2828,2829,2830,2831,2832,2833,2834,2835,2836,2837,2838,2839,2840,2841,2842,2843,2844,2845,2846,2847,2848,2849,2850,2851,2852,2853,2854,2855,2856,2857,2858,2859,2860,2861,2862,2863,2864,2865,2866,2867,2868,2869,2870,2871,2872,2873,2874,2875,2876,2877,2878,2879,2880,2881,2882,2883,2884,2885,2886,2887,2888,2889,2890,2891,2892,2893,2894,2895,2896,2897,2898,2899,2900,2901,2902,2903,2904,2905,2906,2907,2908,2909,2910,2911,2912,2913,2914,2915,2916,2917,2918,2919,2920,2921,2922,2923,2924,2925,2926,2927,2928,2929,2930,2931,2932,2933,2934,2935,2936,2937,2938,2939,2940,2941,2942,2943,2944,2945,2946,2947,2948,2949,2950,2951,2952,2953,2954,2955,2956,2957,2958,2959,2960,2961,2962,2963,2964,2965,2966,2967,2968,2969,2970,2971,2972,2973,2974,2975,2976,2977,2978,2979,2980,2981,2982,2983,2984,2985,2986,2987,2988,2989,2990,2991,2992,2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,3009,3010,3011,3012,3013,3014,3015,3016,3017,3018,3019,3020,3021,3022,3023,3024,3025,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3037,3038,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,3051,3052,3053,3054,3055,3056,3057,3058,3059,3060,3061,3062,3063,3064,3065,3066,3067,3068,3069,3070,3071,3072,3073,3074,3075,3076,3077,3078,3079,3080,3081,3082,3083,3084,3085,3086,3087,3088,3089,3090,3091,3092,3093,3094,3095,3096,3097,3098,3099,3100,3101,3102,3103,3104,3105,3106,3107,3108,3109,3110,3111,3112,3113,3114,3115,3116,3117,3118,3119,3120,3121,3122,3123,3124,3125,3126,3127,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,3141,3142,3143,3144,3145,3146,3147,3148,3149,3150,3151,3152,3153,3154,3155,3156,3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168,3169,3170,3171,3172,3173,3174,3175,3176,3177,3178,3179,3180,3181,3182,3183,3184,3185,3186,3187,3188,3189,3190,3191,3192,3193,3194,3195,3196,3197,3198,3199,3200,3201,3202,3203,3204,3205,3206,3207,3208,3209,3210,3211,3212,3213,3214,3215,3216,3217,3218,3219,3220,3221,3222,3223,3224,3225,3226,3227,3228,3229,3230,3231,3232,3233,3234,3235,3236,3237,3238,3239,3240,3241,3242,3243,3244,3245,3246,3247,3248,3249,3250,3251,3252,3253,3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,3278,3279,3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,3296,3297,3298,3299,3300,3301,3302,3303,3304,3305,3306,3307,3308,3309,3310,3311,3312,3313,3314,3315,3316,3317,3318,3319,3320,3321,3322,3323,3324,3325,3326,3327,3328,3329,3330,3331,3332,3333,3334,3335,3336,3337,3338,3339,3340,3341,3342,3343,3344,3345,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,3360,3361,3362,3363,3364,3365,3366,3367,3368,3369,3370,3371,3372,3373,3374,3375,3376,3377,3378,3379,3380,3381,3382,3383,3384,3385,3386,3387,3388,3389,3390,3391,3392,3393,3394,3395,3396,3397,3398,3399,3400,3401,3402,3403,3404,3405,3406,3407,3408,3409,3410,3411,3412,3413,3414,3415,3416,3417,3418,3419,3420,3421,3422,3423,3424,3425,3426,3427,3428,3429,3430,3431,3432,3433,3434,3435,3436,3437,3438,3439,3440,3441,3442,3443,3444,3445,3446,3447,3448,3449,3450,3451,3452,3453,3454,3455,3456,3457,3458,3459,3460,3461,3462,3463,3464,3465,3466,3467,3468,3469,3470,3471,3472,3473,3474,3475,3476,3477,3478,3479,3480,3481,3482,3483,3484,3485,3486,3487,3488,3489,3490,3491,3492,3493,3494,3495,3496,3497,3498,3499,3500,3501,3502,3503,3504,3505,3506,3507,3508,3509,3510,3511,3512,3513,3514,3515,3516,3517,3518,3519,3520,3521,3522,3523,3524,3525,3526,3527,3528,3529,3530,3531,3532,3533,3534,3535,3536,3537,3538,3539,3540,3541,3542,3543,3544,3545,3546,3547,3548,3549,3550,3551,3552,3553,3554,3555,3556,3557,3558,3559,3560,3561,3562,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,3574,3575,3576,3577,3578,3579,3580,3581,3582,3583,3584,3585,3586,3587,3588,3589,3590,3591,3592,3593,3594,3595,3596,3597,3598,3599,3600,3601,3602,3603,3604,3605,3606,3607,3608,3609,3610,3611,3612,3613,3614,3615,3616,3617,3618,3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3629,3630,3631,3632,3633,3634,3635,3636,3637,3638,3639,3640,3641,3642,3643,3644,3645,3646,3647,3648,3649,3650,3651,3652,3653,3654,3655,3656,3657,3658,3659,3660,3661,3662,3663,3664,3665,3666,3667,3668,3669,3670,3671,3672,3673,3674,3675,3676,3677,3678,3679,3680,3681,3682,3683,3684,3685,3686,3687,3688,3689,3690,3691,3692,3693,3694,3695,3696,3697,3698,3699,3700,3701,3702,3703,3704,3705,3706,3707,3708,3709,3710,3711,3712,3713,3714,3715,3716,3717,3718,3719,3720,3721,3722,3723,3724,3725,3726,3727,3728,3729,3730,3731,3732,3733,3734,3735,3736,3737,3738,3739,3740,3741,3742,3743,3744,3745,3746,3747,3748,3749,3750,3751,3752,3753,3754,3755,3756,3757,3758,3759,3760,3761,3762,3763,3764,3765,3766,3767,3768,3769,3770,3771,3772,3773,3774,3775,3776,3777,3778,3779,3780,3781,3782,3783,3784,3785,3786,3787,3788,3789,3790,3791,3792,3793,3794,3795,3796,3797,3798,3799,3800,3801,3802,3803,3804,3805,3806,3807,3808,3809,3810,3811,3812,3813,3814,3815,3816,3817,3818,3819,3820,3821,3822,3823,3824,3825,3826,3827,3828,3829,3830,3831,3832,3833,3834,3835,3836,3837,3838,3839,3840,3841,3842,3843,3844,3845,3846,3847,3848,3849,3850,3851,3852,3853,3854,3855,3856,3857,3858,3859,3860,3861,3862,3863,3864,3865,3866,3867,3868,3869,3870,3871,3872,3873,3874,3875,3876,3877,3878,3879,3880,3881,3882,3883,3884,3885,3886,3887,3888,3889,3890,3891,3892,3893,3894,3895,3896,3897,3898,3899,3900,3901,3902,3903,3904,3905,3906,3907,3908,3909,3910,3911,3912,3913,3914,3915,3916,3917,3918,3919,3920,3921,3922,3923,3924,3925,3926,3927,3928,3929,3930,3931,3932,3933,3934,3935,3936,3937,3938,3939,3940,3941,3942,3943,3944,3945,3946,3947,3948,3949,3950,3951,3952,3953,3954,3955,3956,3957,3958,3959,3960,3961,3962,3963,3964,3965,3966,3967,3968,3969,3970,3971,3972,3973,3974,3975,3976,3977,3978,3979,3980,3981,3982,3983,3984,3985,3986,3987,3988,3989,3990,3991,3992,3993,3994,3995,3996,3997,3998,3999,4000,4001,4002,4003,4004,4005,4006,4007,4008,4009,4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4020,4021,4022,4023,4024,4025,4026,4027,4028,4029,4030,4031,4032,4033,4034,4035,4036,4037,4038,4039,4040,4041,4042,4043,4044,4045,4046,4047,4048,4049,4050,4051,4052,4053,4054,4055,4056,4057,4058,4059,4060,4061,4062,4063,4064,4065,4066,4067,4068,4069,4070,4071,4072,4073,4074,4075,4076,4077,4078,4079,4080,4081,4082,4083,4084,4085,4086,4087,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,4099,4100,4101,4102,4103,4104,4105,4106,4107,4108,4109,4110,4111,4112,4113,4114,4115,4116,4117,4118,4119,4120,4121,4122,4123,4124,4125,4126,4127,4128,4129,4130,4131,4132,4133,4134,4135,4136,4137,4138,4139,4140,4141,4142,4143,4144,4145,4146,4147,4148,4149,4150,4151,4152,4153,4154,4155,4156,4157,4158,4159,4160,4161,4162,4163,4164,4165,4166,4167,4168,4169,4170,4171,4172,4173,4174,4175,4176,4177,4178,4179,4180,4181,4182,4183,4184,4185,4186,4187,4188,4189,4190,4191,4192,4193,4194,4195,4196,4197,4198,4199,4200,4201,4202,4203,4204,4205,4206,4207,4208,4209,4210,4211,4212,4213,4214,4215,4216,4217,4218,4219,4220,4221,4222,4223,4224,4225,4226,4227,4228,4229,4230,4231,4232,4233,4234,4235,4236,4237,4238,4239,4240,4241,4242,4243,4244,4245,4246,4247,4248,4249,4250,4251,4252,4253,4254,4255,4256,4257,4258,4259,4260,4261,4262,4263,4264,4265,4266,4267,4268,4269,4270,4271,4272,4273,4274,4275,4276,4277,4278,4279,4280,4281,4282,4283,4284,4285,4286,4287,4288,4289,4290,4291,4292,4293,4294,4295,4296,4297,4298,4299,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,4311,4312,4313,4314,4315,4316,4317,4318,4319,4320,4321,4322,4323,4324,4325,4326,4327,4328,4329,4330,4331,4332,4333,4334,4335,4336,4337,4338,4339,4340,4341,4342,4343,4344,4345,4346,4347,4348,4349,4350,4351,4352,4353,4354,4355,4356,4357,4358,4359,4360,4361,4362,4363,4364,4365,4366,4367,4368,4369,4370,4371,4372,4373,4374,4375,4376,4377,4378,4379,4380,4381,4382,4383,4384,4385,4386,4387,4388,4389,4390,4391,4392,4393,4394,4395,4396,4397,4398,4399,4400,4401,4402,4403,4404,4405,4406,4407,4408,4409,4410,4411,4412,4413,4414,4415,4416,4417,4418,4419,4420,4421,4422,4423,4424,4425,4426,4427,4428,4429,4430,4431,4432,4433,4434,4435,4436,4437,4438,4439,4440,4441,4442,4443,4444,4445,4446,4447,4448,4449,4450,4451,4452,4453,4454,4455,4456,4457,4458,4459,4460,4461,4462,4463,4464,4465,4466,4467,4468,4469,4470,4471,4472,4473,4474,4475,4476,4477,4478,4479,4480,4481,4482,4483,4484,4485,4486,4487,4488,4489,4490,4491,4492,4493,4494,4495,4496,4497,4498,4499,4500,4501,4502,4503,4504,4505,4506,4507,4508,4509,4510,4511,4512,4513,4514,4515,4516,4517,4518,4519,4520,4521,4522,4523,4524,4525,4526,4527,4528,4529,4530,4531,4532,4533,4534,4535,4536,4537,4538,4539,4540,4541,4542,4543,4544,4545,4546,4547,4548,4549,4550,4551,4552,4553,4554,4555,4556,4557,4558,4559,4560,4561,4562,4563,4564,4565,4566,4567,4568,4569,4570,4571,4572,4573,4574,4575,4576,4577,4578,4579,4580,4581,4582,4583,4584,4585,4586,4587,4588,4589,4590,4591,4592,4593,4594,4595,4596,4597,4598,4599,4600,4601,4602,4603,4604,4605,4606,4607,4608,4609,4610,4611,4612,4613,4614,4615,4616,4617,4618,4619,4620,4621,4622,4623,4624,4625,4626,4627,4628,4629,4630,4631,4632,4633,4634,4635,4636,4637,4638,4639,4640,4641,4642,4643,4644,4645,4646,4647,4648,4649,4650,4651,4652,4653,4654,4655,4656,4657,4658,4659,4660,4661,4662,4663,4664,4665,4666,4667,4668,4669,4670,4671,4672,4673,4674,4675,4676,4677,4678,4679,4680,4681,4682,4683,4684,4685,4686,4687,4688,4689,4690,4691,4692,4693,4694,4695,4696,4697,4698,4699,4700,4701,4702,4703,4704,4705,4706,4707,4708,4709,4710,4711,4712,4713,4714,4715,4716,4717,4718,4719,4720,4721,4722,4723,4724,4725,4726,4727,4728,4729,4730,4731,4732,4733,4734,4735,4736,4737,4738,4739,4740,4741,4742,4743,4744,4745,4746,4747,4748,4749,4750,4751,4752,4753,4754,4755,4756,4757,4758,4759,4760,4761,4762,4763,4764,4765,4766,4767,4768,4769,4770,4771,4772,4773,4774,4775,4776,4777,4778,4779,4780,4781,4782,4783,4784,4785,4786,4787,4788,4789,4790,4791,4792,4793,4794,4795,4796,4797,4798,4799,4800,4801,4802,4803,4804,4805,4806,4807,4808,4809,4810,4811,4812,4813,4814,4815,4816,4817,4818,4819,4820,4821,4822,4823,4824,4825,4826,4827,4828,4829,4830,4831,4832,4833,4834,4835,4836,4837,4838,4839,4840,4841,4842,4843,4844,4845,4846,4847,4848,4849,4850,4851,4852,4853,4854,4855,4856,4857,4858,4859,4860,4861,4862,4863,4864,4865,4866,4867,4868,4869,4870,4871,4872,4873,4874,4875,4876,4877,4878,4879,4880,4881,4882,4883,4884,4885,4886,4887,4888,4889,4890,4891,4892,4893,4894,4895,4896,4897,4898,4899,4900,4901,4902,4903,4904,4905,4906,4907,4908,4909,4910,4911,4912,4913,4914,4915,4916,4917,4918,4919,4920,4921,4922,4923,4924,4925,4926,4927,4928,4929,4930,4931,4932,4933,4934,4935,4936,4937,4938,4939,4940,4941,4942,4943,4944,4945,4946,4947,4948,4949,4950,4951,4952,4953,4954,4955,4956,4957,4958,4959,4960,4961,4962,4963,4964,4965,4966,4967,4968,4969,4970,4971,4972,4973,4974,4975,4976,4977,4978,4979,4980,4981,4982,4983,4984,4985,4986,4987,4988,4989,4990,4991,4992,4993,4994,4995,4996,4997,4998,4999,5000]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"151","column":"10"},"end":{"line":"151","column":"42"},"code":"new TokenType(\"num\", startsExpr),\n","startIndex":32,"endIndex":32,"highlightLines":[150]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"152","column":"13"},"end":{"line":"152","column":"48"},"code":"new TokenType(\"regexp\", startsExpr),\n","startIndex":35,"endIndex":35,"highlightLines":[151]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"153","column":"13"},"end":{"line":"153","column":"48"},"code":"new TokenType(\"string\", startsExpr),\n","startIndex":35,"endIndex":35,"highlightLines":[152]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"154","column":"11"},"end":{"line":"154","column":"44"},"code":"new TokenType(\"name\", startsExpr),\n","startIndex":33,"endIndex":33,"highlightLines":[153]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"155","column":"10"},"end":{"line":"155","column":"30"},"code":"new TokenType(\"eof\"),\n","startIndex":20,"endIndex":20,"highlightLines":[154]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"158","column":"15"},"end":{"line":"158","column":"71"},"code":"new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n","startIndex":56,"endIndex":56,"highlightLines":[157]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"159","column":"15"},"end":{"line":"159","column":"33"},"code":"new TokenType(\"]\"),\n","startIndex":18,"endIndex":18,"highlightLines":[158]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"160","column":"13"},"end":{"line":"160","column":"69"},"code":"new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n","startIndex":56,"endIndex":56,"highlightLines":[159]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"161","column":"13"},"end":{"line":"161","column":"31"},"code":"new TokenType(\"}\"),\n","startIndex":18,"endIndex":18,"highlightLines":[160]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"162","column":"13"},"end":{"line":"162","column":"69"},"code":"new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n","startIndex":56,"endIndex":56,"highlightLines":[161]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"163","column":"13"},"end":{"line":"163","column":"31"},"code":"new TokenType(\")\"),\n","startIndex":18,"endIndex":18,"highlightLines":[162]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"164","column":"12"},"end":{"line":"164","column":"42"},"code":"new TokenType(\",\", beforeExpr),\n","startIndex":30,"endIndex":30,"highlightLines":[163]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"165","column":"11"},"end":{"line":"165","column":"41"},"code":"new TokenType(\";\", beforeExpr),\n","startIndex":30,"endIndex":30,"highlightLines":[164]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"166","column":"12"},"end":{"line":"166","column":"42"},"code":"new TokenType(\":\", beforeExpr),\n","startIndex":30,"endIndex":30,"highlightLines":[165]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"167","column":"10"},"end":{"line":"167","column":"28"},"code":"new TokenType(\".\"),\n","startIndex":18,"endIndex":18,"highlightLines":[166]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"168","column":"15"},"end":{"line":"168","column":"45"},"code":"new TokenType(\"?\", beforeExpr),\n","startIndex":30,"endIndex":30,"highlightLines":[167]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"169","column":"12"},"end":{"line":"169","column":"43"},"code":"new TokenType(\"=>\", beforeExpr),\n","startIndex":31,"endIndex":31,"highlightLines":[168]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"170","column":"15"},"end":{"line":"170","column":"40"},"code":"new TokenType(\"template\"),\n","startIndex":25,"endIndex":25,"highlightLines":[169]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"171","column":"22"},"end":{"line":"171","column":"54"},"code":"new TokenType(\"invalidTemplate\"),\n","startIndex":32,"endIndex":32,"highlightLines":[170]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"172","column":"15"},"end":{"line":"172","column":"47"},"code":"new TokenType(\"...\", beforeExpr),\n","startIndex":32,"endIndex":32,"highlightLines":[171]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"173","column":"16"},"end":{"line":"173","column":"46"},"code":"new TokenType(\"`\", startsExpr),\n","startIndex":30,"endIndex":30,"highlightLines":[172]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"174","column":"19"},"end":{"line":"174","column":"76"},"code":"new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n","startIndex":57,"endIndex":57,"highlightLines":[173]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"190","column":"9"},"end":{"line":"190","column":"63"},"code":"new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n","startIndex":54,"endIndex":54,"highlightLines":[189]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"191","column":"13"},"end":{"line":"191","column":"68"},"code":"new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n","startIndex":55,"endIndex":55,"highlightLines":[190]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"192","column":"13"},"end":{"line":"192","column":"84"},"code":"new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n","startIndex":71,"endIndex":71,"highlightLines":[191]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"193","column":"13"},"end":{"line":"193","column":"85"},"code":"new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n","startIndex":72,"endIndex":72,"highlightLines":[192]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"194","column":"16"},"end":{"line":"194","column":"30"},"code":"binop(\"||\", 1),\n","startIndex":14,"endIndex":14,"highlightLines":[193]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"134","column":"12"},"end":{"line":"134","column":"64"},"code":"new TokenType(name, {beforeExpr: true, binop: prec})\n","startIndex":-1,"endIndex":-1,"highlightLines":[133]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"195","column":"17"},"end":{"line":"195","column":"31"},"code":"binop(\"&&\", 2),\n","startIndex":14,"endIndex":14,"highlightLines":[194]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"196","column":"16"},"end":{"line":"196","column":"29"},"code":"binop(\"|\", 3),\n","startIndex":13,"endIndex":13,"highlightLines":[195]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"197","column":"17"},"end":{"line":"197","column":"30"},"code":"binop(\"^\", 4),\n","startIndex":13,"endIndex":13,"highlightLines":[196]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"198","column":"17"},"end":{"line":"198","column":"30"},"code":"binop(\"&\", 5),\n","startIndex":13,"endIndex":13,"highlightLines":[197]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"199","column":"15"},"end":{"line":"199","column":"40"},"code":"binop(\"==/!=/===/!==\", 6),\n","startIndex":25,"endIndex":25,"highlightLines":[198]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"200","column":"17"},"end":{"line":"200","column":"38"},"code":"binop(\"</>/<=/>=\", 7),\n","startIndex":21,"endIndex":21,"highlightLines":[199]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"201","column":"15"},"end":{"line":"201","column":"36"},"code":"binop(\"<</>>/>>>\", 8),\n","startIndex":21,"endIndex":21,"highlightLines":[200]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"202","column":"14"},"end":{"line":"202","column":"96"},"code":"new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n","startIndex":82,"endIndex":82,"highlightLines":[201]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"203","column":"13"},"end":{"line":"203","column":"27"},"code":"binop(\"%\", 10),\n","startIndex":14,"endIndex":14,"highlightLines":[202]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"204","column":"11"},"end":{"line":"204","column":"25"},"code":"binop(\"*\", 10),\n","startIndex":14,"endIndex":14,"highlightLines":[203]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"205","column":"12"},"end":{"line":"205","column":"26"},"code":"binop(\"/\", 10),\n","startIndex":14,"endIndex":14,"highlightLines":[204]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"133","column":"3"},"end":{"line":"135","column":"4"},"code":"function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[132,133,134]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"206","column":"15"},"end":{"line":"206","column":"54"},"code":"new TokenType(\"**\", {beforeExpr: true}),\n","startIndex":39,"endIndex":39,"highlightLines":[205]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"209","column":"13"},"end":{"line":"209","column":"24"},"code":"kw(\"break\"),\n","startIndex":11,"endIndex":11,"highlightLines":[208]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"147","column":"31"},"end":{"line":"147","column":"59"},"code":"new TokenType(name, options)\n","startIndex":-1,"endIndex":-1,"highlightLines":[146]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"118","column":"19"},"end":{"line":"131","column":"4"},"code":"function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n","startIndex":421,"endIndex":421,"highlightLines":[117,118,119,120,121,122,123,124,125,126,127,128,129,130]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"210","column":"12"},"end":{"line":"210","column":"34"},"code":"kw(\"case\", beforeExpr),\n","startIndex":22,"endIndex":22,"highlightLines":[209]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"211","column":"13"},"end":{"line":"211","column":"24"},"code":"kw(\"catch\"),\n","startIndex":11,"endIndex":11,"highlightLines":[210]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"212","column":"16"},"end":{"line":"212","column":"30"},"code":"kw(\"continue\"),\n","startIndex":14,"endIndex":14,"highlightLines":[211]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"213","column":"16"},"end":{"line":"213","column":"30"},"code":"kw(\"debugger\"),\n","startIndex":14,"endIndex":14,"highlightLines":[212]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"214","column":"15"},"end":{"line":"214","column":"40"},"code":"kw(\"default\", beforeExpr),\n","startIndex":25,"endIndex":25,"highlightLines":[213]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"215","column":"10"},"end":{"line":"215","column":"52"},"code":"kw(\"do\", {isLoop: true, beforeExpr: true}),\n","startIndex":42,"endIndex":42,"highlightLines":[214]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"216","column":"12"},"end":{"line":"216","column":"34"},"code":"kw(\"else\", beforeExpr),\n","startIndex":22,"endIndex":22,"highlightLines":[215]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"217","column":"15"},"end":{"line":"217","column":"28"},"code":"kw(\"finally\"),\n","startIndex":13,"endIndex":13,"highlightLines":[216]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"218","column":"11"},"end":{"line":"218","column":"36"},"code":"kw(\"for\", {isLoop: true}),\n","startIndex":25,"endIndex":25,"highlightLines":[217]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"219","column":"16"},"end":{"line":"219","column":"42"},"code":"kw(\"function\", startsExpr),\n","startIndex":26,"endIndex":26,"highlightLines":[218]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"220","column":"10"},"end":{"line":"220","column":"18"},"code":"kw(\"if\"),\n","startIndex":8,"endIndex":8,"highlightLines":[219]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"221","column":"14"},"end":{"line":"221","column":"38"},"code":"kw(\"return\", beforeExpr),\n","startIndex":24,"endIndex":24,"highlightLines":[220]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"222","column":"14"},"end":{"line":"222","column":"26"},"code":"kw(\"switch\"),\n","startIndex":12,"endIndex":12,"highlightLines":[221]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"223","column":"13"},"end":{"line":"223","column":"36"},"code":"kw(\"throw\", beforeExpr),\n","startIndex":23,"endIndex":23,"highlightLines":[222]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"224","column":"11"},"end":{"line":"224","column":"20"},"code":"kw(\"try\"),\n","startIndex":9,"endIndex":9,"highlightLines":[223]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"225","column":"11"},"end":{"line":"225","column":"20"},"code":"kw(\"var\"),\n","startIndex":9,"endIndex":9,"highlightLines":[224]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"226","column":"13"},"end":{"line":"226","column":"24"},"code":"kw(\"const\"),\n","startIndex":11,"endIndex":11,"highlightLines":[225]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"227","column":"13"},"end":{"line":"227","column":"40"},"code":"kw(\"while\", {isLoop: true}),\n","startIndex":27,"endIndex":27,"highlightLines":[226]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"228","column":"12"},"end":{"line":"228","column":"22"},"code":"kw(\"with\"),\n","startIndex":10,"endIndex":10,"highlightLines":[227]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"229","column":"11"},"end":{"line":"229","column":"58"},"code":"kw(\"new\", {beforeExpr: true, startsExpr: true}),\n","startIndex":47,"endIndex":47,"highlightLines":[228]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"230","column":"12"},"end":{"line":"230","column":"34"},"code":"kw(\"this\", startsExpr),\n","startIndex":22,"endIndex":22,"highlightLines":[229]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"231","column":"13"},"end":{"line":"231","column":"36"},"code":"kw(\"super\", startsExpr),\n","startIndex":23,"endIndex":23,"highlightLines":[230]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"232","column":"13"},"end":{"line":"232","column":"36"},"code":"kw(\"class\", startsExpr),\n","startIndex":23,"endIndex":23,"highlightLines":[231]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"233","column":"15"},"end":{"line":"233","column":"40"},"code":"kw(\"extends\", beforeExpr),\n","startIndex":25,"endIndex":25,"highlightLines":[232]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"234","column":"14"},"end":{"line":"234","column":"26"},"code":"kw(\"export\"),\n","startIndex":12,"endIndex":12,"highlightLines":[233]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"235","column":"14"},"end":{"line":"235","column":"38"},"code":"kw(\"import\", startsExpr),\n","startIndex":24,"endIndex":24,"highlightLines":[234]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"236","column":"12"},"end":{"line":"236","column":"34"},"code":"kw(\"null\", startsExpr),\n","startIndex":22,"endIndex":22,"highlightLines":[235]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"237","column":"12"},"end":{"line":"237","column":"34"},"code":"kw(\"true\", startsExpr),\n","startIndex":22,"endIndex":22,"highlightLines":[236]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"238","column":"13"},"end":{"line":"238","column":"36"},"code":"kw(\"false\", startsExpr),\n","startIndex":23,"endIndex":23,"highlightLines":[237]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"239","column":"10"},"end":{"line":"239","column":"48"},"code":"kw(\"in\", {beforeExpr: true, binop: 7}),\n","startIndex":38,"endIndex":38,"highlightLines":[238]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"240","column":"18"},"end":{"line":"240","column":"64"},"code":"kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n","startIndex":46,"endIndex":46,"highlightLines":[239]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"241","column":"14"},"end":{"line":"241","column":"78"},"code":"kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n","startIndex":64,"endIndex":64,"highlightLines":[240]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"242","column":"12"},"end":{"line":"242","column":"74"},"code":"kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n","startIndex":62,"endIndex":62,"highlightLines":[241]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"243","column":"14"},"end":{"line":"243","column":"78"},"code":"kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n","startIndex":-1,"endIndex":-1,"highlightLines":[242]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"143","column":"3"},"end":{"line":"148","column":"4"},"code":"function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[142,143,144,145,146,147]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2997","column":"13"},"end":{"line":"2997","column":"39"},"code":"new TokContext(\"{\", false),\n","startIndex":26,"endIndex":26,"highlightLines":[2996]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2998","column":"13"},"end":{"line":"2998","column":"38"},"code":"new TokContext(\"{\", true),\n","startIndex":25,"endIndex":25,"highlightLines":[2997]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2999","column":"13"},"end":{"line":"2999","column":"40"},"code":"new TokContext(\"${\", false),\n","startIndex":27,"endIndex":27,"highlightLines":[2998]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3000","column":"13"},"end":{"line":"3000","column":"39"},"code":"new TokContext(\"(\", false),\n","startIndex":26,"endIndex":26,"highlightLines":[2999]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3001","column":"13"},"end":{"line":"3001","column":"38"},"code":"new TokContext(\"(\", true),\n","startIndex":25,"endIndex":25,"highlightLines":[3000]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3002","column":"13"},"end":{"line":"3002","column":"95"},"code":"new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n","startIndex":82,"endIndex":82,"highlightLines":[3001]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3003","column":"13"},"end":{"line":"3003","column":"46"},"code":"new TokContext(\"function\", false),\n","startIndex":33,"endIndex":33,"highlightLines":[3002]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3004","column":"13"},"end":{"line":"3004","column":"45"},"code":"new TokContext(\"function\", true),\n","startIndex":32,"endIndex":32,"highlightLines":[3003]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3005","column":"17"},"end":{"line":"3005","column":"68"},"code":"new TokContext(\"function\", true, false, null, true),\n","startIndex":51,"endIndex":51,"highlightLines":[3004]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3006","column":"12"},"end":{"line":"3006","column":"64"},"code":"new TokContext(\"function\", false, false, null, true)\n","startIndex":-1,"endIndex":-1,"highlightLines":[3005]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"2988","column":"20"},"end":{"line":"2994","column":"4"},"code":"function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n","startIndex":234,"endIndex":234,"highlightLines":[2987,2988,2989,2990,2991,2992,2993]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3170","column":"3"},"end":{"line":"3170","column":"22"},"code":"buildUnicodeData(9);\n","startIndex":19,"endIndex":19,"highlightLines":[3169]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3156","column":"3"},"end":{"line":"3169","column":"4"},"code":"function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[3155,3156,3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3158","column":"15"},"end":{"line":"3158","column":"101"},"code":"wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n","startIndex":86,"endIndex":86,"highlightLines":[3157]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"274","column":"3"},"end":{"line":"276","column":"4"},"code":"function wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[273,274,275]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3160","column":"27"},"end":{"line":"3160","column":"68"},"code":"wordsRegexp(unicodeGeneralCategoryValues),\n","startIndex":41,"endIndex":41,"highlightLines":[3159]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"274","column":"3"},"end":{"line":"276","column":"4"},"code":"function wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[273,274,275]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3161","column":"17"},"end":{"line":"3161","column":"62"},"code":"wordsRegexp(unicodeScriptValues[ecmaVersion])\n","startIndex":-1,"endIndex":-1,"highlightLines":[3160]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"274","column":"3"},"end":{"line":"276","column":"4"},"code":"function wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[273,274,275]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3171","column":"3"},"end":{"line":"3171","column":"23"},"code":"buildUnicodeData(10);\n","startIndex":20,"endIndex":20,"highlightLines":[3170]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3156","column":"3"},"end":{"line":"3169","column":"4"},"code":"function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[3155,3156,3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168]}},{"caller":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3172","column":"3"},"end":{"line":"3172","column":"23"},"code":"buildUnicodeData(11);\n","startIndex":20,"endIndex":20,"highlightLines":[3171]},"callee":{"fileName":"acorn.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js","start":{"line":"3156","column":"3"},"end":{"line":"3169","column":"4"},"code":"function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n","startIndex":-1,"endIndex":-1,"highlightLines":[3155,3156,3157,3158,3159,3160,3161,3162,3163,3164,3165,3166,3167,3168]}},{"caller":{"fileName":"tests.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/tests.js","start":{"line":"10","column":"1"},"end":{"line":"32","column":"3"},"code":"test(\"import ''\", {\n  type: \"Program\",\n  start: 0,\n  end: 9,\n  body: [\n    {\n      type: \"ImportDeclaration\",\n      start: 0,\n      end: 9,\n      specifiers: [],\n      source: {\n        type: \"Literal\",\n        start: 7,\n        end: 9,\n        value: \"\",\n        raw: \"''\"\n      }\n    }\n  ]\n}, {\n  ecmaVersion: 5,\n  sourceType: \"module\"\n});\n","startIndex":340,"endIndex":340,"highlightLines":[9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31]},"callee":{"fileName":"driver.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/driver.js","start":{"line":"3","column":"16"},"end":{"line":"5","column":"2"},"code":"function(code, ast, options) {\n  tests.push({code: code, ast: ast, options: options});\n};\n","startIndex":88,"endIndex":88,"highlightLines":[2,3,4]}},{"caller":{"fileName":"tests.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/tests.js","start":{"line":"34","column":"1"},"end":{"line":"37","column":"3"},"code":"testFail(\"import('')\", \"Unexpected token (1:6)\", {\n  ecmaVersion: 5,\n  sourceType: \"module\"\n});\n","startIndex":94,"endIndex":94,"highlightLines":[33,34,35,36]},"callee":{"fileName":"driver.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/driver.js","start":{"line":"6","column":"20"},"end":{"line":"8","column":"2"},"code":"function(code, message, options) {\n  tests.push({code: code, error: message, options: options});\n};\n","startIndex":98,"endIndex":98,"highlightLines":[5,6,7]}},{"caller":{"fileName":"tests.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/tests.js","start":{"line":"39","column":"1"},"end":{"line":"64","column":"3"},"code":"test(\"new Object\", {\n  type: \"Program\",\n  start: 0,\n  end: 10,\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      start: 0,\n      end: 10,\n      expression: {\n        type: \"NewExpression\",\n        start: 0,\n        end: 10,\n        callee: {\n          type: \"Identifier\",\n          start: 4,\n          end: 10,\n          name: \"Object\"\n        },\n        arguments: []\n      }\n    }\n  ]\n}, {\n  allowReserved: \"never\"\n});\n","startIndex":426,"endIndex":426,"highlightLines":[38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63]},"callee":{"fileName":"driver.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/driver.js","start":{"line":"3","column":"16"},"end":{"line":"5","column":"2"},"code":"function(code, ast, options) {\n  tests.push({code: code, ast: ast, options: options});\n};\n","startIndex":88,"endIndex":88,"highlightLines":[2,3,4]}},{"caller":{"fileName":"tests.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/tests.js","start":{"line":"66","column":"1"},"end":{"line":"106","column":"3"},"code":"test(\"this\\n\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"ThisExpression\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 0\n    }\n  }\n});\n","startIndex":597,"endIndex":597,"highlightLines":[65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105]},"callee":{"fileName":"driver.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/driver.js","start":{"line":"3","column":"16"},"end":{"line":"5","column":"2"},"code":"function(code, ast, options) {\n  tests.push({code: code, ast: ast, options: options});\n};\n","startIndex":88,"endIndex":88,"highlightLines":[2,3,4]}},{"caller":{"fileName":"tests.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/tests.js","start":{"line":"108","column":"1"},"end":{"line":"149","column":"3"},"code":"test(\"null\\n\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: null,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 0\n    }\n  }\n});\n","startIndex":611,"endIndex":611,"highlightLines":[107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148]},"callee":{"fileName":"driver.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/driver.js","start":{"line":"3","column":"16"},"end":{"line":"5","column":"2"},"code":"function(code, ast, options) {\n  tests.push({code: code, ast: ast, options: options});\n};\n","startIndex":88,"endIndex":88,"highlightLines":[2,3,4]}},{"caller":{"fileName":"tests.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/tests.js","start":{"line":"151","column":"1"},"end":{"line":"192","column":"3"}},"callee":{"fileName":"driver.js","fullPath":"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/driver.js","start":{"line":"3","column":"16"},"end":{"line":"5","column":"2"}}}];
let __files = {"/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/run.js":"(function() {\n  var driver = require(\"./driver.js\")\n  require(\"./tests.js\");\n  require(\"./tests-harmony.js\");\n  require(\"./tests-es7.js\");\n  require(\"./tests-asyncawait.js\");\n  require(\"./tests-await-top-level.js\");\n  require(\"./tests-trailing-commas-in-func.js\");\n  require(\"./tests-template-literal-revision.js\");\n  require(\"./tests-directive.js\");\n  require(\"./tests-rest-spread-properties.js\");\n  require(\"./tests-async-iteration.js\");\n  require(\"./tests-regexp.js\");\n  require(\"./tests-regexp-2018.js\");\n  require(\"./tests-json-superset.js\");\n  require(\"./tests-optional-catch-binding.js\");\n  require(\"./tests-bigint.js\");\n  require(\"./tests-dynamic-import.js\");\n  var acorn = require(\"../acorn\")\n  var acorn_loose = require(\"../acorn-loose\")\n\n  var htmlLog = typeof document === \"object\" && document.getElementById('log');\n  var htmlGroup = htmlLog;\n\n  function group(name) {\n    if (htmlGroup) {\n      var parentGroup = htmlGroup;\n      htmlGroup = document.createElement(\"ul\");\n      var item = document.createElement(\"li\");\n      item.textContent = name;\n      item.appendChild(htmlGroup);\n      parentGroup.appendChild(item);\n    }\n    if (typeof console === \"object\" && console.group) {\n      console.group(name);\n    }\n  }\n\n  function groupEnd() {\n    if (htmlGroup) {\n      htmlGroup = htmlGroup.parentElement.parentElement;\n    }\n    if (typeof console === \"object\" && console.groupEnd) {\n      console.groupEnd(name);\n    }\n  }\n\n  function log(title, message) {\n    if (htmlGroup) {\n      var elem = document.createElement(\"li\");\n      elem.innerHTML = \"<b>\" + title + \"</b> \" + message;\n      htmlGroup.appendChild(elem);\n    }\n    if (typeof console === \"object\") console.log(title, message);\n  }\n\n  var stats, modes = {\n    Normal: {\n      config: {\n        parse: acorn.parse\n      }\n    },\n    Loose: {\n      config: {\n        parse: acorn_loose.parse,\n        loose: true,\n        filter: function (test) {\n          var opts = test.options || {};\n          return opts.loose !== false;\n        }\n      }\n    }\n  };\n\n  function report(state, code, message) {\n    if (state != \"ok\") {++stats.failed; log(code, message);}\n    ++stats.testsRun;\n  }\n/*\n  group(\"Errors\");\n\n  for (var name in modes) {\n    group(name);\n    var mode = modes[name];\n    stats = mode.stats = {testsRun: 0, failed: 0};\n    var t0 = +new Date;\n    driver.runTests(mode.config, report);\n    mode.stats.duration = +new Date - t0;\n    groupEnd();\n  }\n\n  groupEnd();\n\n  function outputStats(name, stats) {\n    log(name + \":\", stats.testsRun + \" tests run in \" + stats.duration + \"ms; \" +\n      (stats.failed ? stats.failed + \" failures.\" : \"all passed.\"));\n  }\n\n  var total = {testsRun: 0, failed: 0, duration: 0};\n\n  group(\"Stats\");\n\n  for (var name in modes) {\n    var stats = modes[name].stats;\n    outputStats(name + \" parser\", stats);\n    for (var key in stats) total[key] += stats[key];\n  }\n\n  outputStats(\"Total\", total);\n\n  groupEnd();\n\n  if (total.failed && typeof process === \"object\") {\n    process.stdout.write(\"\", function() {\n      process.exit(1);\n    });\n  }\n  */\n})();\n","/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/acorn/dist/acorn.js":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (global = global || self, factory(global.acorn = {}));\n}(this, function (exports) { 'use strict';\n\n  // Reserved word lists for various dialects of the language\n\n  var reservedWords = {\n    3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n    5: \"class enum extends super const export import\",\n    6: \"enum\",\n    strict: \"implements interface let package private protected public static yield\",\n    strictBind: \"eval arguments\"\n  };\n\n  // And the keywords\n\n  var ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\n  var keywords = {\n    5: ecma5AndLessKeywords,\n    \"5module\": ecma5AndLessKeywords + \" export import\",\n    6: ecma5AndLessKeywords + \" const class extends export import super\"\n  };\n\n  var keywordRelationalOperator = /^in(stanceof)?$/;\n\n  // ## Character categories\n\n  // Big ugly regular expressions that match characters in the\n  // whitespace, identifier, and identifier-start categories. These\n  // are only applied when a character is found to actually have a\n  // code point above 128.\n  // Generated by `bin/generate-identifier-regex.js`.\n  var nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e86-\\u0e8a\\u0e8c-\\u0ea3\\u0ea5\\u0ea7-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf3\\u1cf5\\u1cf6\\u1cfa\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7bf\\ua7c2-\\ua7c6\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab67\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\n  var nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\n  var nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\n  var nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\n  nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n  // These are a run-length and offset encoded representation of the\n  // >0xffff code points that are a valid part of identifiers. The\n  // offset starts at 0x10000, and each pair of numbers represents an\n  // offset to the next range, and then a size of the range. They were\n  // generated by bin/generate-identifier-regex.js\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,155,22,13,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,21,0,33,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,14,0,72,26,230,43,117,63,32,0,161,7,3,38,17,0,2,0,29,0,11,39,8,0,22,0,12,45,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,74,6,0,67,12,65,1,2,0,29,6135,9,754,9486,286,50,2,18,3,9,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,2357,44,11,6,17,0,370,43,1301,196,60,67,8,0,1205,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n  // eslint-disable-next-line comma-spacing\n  var astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,232,6,3,6,4,0,29,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1014,0,2,54,8,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,262,6,10,9,419,13,1495,6,110,6,6,9,792487,239];\n\n  // This has a complexity linear to the value of the code. The\n  // assumption is that looking up astral identifier characters is\n  // rare.\n  function isInAstralSet(code, set) {\n    var pos = 0x10000;\n    for (var i = 0; i < set.length; i += 2) {\n      pos += set[i];\n      if (pos > code) { return false }\n      pos += set[i + 1];\n      if (pos >= code) { return true }\n    }\n  }\n\n  // Test whether a given character code starts an identifier.\n\n  function isIdentifierStart(code, astral) {\n    if (code < 65) { return code === 36 }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes)\n  }\n\n  // Test whether a given character is part of an identifier.\n\n  function isIdentifierChar(code, astral) {\n    if (code < 48) { return code === 36 }\n    if (code < 58) { return true }\n    if (code < 65) { return false }\n    if (code < 91) { return true }\n    if (code < 97) { return code === 95 }\n    if (code < 123) { return true }\n    if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n    if (astral === false) { return false }\n    return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n  }\n\n  // ## Token types\n\n  // The assignment of fine-grained, information-carrying type objects\n  // allows the tokenizer to store the information it has about a\n  // token in a way that is very cheap for the parser to look up.\n\n  // All token type variables start with an underscore, to make them\n  // easy to recognize.\n\n  // The `beforeExpr` property is used to disambiguate between regular\n  // expressions and divisions. It is set on all token types that can\n  // be followed by an expression (thus, a slash after them would be a\n  // regular expression).\n  //\n  // The `startsExpr` property is used to check if the token ends a\n  // `yield` expression. It is set on all token types that either can\n  // directly start an expression (like a quotation mark) or can\n  // continue an expression (like the body of a string).\n  //\n  // `isLoop` marks a keyword as starting a loop, which is important\n  // to know when parsing a label, in order to allow or disallow\n  // continue jumps to that label.\n\n  var TokenType = function TokenType(label, conf) {\n    if ( conf === void 0 ) conf = {};\n\n    this.label = label;\n    this.keyword = conf.keyword;\n    this.beforeExpr = !!conf.beforeExpr;\n    this.startsExpr = !!conf.startsExpr;\n    this.isLoop = !!conf.isLoop;\n    this.isAssign = !!conf.isAssign;\n    this.prefix = !!conf.prefix;\n    this.postfix = !!conf.postfix;\n    this.binop = conf.binop || null;\n    this.updateContext = null;\n  };\n\n  function binop(name, prec) {\n    return new TokenType(name, {beforeExpr: true, binop: prec})\n  }\n  var beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true};\n\n  // Map keyword names to token types.\n\n  var keywords$1 = {};\n\n  // Succinct definitions of keyword token types\n  function kw(name, options) {\n    if ( options === void 0 ) options = {};\n\n    options.keyword = name;\n    return keywords$1[name] = new TokenType(name, options)\n  }\n\n  var types = {\n    num: new TokenType(\"num\", startsExpr),\n    regexp: new TokenType(\"regexp\", startsExpr),\n    string: new TokenType(\"string\", startsExpr),\n    name: new TokenType(\"name\", startsExpr),\n    eof: new TokenType(\"eof\"),\n\n    // Punctuation token types.\n    bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n    bracketR: new TokenType(\"]\"),\n    braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n    braceR: new TokenType(\"}\"),\n    parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n    parenR: new TokenType(\")\"),\n    comma: new TokenType(\",\", beforeExpr),\n    semi: new TokenType(\";\", beforeExpr),\n    colon: new TokenType(\":\", beforeExpr),\n    dot: new TokenType(\".\"),\n    question: new TokenType(\"?\", beforeExpr),\n    arrow: new TokenType(\"=>\", beforeExpr),\n    template: new TokenType(\"template\"),\n    invalidTemplate: new TokenType(\"invalidTemplate\"),\n    ellipsis: new TokenType(\"...\", beforeExpr),\n    backQuote: new TokenType(\"`\", startsExpr),\n    dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n    // Operators. These carry several kinds of properties to help the\n    // parser use them properly (the presence of these properties is\n    // what categorizes them as operators).\n    //\n    // `binop`, when present, specifies that this operator is a binary\n    // operator, and will refer to its precedence.\n    //\n    // `prefix` and `postfix` mark the operator as a prefix or postfix\n    // unary operator.\n    //\n    // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n    // binary operators with a very low precedence, that should result\n    // in AssignmentExpression nodes.\n\n    eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n    assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n    incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n    prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    logicalOR: binop(\"||\", 1),\n    logicalAND: binop(\"&&\", 2),\n    bitwiseOR: binop(\"|\", 3),\n    bitwiseXOR: binop(\"^\", 4),\n    bitwiseAND: binop(\"&\", 5),\n    equality: binop(\"==/!=/===/!==\", 6),\n    relational: binop(\"</>/<=/>=\", 7),\n    bitShift: binop(\"<</>>/>>>\", 8),\n    plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n    modulo: binop(\"%\", 10),\n    star: binop(\"*\", 10),\n    slash: binop(\"/\", 10),\n    starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n    // Keyword token types.\n    _break: kw(\"break\"),\n    _case: kw(\"case\", beforeExpr),\n    _catch: kw(\"catch\"),\n    _continue: kw(\"continue\"),\n    _debugger: kw(\"debugger\"),\n    _default: kw(\"default\", beforeExpr),\n    _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n    _else: kw(\"else\", beforeExpr),\n    _finally: kw(\"finally\"),\n    _for: kw(\"for\", {isLoop: true}),\n    _function: kw(\"function\", startsExpr),\n    _if: kw(\"if\"),\n    _return: kw(\"return\", beforeExpr),\n    _switch: kw(\"switch\"),\n    _throw: kw(\"throw\", beforeExpr),\n    _try: kw(\"try\"),\n    _var: kw(\"var\"),\n    _const: kw(\"const\"),\n    _while: kw(\"while\", {isLoop: true}),\n    _with: kw(\"with\"),\n    _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n    _this: kw(\"this\", startsExpr),\n    _super: kw(\"super\", startsExpr),\n    _class: kw(\"class\", startsExpr),\n    _extends: kw(\"extends\", beforeExpr),\n    _export: kw(\"export\"),\n    _import: kw(\"import\", startsExpr),\n    _null: kw(\"null\", startsExpr),\n    _true: kw(\"true\", startsExpr),\n    _false: kw(\"false\", startsExpr),\n    _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n    _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n    _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n    _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n  };\n\n  // Matches a whole line break (where CRLF is considered a single\n  // line break). Used to count lines.\n\n  var lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\n  var lineBreakG = new RegExp(lineBreak.source, \"g\");\n\n  function isNewLine(code, ecma2019String) {\n    return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n  }\n\n  var nonASCIIwhitespace = /[\\u1680\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\n  var skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\n  var ref = Object.prototype;\n  var hasOwnProperty = ref.hasOwnProperty;\n  var toString = ref.toString;\n\n  // Checks if an object has a property.\n\n  function has(obj, propName) {\n    return hasOwnProperty.call(obj, propName)\n  }\n\n  var isArray = Array.isArray || (function (obj) { return (\n    toString.call(obj) === \"[object Array]\"\n  ); });\n\n  function wordsRegexp(words) {\n    return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n  }\n\n  // These are used when `options.locations` is on, for the\n  // `startLoc` and `endLoc` properties.\n\n  var Position = function Position(line, col) {\n    this.line = line;\n    this.column = col;\n  };\n\n  Position.prototype.offset = function offset (n) {\n    return new Position(this.line, this.column + n)\n  };\n\n  var SourceLocation = function SourceLocation(p, start, end) {\n    this.start = start;\n    this.end = end;\n    if (p.sourceFile !== null) { this.source = p.sourceFile; }\n  };\n\n  // The `getLineInfo` function is mostly useful when the\n  // `locations` option is off (for performance reasons) and you\n  // want to find the line/column position for a given character\n  // offset. `input` should be the code string that the offset refers\n  // into.\n\n  function getLineInfo(input, offset) {\n    for (var line = 1, cur = 0;;) {\n      lineBreakG.lastIndex = cur;\n      var match = lineBreakG.exec(input);\n      if (match && match.index < offset) {\n        ++line;\n        cur = match.index + match[0].length;\n      } else {\n        return new Position(line, offset - cur)\n      }\n    }\n  }\n\n  // A second optional argument can be given to further configure\n  // the parser process. These options are recognized:\n\n  var defaultOptions = {\n    // `ecmaVersion` indicates the ECMAScript version to parse. Must be\n    // either 3, 5, 6 (2015), 7 (2016), 8 (2017), 9 (2018), or 10\n    // (2019). This influences support for strict mode, the set of\n    // reserved words, and support for new syntax features. The default\n    // is 10.\n    ecmaVersion: 10,\n    // `sourceType` indicates the mode the code should be parsed in.\n    // Can be either `\"script\"` or `\"module\"`. This influences global\n    // strict mode and parsing of `import` and `export` declarations.\n    sourceType: \"script\",\n    // `onInsertedSemicolon` can be a callback that will be called\n    // when a semicolon is automatically inserted. It will be passed\n    // the position of the comma as an offset, and if `locations` is\n    // enabled, it is given the location as a `{line, column}` object\n    // as second argument.\n    onInsertedSemicolon: null,\n    // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n    // trailing commas.\n    onTrailingComma: null,\n    // By default, reserved words are only enforced if ecmaVersion >= 5.\n    // Set `allowReserved` to a boolean value to explicitly turn this on\n    // an off. When this option has the value \"never\", reserved words\n    // and keywords can also not be used as property names.\n    allowReserved: null,\n    // When enabled, a return at the top level is not considered an\n    // error.\n    allowReturnOutsideFunction: false,\n    // When enabled, import/export statements are not constrained to\n    // appearing at the top of the program.\n    allowImportExportEverywhere: false,\n    // When enabled, await identifiers are allowed to appear at the top-level scope,\n    // but they are still not allowed in non-async functions.\n    allowAwaitOutsideFunction: false,\n    // When enabled, hashbang directive in the beginning of file\n    // is allowed and treated as a line comment.\n    allowHashBang: false,\n    // When `locations` is on, `loc` properties holding objects with\n    // `start` and `end` properties in `{line, column}` form (with\n    // line being 1-based and column 0-based) will be attached to the\n    // nodes.\n    locations: false,\n    // A function can be passed as `onToken` option, which will\n    // cause Acorn to call that function with object in the same\n    // format as tokens returned from `tokenizer().getToken()`. Note\n    // that you are not allowed to call the parser from the\n    // callback—that will corrupt its internal state.\n    onToken: null,\n    // A function can be passed as `onComment` option, which will\n    // cause Acorn to call that function with `(block, text, start,\n    // end)` parameters whenever a comment is skipped. `block` is a\n    // boolean indicating whether this is a block (`/* */`) comment,\n    // `text` is the content of the comment, and `start` and `end` are\n    // character offsets that denote the start and end of the comment.\n    // When the `locations` option is on, two more parameters are\n    // passed, the full `{line, column}` locations of the start and\n    // end of the comments. Note that you are not allowed to call the\n    // parser from the callback—that will corrupt its internal state.\n    onComment: null,\n    // Nodes have their start and end characters offsets recorded in\n    // `start` and `end` properties (directly on the node, rather than\n    // the `loc` object, which holds line/column data. To also add a\n    // [semi-standardized][range] `range` property holding a `[start,\n    // end]` array with the same numbers, set the `ranges` option to\n    // `true`.\n    //\n    // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n    ranges: false,\n    // It is possible to parse multiple files into a single AST by\n    // passing the tree produced by parsing the first file as\n    // `program` option in subsequent parses. This will add the\n    // toplevel forms of the parsed file to the `Program` (top) node\n    // of an existing parse tree.\n    program: null,\n    // When `locations` is on, you can pass this to record the source\n    // file in every node's `loc` object.\n    sourceFile: null,\n    // This value, if given, is stored in every node, whether\n    // `locations` is on or off.\n    directSourceFile: null,\n    // When enabled, parenthesized expressions are represented by\n    // (non-standard) ParenthesizedExpression nodes\n    preserveParens: false\n  };\n\n  // Interpret and default an options object\n\n  function getOptions(opts) {\n    var options = {};\n\n    for (var opt in defaultOptions)\n      { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n    if (options.ecmaVersion >= 2015)\n      { options.ecmaVersion -= 2009; }\n\n    if (options.allowReserved == null)\n      { options.allowReserved = options.ecmaVersion < 5; }\n\n    if (isArray(options.onToken)) {\n      var tokens = options.onToken;\n      options.onToken = function (token) { return tokens.push(token); };\n    }\n    if (isArray(options.onComment))\n      { options.onComment = pushComment(options, options.onComment); }\n\n    return options\n  }\n\n  function pushComment(options, array) {\n    return function(block, text, start, end, startLoc, endLoc) {\n      var comment = {\n        type: block ? \"Block\" : \"Line\",\n        value: text,\n        start: start,\n        end: end\n      };\n      if (options.locations)\n        { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n      if (options.ranges)\n        { comment.range = [start, end]; }\n      array.push(comment);\n    }\n  }\n\n  // Each scope gets a bitset that may contain these flags\n  var\n      SCOPE_TOP = 1,\n      SCOPE_FUNCTION = 2,\n      SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION,\n      SCOPE_ASYNC = 4,\n      SCOPE_GENERATOR = 8,\n      SCOPE_ARROW = 16,\n      SCOPE_SIMPLE_CATCH = 32,\n      SCOPE_SUPER = 64,\n      SCOPE_DIRECT_SUPER = 128;\n\n  function functionFlags(async, generator) {\n    return SCOPE_FUNCTION | (async ? SCOPE_ASYNC : 0) | (generator ? SCOPE_GENERATOR : 0)\n  }\n\n  // Used in checkLVal and declareName to determine the type of a binding\n  var\n      BIND_NONE = 0, // Not a binding\n      BIND_VAR = 1, // Var-style binding\n      BIND_LEXICAL = 2, // Let- or const-style binding\n      BIND_FUNCTION = 3, // Function declaration\n      BIND_SIMPLE_CATCH = 4, // Simple (identifier pattern) catch binding\n      BIND_OUTSIDE = 5; // Special case for function names as bound inside the function\n\n  var Parser = function Parser(options, input, startPos) {\n    this.options = options = getOptions(options);\n    this.sourceFile = options.sourceFile;\n    this.keywords = wordsRegexp(keywords[options.ecmaVersion >= 6 ? 6 : options.sourceType === \"module\" ? \"5module\" : 5]);\n    var reserved = \"\";\n    if (options.allowReserved !== true) {\n      for (var v = options.ecmaVersion;; v--)\n        { if (reserved = reservedWords[v]) { break } }\n      if (options.sourceType === \"module\") { reserved += \" await\"; }\n    }\n    this.reservedWords = wordsRegexp(reserved);\n    var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n    this.reservedWordsStrict = wordsRegexp(reservedStrict);\n    this.reservedWordsStrictBind = wordsRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n    this.input = String(input);\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos;\n      this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n    } else {\n      this.pos = this.lineStart = 0;\n      this.curLine = 1;\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = types.eof;\n    // For tokens that include more information than their type, the value\n    this.value = null;\n    // Its start and end offset\n    this.start = this.end = this.pos;\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition();\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null;\n    this.lastTokStart = this.lastTokEnd = this.pos;\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext();\n    this.exprAllowed = true;\n\n    // Figure out if it's a module code.\n    this.inModule = options.sourceType === \"module\";\n    this.strict = this.inModule || this.strictDirective(this.pos);\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1;\n\n    // Positions to delayed-check that yield/await does not exist in default parameters.\n    this.yieldPos = this.awaitPos = this.awaitIdentPos = 0;\n    // Labels in scope.\n    this.labels = [];\n    // Thus-far undefined exports.\n    this.undefinedExports = {};\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n      { this.skipLineComment(2); }\n\n    // Scope tracking for duplicate variable names (see scope.js)\n    this.scopeStack = [];\n    this.enterScope(SCOPE_TOP);\n\n    // For RegExp validation\n    this.regexpState = null;\n  };\n\n  var prototypeAccessors = { inFunction: { configurable: true },inGenerator: { configurable: true },inAsync: { configurable: true },allowSuper: { configurable: true },allowDirectSuper: { configurable: true },treatFunctionsAsVar: { configurable: true } };\n\n  Parser.prototype.parse = function parse () {\n    var node = this.options.program || this.startNode();\n    this.nextToken();\n    return this.parseTopLevel(node)\n  };\n\n  prototypeAccessors.inFunction.get = function () { return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0 };\n  prototypeAccessors.inGenerator.get = function () { return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 };\n  prototypeAccessors.inAsync.get = function () { return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 };\n  prototypeAccessors.allowSuper.get = function () { return (this.currentThisScope().flags & SCOPE_SUPER) > 0 };\n  prototypeAccessors.allowDirectSuper.get = function () { return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0 };\n  prototypeAccessors.treatFunctionsAsVar.get = function () { return this.treatFunctionsAsVarInScope(this.currentScope()) };\n\n  // Switch to a getter for 7.0.0.\n  Parser.prototype.inNonArrowFunction = function inNonArrowFunction () { return (this.currentThisScope().flags & SCOPE_FUNCTION) > 0 };\n\n  Parser.extend = function extend () {\n      var plugins = [], len = arguments.length;\n      while ( len-- ) plugins[ len ] = arguments[ len ];\n\n    var cls = this;\n    for (var i = 0; i < plugins.length; i++) { cls = plugins[i](cls); }\n    return cls\n  };\n\n  Parser.parse = function parse (input, options) {\n    return new this(options, input).parse()\n  };\n\n  Parser.parseExpressionAt = function parseExpressionAt (input, pos, options) {\n    var parser = new this(options, input, pos);\n    parser.nextToken();\n    return parser.parseExpression()\n  };\n\n  Parser.tokenizer = function tokenizer (input, options) {\n    return new this(options, input)\n  };\n\n  Object.defineProperties( Parser.prototype, prototypeAccessors );\n\n  var pp = Parser.prototype;\n\n  // ## Parser utilities\n\n  var literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\")/;\n  pp.strictDirective = function(start) {\n    for (;;) {\n      // Try to find string literal.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      var match = literal.exec(this.input.slice(start));\n      if (!match) { return false }\n      if ((match[1] || match[2]) === \"use strict\") { return true }\n      start += match[0].length;\n\n      // Skip semicolon, if any.\n      skipWhiteSpace.lastIndex = start;\n      start += skipWhiteSpace.exec(this.input)[0].length;\n      if (this.input[start] === \";\")\n        { start++; }\n    }\n  };\n\n  // Predicate that tests whether the next token is of the given\n  // type, and if yes, consumes it as a side effect.\n\n  pp.eat = function(type) {\n    if (this.type === type) {\n      this.next();\n      return true\n    } else {\n      return false\n    }\n  };\n\n  // Tests whether parsed token is a contextual keyword.\n\n  pp.isContextual = function(name) {\n    return this.type === types.name && this.value === name && !this.containsEsc\n  };\n\n  // Consumes contextual keyword if possible.\n\n  pp.eatContextual = function(name) {\n    if (!this.isContextual(name)) { return false }\n    this.next();\n    return true\n  };\n\n  // Asserts that following token is given contextual keyword.\n\n  pp.expectContextual = function(name) {\n    if (!this.eatContextual(name)) { this.unexpected(); }\n  };\n\n  // Test whether a semicolon can be inserted at the current position.\n\n  pp.canInsertSemicolon = function() {\n    return this.type === types.eof ||\n      this.type === types.braceR ||\n      lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  pp.insertSemicolon = function() {\n    if (this.canInsertSemicolon()) {\n      if (this.options.onInsertedSemicolon)\n        { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n      return true\n    }\n  };\n\n  // Consume a semicolon, or, failing that, see if we are allowed to\n  // pretend that there is a semicolon at this position.\n\n  pp.semicolon = function() {\n    if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n  };\n\n  pp.afterTrailingComma = function(tokType, notNext) {\n    if (this.type === tokType) {\n      if (this.options.onTrailingComma)\n        { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n      if (!notNext)\n        { this.next(); }\n      return true\n    }\n  };\n\n  // Expect a token of a given type. If found, consume it, otherwise,\n  // raise an unexpected token error.\n\n  pp.expect = function(type) {\n    this.eat(type) || this.unexpected();\n  };\n\n  // Raise an unexpected token error.\n\n  pp.unexpected = function(pos) {\n    this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n  };\n\n  function DestructuringErrors() {\n    this.shorthandAssign =\n    this.trailingComma =\n    this.parenthesizedAssign =\n    this.parenthesizedBind =\n    this.doubleProto =\n      -1;\n  }\n\n  pp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n    if (!refDestructuringErrors) { return }\n    if (refDestructuringErrors.trailingComma > -1)\n      { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n    var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n    if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n  };\n\n  pp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n    if (!refDestructuringErrors) { return false }\n    var shorthandAssign = refDestructuringErrors.shorthandAssign;\n    var doubleProto = refDestructuringErrors.doubleProto;\n    if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n    if (shorthandAssign >= 0)\n      { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n    if (doubleProto >= 0)\n      { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n  };\n\n  pp.checkYieldAwaitInDefaultParams = function() {\n    if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n      { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n    if (this.awaitPos)\n      { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n  };\n\n  pp.isSimpleAssignTarget = function(expr) {\n    if (expr.type === \"ParenthesizedExpression\")\n      { return this.isSimpleAssignTarget(expr.expression) }\n    return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n  };\n\n  var pp$1 = Parser.prototype;\n\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  pp$1.parseTopLevel = function(node) {\n    var exports = {};\n    if (!node.body) { node.body = []; }\n    while (this.type !== types.eof) {\n      var stmt = this.parseStatement(null, true, exports);\n      node.body.push(stmt);\n    }\n    if (this.inModule)\n      { for (var i = 0, list = Object.keys(this.undefinedExports); i < list.length; i += 1)\n        {\n          var name = list[i];\n\n          this.raiseRecoverable(this.undefinedExports[name].start, (\"Export '\" + name + \"' is not defined\"));\n        } }\n    this.adaptDirectivePrologue(node.body);\n    this.next();\n    node.sourceType = this.options.sourceType;\n    return this.finishNode(node, \"Program\")\n  };\n\n  var loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"};\n\n  pp$1.isLet = function(context) {\n    if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n    // For ambiguous cases, determine if a LexicalDeclaration (or only a\n    // Statement) is allowed here. If context is not empty then only a Statement\n    // is allowed. However, `let [` is an explicit negative lookahead for\n    // ExpressionStatement, so special-case it first.\n    if (nextCh === 91) { return true } // '['\n    if (context) { return false }\n\n    if (nextCh === 123) { return true } // '{'\n    if (isIdentifierStart(nextCh, true)) {\n      var pos = next + 1;\n      while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n      var ident = this.input.slice(next, pos);\n      if (!keywordRelationalOperator.test(ident)) { return true }\n    }\n    return false\n  };\n\n  // check 'async [no LineTerminator here] function'\n  // - 'async /*foo*/ function' is OK.\n  // - 'async /*\\n*/ function' is invalid.\n  pp$1.isAsyncFunction = function() {\n    if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n      { return false }\n\n    skipWhiteSpace.lastIndex = this.pos;\n    var skip = skipWhiteSpace.exec(this.input);\n    var next = this.pos + skip[0].length;\n    return !lineBreak.test(this.input.slice(this.pos, next)) &&\n      this.input.slice(next, next + 8) === \"function\" &&\n      (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n  };\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n\n  pp$1.parseStatement = function(context, topLevel, exports) {\n    var starttype = this.type, node = this.startNode(), kind;\n\n    if (this.isLet(context)) {\n      starttype = types._var;\n      kind = \"let\";\n    }\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n    case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n    case types._debugger: return this.parseDebuggerStatement(node)\n    case types._do: return this.parseDoStatement(node)\n    case types._for: return this.parseForStatement(node)\n    case types._function:\n      // Function as sole body of either an if statement or a labeled statement\n      // works, but not when it is part of a labeled statement that is the sole\n      // body of an if statement.\n      if ((context && (this.strict || context !== \"if\" && context !== \"label\")) && this.options.ecmaVersion >= 6) { this.unexpected(); }\n      return this.parseFunctionStatement(node, false, !context)\n    case types._class:\n      if (context) { this.unexpected(); }\n      return this.parseClass(node, true)\n    case types._if: return this.parseIfStatement(node)\n    case types._return: return this.parseReturnStatement(node)\n    case types._switch: return this.parseSwitchStatement(node)\n    case types._throw: return this.parseThrowStatement(node)\n    case types._try: return this.parseTryStatement(node)\n    case types._const: case types._var:\n      kind = kind || this.value;\n      if (context && kind !== \"var\") { this.unexpected(); }\n      return this.parseVarStatement(node, kind)\n    case types._while: return this.parseWhileStatement(node)\n    case types._with: return this.parseWithStatement(node)\n    case types.braceL: return this.parseBlock(true, node)\n    case types.semi: return this.parseEmptyStatement(node)\n    case types._export:\n    case types._import:\n      if (this.options.ecmaVersion > 10 && starttype === types._import) {\n        skipWhiteSpace.lastIndex = this.pos;\n        var skip = skipWhiteSpace.exec(this.input);\n        var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n        if (nextCh === 40) // '('\n          { return this.parseExpressionStatement(node, this.parseExpression()) }\n      }\n\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel)\n          { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n        if (!this.inModule)\n          { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n      }\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n      // If the statement does not start with a statement keyword or a\n      // brace, it's an ExpressionStatement or LabeledStatement. We\n      // simply start parsing an expression, and afterwards, if the\n      // next token is a colon and the expression was a simple\n      // Identifier node, we switch to interpreting it as a label.\n    default:\n      if (this.isAsyncFunction()) {\n        if (context) { this.unexpected(); }\n        this.next();\n        return this.parseFunctionStatement(node, true, !context)\n      }\n\n      var maybeName = this.value, expr = this.parseExpression();\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n        { return this.parseLabeledStatement(node, maybeName, expr, context) }\n      else { return this.parseExpressionStatement(node, expr) }\n    }\n  };\n\n  pp$1.parseBreakContinueStatement = function(node, keyword) {\n    var isBreak = keyword === \"break\";\n    this.next();\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n    else if (this.type !== types.name) { this.unexpected(); }\n    else {\n      node.label = this.parseIdent();\n      this.semicolon();\n    }\n\n    // Verify that there is an actual destination to break or\n    // continue to.\n    var i = 0;\n    for (; i < this.labels.length; ++i) {\n      var lab = this.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n        if (node.label && isBreak) { break }\n      }\n    }\n    if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n    return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n  };\n\n  pp$1.parseDebuggerStatement = function(node) {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\")\n  };\n\n  pp$1.parseDoStatement = function(node) {\n    this.next();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"do\");\n    this.labels.pop();\n    this.expect(types._while);\n    node.test = this.parseParenExpression();\n    if (this.options.ecmaVersion >= 6)\n      { this.eat(types.semi); }\n    else\n      { this.semicolon(); }\n    return this.finishNode(node, \"DoWhileStatement\")\n  };\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  pp$1.parseForStatement = function(node) {\n    this.next();\n    var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n    this.labels.push(loopLabel);\n    this.enterScope(0);\n    this.expect(types.parenL);\n    if (this.type === types.semi) {\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, null)\n    }\n    var isLet = this.isLet();\n    if (this.type === types._var || this.type === types._const || isLet) {\n      var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n      this.next();\n      this.parseVar(init$1, true, kind);\n      this.finishNode(init$1, \"VariableDeclaration\");\n      if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1) {\n        if (this.options.ecmaVersion >= 9) {\n          if (this.type === types._in) {\n            if (awaitAt > -1) { this.unexpected(awaitAt); }\n          } else { node.await = awaitAt > -1; }\n        }\n        return this.parseForIn(node, init$1)\n      }\n      if (awaitAt > -1) { this.unexpected(awaitAt); }\n      return this.parseFor(node, init$1)\n    }\n    var refDestructuringErrors = new DestructuringErrors;\n    var init = this.parseExpression(true, refDestructuringErrors);\n    if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      this.toAssignable(init, false, refDestructuringErrors);\n      this.checkLVal(init);\n      return this.parseForIn(node, init)\n    } else {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init)\n  };\n\n  pp$1.parseFunctionStatement = function(node, isAsync, declarationPosition) {\n    this.next();\n    return this.parseFunction(node, FUNC_STATEMENT | (declarationPosition ? 0 : FUNC_HANGING_STATEMENT), false, isAsync)\n  };\n\n  pp$1.parseIfStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    // allow function declarations in branches, but only in non-strict mode\n    node.consequent = this.parseStatement(\"if\");\n    node.alternate = this.eat(types._else) ? this.parseStatement(\"if\") : null;\n    return this.finishNode(node, \"IfStatement\")\n  };\n\n  pp$1.parseReturnStatement = function(node) {\n    if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n      { this.raise(this.start, \"'return' outside of function\"); }\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n    else { node.argument = this.parseExpression(); this.semicolon(); }\n    return this.finishNode(node, \"ReturnStatement\")\n  };\n\n  pp$1.parseSwitchStatement = function(node) {\n    this.next();\n    node.discriminant = this.parseParenExpression();\n    node.cases = [];\n    this.expect(types.braceL);\n    this.labels.push(switchLabel);\n    this.enterScope(0);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    var cur;\n    for (var sawDefault = false; this.type !== types.braceR;) {\n      if (this.type === types._case || this.type === types._default) {\n        var isCase = this.type === types._case;\n        if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n        node.cases.push(cur = this.startNode());\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) { this.raiseRecoverable(this.lastTokStart, \"Multiple default clauses\"); }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(types.colon);\n      } else {\n        if (!cur) { this.unexpected(); }\n        cur.consequent.push(this.parseStatement(null));\n      }\n    }\n    this.exitScope();\n    if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n    this.next(); // Closing brace\n    this.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\")\n  };\n\n  pp$1.parseThrowStatement = function(node) {\n    this.next();\n    if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n      { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\")\n  };\n\n  // Reused empty array added for node fields that are always empty.\n\n  var empty = [];\n\n  pp$1.parseTryStatement = function(node) {\n    this.next();\n    node.block = this.parseBlock();\n    node.handler = null;\n    if (this.type === types._catch) {\n      var clause = this.startNode();\n      this.next();\n      if (this.eat(types.parenL)) {\n        clause.param = this.parseBindingAtom();\n        var simple = clause.param.type === \"Identifier\";\n        this.enterScope(simple ? SCOPE_SIMPLE_CATCH : 0);\n        this.checkLVal(clause.param, simple ? BIND_SIMPLE_CATCH : BIND_LEXICAL);\n        this.expect(types.parenR);\n      } else {\n        if (this.options.ecmaVersion < 10) { this.unexpected(); }\n        clause.param = null;\n        this.enterScope(0);\n      }\n      clause.body = this.parseBlock(false);\n      this.exitScope();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n    node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n    if (!node.handler && !node.finalizer)\n      { this.raise(node.start, \"Missing catch or finally clause\"); }\n    return this.finishNode(node, \"TryStatement\")\n  };\n\n  pp$1.parseVarStatement = function(node, kind) {\n    this.next();\n    this.parseVar(node, false, kind);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\")\n  };\n\n  pp$1.parseWhileStatement = function(node) {\n    this.next();\n    node.test = this.parseParenExpression();\n    this.labels.push(loopLabel);\n    node.body = this.parseStatement(\"while\");\n    this.labels.pop();\n    return this.finishNode(node, \"WhileStatement\")\n  };\n\n  pp$1.parseWithStatement = function(node) {\n    if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n    this.next();\n    node.object = this.parseParenExpression();\n    node.body = this.parseStatement(\"with\");\n    return this.finishNode(node, \"WithStatement\")\n  };\n\n  pp$1.parseEmptyStatement = function(node) {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\")\n  };\n\n  pp$1.parseLabeledStatement = function(node, maybeName, expr, context) {\n    for (var i$1 = 0, list = this.labels; i$1 < list.length; i$1 += 1)\n      {\n      var label = list[i$1];\n\n      if (label.name === maybeName)\n        { this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    } }\n    var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n    for (var i = this.labels.length - 1; i >= 0; i--) {\n      var label$1 = this.labels[i];\n      if (label$1.statementStart === node.start) {\n        // Update information about previous labels on this node\n        label$1.statementStart = this.start;\n        label$1.kind = kind;\n      } else { break }\n    }\n    this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n    node.body = this.parseStatement(context ? context.indexOf(\"label\") === -1 ? context + \"label\" : context : \"label\");\n    this.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\")\n  };\n\n  pp$1.parseExpressionStatement = function(node, expr) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\")\n  };\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowStrict` is true (used for\n  // function bodies).\n\n  pp$1.parseBlock = function(createNewLexicalScope, node) {\n    if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n    if ( node === void 0 ) node = this.startNode();\n\n    node.body = [];\n    this.expect(types.braceL);\n    if (createNewLexicalScope) { this.enterScope(0); }\n    while (!this.eat(types.braceR)) {\n      var stmt = this.parseStatement(null);\n      node.body.push(stmt);\n    }\n    if (createNewLexicalScope) { this.exitScope(); }\n    return this.finishNode(node, \"BlockStatement\")\n  };\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  pp$1.parseFor = function(node, init) {\n    node.init = init;\n    this.expect(types.semi);\n    node.test = this.type === types.semi ? null : this.parseExpression();\n    this.expect(types.semi);\n    node.update = this.type === types.parenR ? null : this.parseExpression();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, \"ForStatement\")\n  };\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  pp$1.parseForIn = function(node, init) {\n    var isForIn = this.type === types._in;\n    this.next();\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (\n        !isForIn ||\n        this.options.ecmaVersion < 8 ||\n        this.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\"\n      )\n    ) {\n      this.raise(\n        init.start,\n        ((isForIn ? \"for-in\" : \"for-of\") + \" loop variable declaration may not have an initializer\")\n      );\n    } else if (init.type === \"AssignmentPattern\") {\n      this.raise(init.start, \"Invalid left-hand side in for-loop\");\n    }\n    node.left = init;\n    node.right = isForIn ? this.parseExpression() : this.parseMaybeAssign();\n    this.expect(types.parenR);\n    node.body = this.parseStatement(\"for\");\n    this.exitScope();\n    this.labels.pop();\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\")\n  };\n\n  // Parse a list of variable declarations.\n\n  pp$1.parseVar = function(node, isFor, kind) {\n    node.declarations = [];\n    node.kind = kind;\n    for (;;) {\n      var decl = this.startNode();\n      this.parseVarId(decl, kind);\n      if (this.eat(types.eq)) {\n        decl.init = this.parseMaybeAssign(isFor);\n      } else if (kind === \"const\" && !(this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n        this.unexpected();\n      } else if (decl.id.type !== \"Identifier\" && !(isFor && (this.type === types._in || this.isContextual(\"of\")))) {\n        this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\");\n      } else {\n        decl.init = null;\n      }\n      node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(types.comma)) { break }\n    }\n    return node\n  };\n\n  pp$1.parseVarId = function(decl, kind) {\n    decl.id = this.parseBindingAtom();\n    this.checkLVal(decl.id, kind === \"var\" ? BIND_VAR : BIND_LEXICAL, false);\n  };\n\n  var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;\n\n  // Parse a function declaration or literal (depending on the\n  // `statement & FUNC_STATEMENT`).\n\n  // Remove `allowExpressionBody` for 7.0.0, as it is only called with false\n  pp$1.parseFunction = function(node, statement, allowExpressionBody, isAsync) {\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n      if (this.type === types.star && (statement & FUNC_HANGING_STATEMENT))\n        { this.unexpected(); }\n      node.generator = this.eat(types.star);\n    }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    if (statement & FUNC_STATEMENT) {\n      node.id = (statement & FUNC_NULLABLE_ID) && this.type !== types.name ? null : this.parseIdent();\n      if (node.id && !(statement & FUNC_HANGING_STATEMENT))\n        // If it is a regular function declaration in sloppy mode, then it is\n        // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n        // mode depends on properties of the current scope (see\n        // treatFunctionsAsVar).\n        { this.checkLVal(node.id, (this.strict || node.generator || node.async) ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION); }\n    }\n\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(node.async, node.generator));\n\n    if (!(statement & FUNC_STATEMENT))\n      { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n    this.parseFunctionParams(node);\n    this.parseFunctionBody(node, allowExpressionBody, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, (statement & FUNC_STATEMENT) ? \"FunctionDeclaration\" : \"FunctionExpression\")\n  };\n\n  pp$1.parseFunctionParams = function(node) {\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n  };\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  pp$1.parseClass = function(node, isStatement) {\n    this.next();\n\n    // ecma-262 14.6 Class Definitions\n    // A class definition is always strict mode code.\n    var oldStrict = this.strict;\n    this.strict = true;\n\n    this.parseClassId(node, isStatement);\n    this.parseClassSuper(node);\n    var classBody = this.startNode();\n    var hadConstructor = false;\n    classBody.body = [];\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      var element = this.parseClassElement(node.superClass !== null);\n      if (element) {\n        classBody.body.push(element);\n        if (element.type === \"MethodDefinition\" && element.kind === \"constructor\") {\n          if (hadConstructor) { this.raise(element.start, \"Duplicate constructor in the same class\"); }\n          hadConstructor = true;\n        }\n      }\n    }\n    node.body = this.finishNode(classBody, \"ClassBody\");\n    this.strict = oldStrict;\n    return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n  };\n\n  pp$1.parseClassElement = function(constructorAllowsSuper) {\n    var this$1 = this;\n\n    if (this.eat(types.semi)) { return null }\n\n    var method = this.startNode();\n    var tryContextual = function (k, noLineBreak) {\n      if ( noLineBreak === void 0 ) noLineBreak = false;\n\n      var start = this$1.start, startLoc = this$1.startLoc;\n      if (!this$1.eatContextual(k)) { return false }\n      if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n      if (method.key) { this$1.unexpected(); }\n      method.computed = false;\n      method.key = this$1.startNodeAt(start, startLoc);\n      method.key.name = k;\n      this$1.finishNode(method.key, \"Identifier\");\n      return false\n    };\n\n    method.kind = \"method\";\n    method.static = tryContextual(\"static\");\n    var isGenerator = this.eat(types.star);\n    var isAsync = false;\n    if (!isGenerator) {\n      if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n        isAsync = true;\n        isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      } else if (tryContextual(\"get\")) {\n        method.kind = \"get\";\n      } else if (tryContextual(\"set\")) {\n        method.kind = \"set\";\n      }\n    }\n    if (!method.key) { this.parsePropertyName(method); }\n    var key = method.key;\n    var allowsDirectSuper = false;\n    if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n        key.type === \"Literal\" && key.value === \"constructor\")) {\n      if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n      if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n      if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n      method.kind = \"constructor\";\n      allowsDirectSuper = constructorAllowsSuper;\n    } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n      this.raise(key.start, \"Classes may not have a static property named prototype\");\n    }\n    this.parseClassMethod(method, isGenerator, isAsync, allowsDirectSuper);\n    if (method.kind === \"get\" && method.value.params.length !== 0)\n      { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n    if (method.kind === \"set\" && method.value.params.length !== 1)\n      { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n    if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n      { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n    return method\n  };\n\n  pp$1.parseClassMethod = function(method, isGenerator, isAsync, allowsDirectSuper) {\n    method.value = this.parseMethod(isGenerator, isAsync, allowsDirectSuper);\n    return this.finishNode(method, \"MethodDefinition\")\n  };\n\n  pp$1.parseClassId = function(node, isStatement) {\n    if (this.type === types.name) {\n      node.id = this.parseIdent();\n      if (isStatement)\n        { this.checkLVal(node.id, BIND_LEXICAL, false); }\n    } else {\n      if (isStatement === true)\n        { this.unexpected(); }\n      node.id = null;\n    }\n  };\n\n  pp$1.parseClassSuper = function(node) {\n    node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n  };\n\n  // Parses module export declaration.\n\n  pp$1.parseExport = function(node, exports) {\n    this.next();\n    // export * from '...'\n    if (this.eat(types.star)) {\n      this.expectContextual(\"from\");\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n      this.semicolon();\n      return this.finishNode(node, \"ExportAllDeclaration\")\n    }\n    if (this.eat(types._default)) { // export default ...\n      this.checkExport(exports, \"default\", this.lastTokStart);\n      var isAsync;\n      if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n        var fNode = this.startNode();\n        this.next();\n        if (isAsync) { this.next(); }\n        node.declaration = this.parseFunction(fNode, FUNC_STATEMENT | FUNC_NULLABLE_ID, false, isAsync);\n      } else if (this.type === types._class) {\n        var cNode = this.startNode();\n        node.declaration = this.parseClass(cNode, \"nullableID\");\n      } else {\n        node.declaration = this.parseMaybeAssign();\n        this.semicolon();\n      }\n      return this.finishNode(node, \"ExportDefaultDeclaration\")\n    }\n    // export var|const|let|function|class ...\n    if (this.shouldParseExportStatement()) {\n      node.declaration = this.parseStatement(null);\n      if (node.declaration.type === \"VariableDeclaration\")\n        { this.checkVariableExport(exports, node.declaration.declarations); }\n      else\n        { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n      node.specifiers = [];\n      node.source = null;\n    } else { // export { x, y as z } [from '...']\n      node.declaration = null;\n      node.specifiers = this.parseExportSpecifiers(exports);\n      if (this.eatContextual(\"from\")) {\n        if (this.type !== types.string) { this.unexpected(); }\n        node.source = this.parseExprAtom();\n      } else {\n        for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n          // check for keywords used as local names\n          var spec = list[i];\n\n          this.checkUnreserved(spec.local);\n          // check if export is defined\n          this.checkLocalExport(spec.local);\n        }\n\n        node.source = null;\n      }\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportNamedDeclaration\")\n  };\n\n  pp$1.checkExport = function(exports, name, pos) {\n    if (!exports) { return }\n    if (has(exports, name))\n      { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n    exports[name] = true;\n  };\n\n  pp$1.checkPatternExport = function(exports, pat) {\n    var type = pat.type;\n    if (type === \"Identifier\")\n      { this.checkExport(exports, pat.name, pat.start); }\n    else if (type === \"ObjectPattern\")\n      { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n        {\n          var prop = list[i];\n\n          this.checkPatternExport(exports, prop);\n        } }\n    else if (type === \"ArrayPattern\")\n      { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n        var elt = list$1[i$1];\n\n          if (elt) { this.checkPatternExport(exports, elt); }\n      } }\n    else if (type === \"Property\")\n      { this.checkPatternExport(exports, pat.value); }\n    else if (type === \"AssignmentPattern\")\n      { this.checkPatternExport(exports, pat.left); }\n    else if (type === \"RestElement\")\n      { this.checkPatternExport(exports, pat.argument); }\n    else if (type === \"ParenthesizedExpression\")\n      { this.checkPatternExport(exports, pat.expression); }\n  };\n\n  pp$1.checkVariableExport = function(exports, decls) {\n    if (!exports) { return }\n    for (var i = 0, list = decls; i < list.length; i += 1)\n      {\n      var decl = list[i];\n\n      this.checkPatternExport(exports, decl.id);\n    }\n  };\n\n  pp$1.shouldParseExportStatement = function() {\n    return this.type.keyword === \"var\" ||\n      this.type.keyword === \"const\" ||\n      this.type.keyword === \"class\" ||\n      this.type.keyword === \"function\" ||\n      this.isLet() ||\n      this.isAsyncFunction()\n  };\n\n  // Parses a comma-separated list of module exports.\n\n  pp$1.parseExportSpecifiers = function(exports) {\n    var nodes = [], first = true;\n    // export { x, y as z } [from '...']\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node = this.startNode();\n      node.local = this.parseIdent(true);\n      node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local;\n      this.checkExport(exports, node.exported.name, node.exported.start);\n      nodes.push(this.finishNode(node, \"ExportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Parses import declaration.\n\n  pp$1.parseImport = function(node) {\n    this.next();\n    // import '...'\n    if (this.type === types.string) {\n      node.specifiers = empty;\n      node.source = this.parseExprAtom();\n    } else {\n      node.specifiers = this.parseImportSpecifiers();\n      this.expectContextual(\"from\");\n      node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n    }\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\")\n  };\n\n  // Parses a comma-separated list of module imports.\n\n  pp$1.parseImportSpecifiers = function() {\n    var nodes = [], first = true;\n    if (this.type === types.name) {\n      // import defaultObj, { x, y as z } from '...'\n      var node = this.startNode();\n      node.local = this.parseIdent();\n      this.checkLVal(node.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n      if (!this.eat(types.comma)) { return nodes }\n    }\n    if (this.type === types.star) {\n      var node$1 = this.startNode();\n      this.next();\n      this.expectContextual(\"as\");\n      node$1.local = this.parseIdent();\n      this.checkLVal(node$1.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n      return nodes\n    }\n    this.expect(types.braceL);\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var node$2 = this.startNode();\n      node$2.imported = this.parseIdent(true);\n      if (this.eatContextual(\"as\")) {\n        node$2.local = this.parseIdent();\n      } else {\n        this.checkUnreserved(node$2.imported);\n        node$2.local = node$2.imported;\n      }\n      this.checkLVal(node$2.local, BIND_LEXICAL);\n      nodes.push(this.finishNode(node$2, \"ImportSpecifier\"));\n    }\n    return nodes\n  };\n\n  // Set `ExpressionStatement#directive` property for directive prologues.\n  pp$1.adaptDirectivePrologue = function(statements) {\n    for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n      statements[i].directive = statements[i].expression.raw.slice(1, -1);\n    }\n  };\n  pp$1.isDirectiveCandidate = function(statement) {\n    return (\n      statement.type === \"ExpressionStatement\" &&\n      statement.expression.type === \"Literal\" &&\n      typeof statement.expression.value === \"string\" &&\n      // Reject parenthesized strings.\n      (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n    )\n  };\n\n  var pp$2 = Parser.prototype;\n\n  // Convert existing expression atom to assignable pattern\n  // if possible.\n\n  pp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 6 && node) {\n      switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\")\n          { this.raise(node.start, \"Cannot use 'await' as identifier inside an async function\"); }\n        break\n\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"RestElement\":\n        break\n\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n\n        this.toAssignable(prop, isBinding);\n          // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n          if (\n            prop.type === \"RestElement\" &&\n            (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n          ) {\n            this.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n        break\n\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n        this.toAssignable(node.value, isBinding);\n        break\n\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n        this.toAssignableList(node.elements, isBinding);\n        break\n\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n        if (node.argument.type === \"AssignmentPattern\")\n          { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n        break\n\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n        // falls through to AssignmentPattern\n\n      case \"AssignmentPattern\":\n        break\n\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding, refDestructuringErrors);\n        break\n\n      case \"MemberExpression\":\n        if (!isBinding) { break }\n\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n      }\n    } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n    return node\n  };\n\n  // Convert list of expression atoms to binding list.\n\n  pp$2.toAssignableList = function(exprList, isBinding) {\n    var end = exprList.length;\n    for (var i = 0; i < end; i++) {\n      var elt = exprList[i];\n      if (elt) { this.toAssignable(elt, isBinding); }\n    }\n    if (end) {\n      var last = exprList[end - 1];\n      if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n        { this.unexpected(last.argument.start); }\n    }\n    return exprList\n  };\n\n  // Parses spread element.\n\n  pp$2.parseSpread = function(refDestructuringErrors) {\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    return this.finishNode(node, \"SpreadElement\")\n  };\n\n  pp$2.parseRestBinding = function() {\n    var node = this.startNode();\n    this.next();\n\n    // RestElement inside of a function parameter must be an identifier\n    if (this.options.ecmaVersion === 6 && this.type !== types.name)\n      { this.unexpected(); }\n\n    node.argument = this.parseBindingAtom();\n\n    return this.finishNode(node, \"RestElement\")\n  };\n\n  // Parses lvalue (assignable) atom.\n\n  pp$2.parseBindingAtom = function() {\n    if (this.options.ecmaVersion >= 6) {\n      switch (this.type) {\n      case types.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\")\n\n      case types.braceL:\n        return this.parseObj(true)\n      }\n    }\n    return this.parseIdent()\n  };\n\n  pp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (first) { first = false; }\n      else { this.expect(types.comma); }\n      if (allowEmpty && this.type === types.comma) {\n        elts.push(null);\n      } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n        break\n      } else if (this.type === types.ellipsis) {\n        var rest = this.parseRestBinding();\n        this.parseBindingListItem(rest);\n        elts.push(rest);\n        if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n        this.expect(close);\n        break\n      } else {\n        var elem = this.parseMaybeDefault(this.start, this.startLoc);\n        this.parseBindingListItem(elem);\n        elts.push(elem);\n      }\n    }\n    return elts\n  };\n\n  pp$2.parseBindingListItem = function(param) {\n    return param\n  };\n\n  // Parses assignment pattern around given atom if possible.\n\n  pp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n    left = left || this.parseBindingAtom();\n    if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.right = this.parseMaybeAssign();\n    return this.finishNode(node, \"AssignmentPattern\")\n  };\n\n  // Verify that a node is an lval — something that can be assigned\n  // to.\n  // bindingType can be either:\n  // 'var' indicating that the lval creates a 'var' binding\n  // 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n  // 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\n  pp$2.checkLVal = function(expr, bindingType, checkClashes) {\n    if ( bindingType === void 0 ) bindingType = BIND_NONE;\n\n    switch (expr.type) {\n    case \"Identifier\":\n      if (bindingType === BIND_LEXICAL && expr.name === \"let\")\n        { this.raiseRecoverable(expr.start, \"let is disallowed as a lexically bound name\"); }\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n        { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n      if (checkClashes) {\n        if (has(checkClashes, expr.name))\n          { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n        checkClashes[expr.name] = true;\n      }\n      if (bindingType !== BIND_NONE && bindingType !== BIND_OUTSIDE) { this.declareName(expr.name, bindingType, expr.start); }\n      break\n\n    case \"MemberExpression\":\n      if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n      break\n\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1)\n        {\n      var prop = list[i];\n\n      this.checkLVal(prop, bindingType, checkClashes);\n    }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLVal(expr.value, bindingType, checkClashes);\n      break\n\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n\n      if (elem) { this.checkLVal(elem, bindingType, checkClashes); }\n      }\n      break\n\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, bindingType, checkClashes);\n      break\n\n    case \"RestElement\":\n      this.checkLVal(expr.argument, bindingType, checkClashes);\n      break\n\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, bindingType, checkClashes);\n      break\n\n    default:\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n    }\n  };\n\n  // A recursive descent parser operates by defining functions for all\n\n  var pp$3 = Parser.prototype;\n\n  // Check if property name clashes with already added.\n  // Object/class getters and setters are not allowed to clash —\n  // either with each other or with an init property — and in\n  // strict mode, init properties are also not allowed to be repeated.\n\n  pp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n    if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n      { return }\n    if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n      { return }\n    var key = prop.key;\n    var name;\n    switch (key.type) {\n    case \"Identifier\": name = key.name; break\n    case \"Literal\": name = String(key.value); break\n    default: return\n    }\n    var kind = prop.kind;\n    if (this.options.ecmaVersion >= 6) {\n      if (name === \"__proto__\" && kind === \"init\") {\n        if (propHash.proto) {\n          if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n          // Backwards-compat kludge. Can be removed in version 6.0\n          else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n        }\n        propHash.proto = true;\n      }\n      return\n    }\n    name = \"$\" + name;\n    var other = propHash[name];\n    if (other) {\n      var redefinition;\n      if (kind === \"init\") {\n        redefinition = this.strict && other.init || other.get || other.set;\n      } else {\n        redefinition = other.init || other[kind];\n      }\n      if (redefinition)\n        { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n    } else {\n      other = propHash[name] = {\n        init: false,\n        get: false,\n        set: false\n      };\n    }\n    other[kind] = true;\n  };\n\n  // ### Expression parsing\n\n  // These nest, from the most general expression type at the top to\n  // 'atomic', nondivisible expression types at the bottom. Most of\n  // the functions will simply let the function(s) below them parse,\n  // and, *if* the syntactic construct they handle is present, wrap\n  // the AST node that the inner parser gave them in another node.\n\n  // Parse a full expression. The optional arguments are used to\n  // forbid the `in` operator (in for loops initalization expressions)\n  // and provide reference for storing '=' operator inside shorthand\n  // property assignment in contexts where both object expression\n  // and object pattern might appear (so it's possible to raise\n  // delayed syntax error at correct position).\n\n  pp$3.parseExpression = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n    if (this.type === types.comma) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.expressions = [expr];\n      while (this.eat(types.comma)) { node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors)); }\n      return this.finishNode(node, \"SequenceExpression\")\n    }\n    return expr\n  };\n\n  // Parse an assignment expression. This includes applications of\n  // operators like `+=`.\n\n  pp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n    if (this.isContextual(\"yield\")) {\n      if (this.inGenerator) { return this.parseYield(noIn) }\n      // The tokenizer will assume an expression is allowed after\n      // `yield`, but this isn't that kind of yield\n      else { this.exprAllowed = false; }\n    }\n\n    var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1, oldShorthandAssign = -1;\n    if (refDestructuringErrors) {\n      oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n      oldTrailingComma = refDestructuringErrors.trailingComma;\n      oldShorthandAssign = refDestructuringErrors.shorthandAssign;\n      refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = refDestructuringErrors.shorthandAssign = -1;\n    } else {\n      refDestructuringErrors = new DestructuringErrors;\n      ownDestructuringErrors = true;\n    }\n\n    var startPos = this.start, startLoc = this.startLoc;\n    if (this.type === types.parenL || this.type === types.name)\n      { this.potentialArrowAt = this.start; }\n    var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n    if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n    if (this.type.isAssign) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.operator = this.value;\n      node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n      if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n      refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n      this.checkLVal(left);\n      this.next();\n      node.right = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"AssignmentExpression\")\n    } else {\n      if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n    }\n    if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n    if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n    if (oldShorthandAssign > -1) { refDestructuringErrors.shorthandAssign = oldShorthandAssign; }\n    return left\n  };\n\n  // Parse a ternary conditional (`?:`) operator.\n\n  pp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprOps(noIn, refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    if (this.eat(types.question)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.test = expr;\n      node.consequent = this.parseMaybeAssign();\n      this.expect(types.colon);\n      node.alternate = this.parseMaybeAssign(noIn);\n      return this.finishNode(node, \"ConditionalExpression\")\n    }\n    return expr\n  };\n\n  // Start the precedence parser.\n\n  pp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n  };\n\n  // Parse binary operators with the operator precedence parsing\n  // algorithm. `left` is the left-hand side of the operator.\n  // `minPrec` provides context that allows the function to stop and\n  // defer further parser to one of its callers when it encounters an\n  // operator that has a lower precedence than the set it is parsing.\n\n  pp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n    var prec = this.type.binop;\n    if (prec != null && (!noIn || this.type !== types._in)) {\n      if (prec > minPrec) {\n        var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n        var op = this.value;\n        this.next();\n        var startPos = this.start, startLoc = this.startLoc;\n        var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n        var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n        return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n      }\n    }\n    return left\n  };\n\n  pp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.left = left;\n    node.operator = op;\n    node.right = right;\n    return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n  };\n\n  // Parse unary operators, both prefix and postfix.\n\n  pp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n    var startPos = this.start, startLoc = this.startLoc, expr;\n    if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n      expr = this.parseAwait();\n      sawUnary = true;\n    } else if (this.type.prefix) {\n      var node = this.startNode(), update = this.type === types.incDec;\n      node.operator = this.value;\n      node.prefix = true;\n      this.next();\n      node.argument = this.parseMaybeUnary(null, true);\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      if (update) { this.checkLVal(node.argument); }\n      else if (this.strict && node.operator === \"delete\" &&\n               node.argument.type === \"Identifier\")\n        { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n      else { sawUnary = true; }\n      expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n    } else {\n      expr = this.parseExprSubscripts(refDestructuringErrors);\n      if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n      while (this.type.postfix && !this.canInsertSemicolon()) {\n        var node$1 = this.startNodeAt(startPos, startLoc);\n        node$1.operator = this.value;\n        node$1.prefix = false;\n        node$1.argument = expr;\n        this.checkLVal(expr);\n        this.next();\n        expr = this.finishNode(node$1, \"UpdateExpression\");\n      }\n    }\n\n    if (!sawUnary && this.eat(types.starstar))\n      { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n    else\n      { return expr }\n  };\n\n  // Parse call, dot, and `[]`-subscript expressions.\n\n  pp$3.parseExprSubscripts = function(refDestructuringErrors) {\n    var startPos = this.start, startLoc = this.startLoc;\n    var expr = this.parseExprAtom(refDestructuringErrors);\n    var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n    if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n    var result = this.parseSubscripts(expr, startPos, startLoc);\n    if (refDestructuringErrors && result.type === \"MemberExpression\") {\n      if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n      if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n    }\n    return result\n  };\n\n  pp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n    var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n        this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n    while (true) {\n      var element = this.parseSubscript(base, startPos, startLoc, noCalls, maybeAsyncArrow);\n      if (element === base || element.type === \"ArrowFunctionExpression\") { return element }\n      base = element;\n    }\n  };\n\n  pp$3.parseSubscript = function(base, startPos, startLoc, noCalls, maybeAsyncArrow) {\n    var computed = this.eat(types.bracketL);\n    if (computed || this.eat(types.dot)) {\n      var node = this.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this.parseExpression() : this.parseIdent(this.options.allowReserved !== \"never\");\n      node.computed = !!computed;\n      if (computed) { this.expect(types.bracketR); }\n      base = this.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      this.awaitIdentPos = 0;\n      var exprList = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        if (this.awaitIdentPos > 0)\n          { this.raise(this.awaitIdentPos, \"Cannot use 'await' as identifier inside an async function\"); }\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        this.awaitIdentPos = oldAwaitIdentPos;\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n      this.awaitIdentPos = oldAwaitIdentPos || this.awaitIdentPos;\n      var node$1 = this.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this.finishNode(node$1, \"CallExpression\");\n    } else if (this.type === types.backQuote) {\n      var node$2 = this.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this.parseTemplate({isTagged: true});\n      base = this.finishNode(node$2, \"TaggedTemplateExpression\");\n    }\n    return base\n  };\n\n  // Parse an atomic expression — either a single token that is an\n  // expression, an expression started by a keyword like `function` or\n  // `new`, or an expression wrapped in punctuation like `()`, `[]`,\n  // or `{}`.\n\n  pp$3.parseExprAtom = function(refDestructuringErrors) {\n    // If a division operator appears in an expression position, the\n    // tokenizer got confused, and we force it to read a regexp instead.\n    if (this.type === types.slash) { this.readRegexp(); }\n\n    var node, canBeArrow = this.potentialArrowAt === this.start;\n    switch (this.type) {\n    case types._super:\n      if (!this.allowSuper)\n        { this.raise(this.start, \"'super' keyword outside a method\"); }\n      node = this.startNode();\n      this.next();\n      if (this.type === types.parenL && !this.allowDirectSuper)\n        { this.raise(node.start, \"super() call outside constructor of a subclass\"); }\n      // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super ( Arguments )\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n        { this.unexpected(); }\n      return this.finishNode(node, \"Super\")\n\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\")\n\n    case types.name:\n      var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n      var id = this.parseIdent(false);\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n        { return this.parseFunction(this.startNodeAt(startPos, startLoc), 0, false, true) }\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types.arrow))\n          { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n          id = this.parseIdent(false);\n          if (this.canInsertSemicolon() || !this.eat(types.arrow))\n            { this.unexpected(); }\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n        }\n      }\n      return id\n\n    case types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {pattern: value.pattern, flags: value.flags};\n      return node\n\n    case types.num: case types.string:\n      return this.parseLiteral(this.value)\n\n    case types._null: case types._true: case types._false:\n      node = this.startNode();\n      node.value = this.type === types._null ? null : this.type === types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\")\n\n    case types.parenL:\n      var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n          { refDestructuringErrors.parenthesizedAssign = start; }\n        if (refDestructuringErrors.parenthesizedBind < 0)\n          { refDestructuringErrors.parenthesizedBind = start; }\n      }\n      return expr\n\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\")\n\n    case types.braceL:\n      return this.parseObj(false, refDestructuringErrors)\n\n    case types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, 0)\n\n    case types._class:\n      return this.parseClass(this.startNode(), false)\n\n    case types._new:\n      return this.parseNew()\n\n    case types.backQuote:\n      return this.parseTemplate()\n\n    case types._import:\n      if (this.options.ecmaVersion >= 11) {\n        return this.parseExprImport()\n      } else {\n        return this.unexpected()\n      }\n\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$3.parseExprImport = function() {\n    var node = this.startNode();\n    this.next(); // skip `import`\n    switch (this.type) {\n    case types.parenL:\n      return this.parseDynamicImport(node)\n    default:\n      this.unexpected();\n    }\n  };\n\n  pp$3.parseDynamicImport = function(node) {\n    this.next(); // skip `(`\n\n    // Parse node.source.\n    node.source = this.parseMaybeAssign();\n\n    // Verify ending.\n    if (!this.eat(types.parenR)) {\n      var errorPos = this.start;\n      if (this.eat(types.comma) && this.eat(types.parenR)) {\n        this.raiseRecoverable(errorPos, \"Trailing comma is not allowed in import()\");\n      } else {\n        this.unexpected(errorPos);\n      }\n    }\n\n    return this.finishNode(node, \"ImportExpression\")\n  };\n\n  pp$3.parseLiteral = function(value) {\n    var node = this.startNode();\n    node.value = value;\n    node.raw = this.input.slice(this.start, this.end);\n    if (node.raw.charCodeAt(node.raw.length - 1) === 110) { node.bigint = node.raw.slice(0, -1); }\n    this.next();\n    return this.finishNode(node, \"Literal\")\n  };\n\n  pp$3.parseParenExpression = function() {\n    this.expect(types.parenL);\n    var val = this.parseExpression();\n    this.expect(types.parenR);\n    return val\n  };\n\n  pp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n    var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n    if (this.options.ecmaVersion >= 6) {\n      this.next();\n\n      var innerStartPos = this.start, innerStartLoc = this.startLoc;\n      var exprList = [], first = true, lastIsComma = false;\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n      this.yieldPos = 0;\n      this.awaitPos = 0;\n      // Do not save awaitIdentPos to allow checking awaits nested in parameters\n      while (this.type !== types.parenR) {\n        first ? first = false : this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(types.parenR, true)) {\n          lastIsComma = true;\n          break\n        } else if (this.type === types.ellipsis) {\n          spreadStart = this.start;\n          exprList.push(this.parseParenItem(this.parseRestBinding()));\n          if (this.type === types.comma) { this.raise(this.start, \"Comma is not permitted after the rest element\"); }\n          break\n        } else {\n          exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem));\n        }\n      }\n      var innerEndPos = this.start, innerEndLoc = this.startLoc;\n      this.expect(types.parenR);\n\n      if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n        this.checkPatternErrors(refDestructuringErrors, false);\n        this.checkYieldAwaitInDefaultParams();\n        this.yieldPos = oldYieldPos;\n        this.awaitPos = oldAwaitPos;\n        return this.parseParenArrowList(startPos, startLoc, exprList)\n      }\n\n      if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n      if (spreadStart) { this.unexpected(spreadStart); }\n      this.checkExpressionErrors(refDestructuringErrors, true);\n      this.yieldPos = oldYieldPos || this.yieldPos;\n      this.awaitPos = oldAwaitPos || this.awaitPos;\n\n      if (exprList.length > 1) {\n        val = this.startNodeAt(innerStartPos, innerStartLoc);\n        val.expressions = exprList;\n        this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n      } else {\n        val = exprList[0];\n      }\n    } else {\n      val = this.parseParenExpression();\n    }\n\n    if (this.options.preserveParens) {\n      var par = this.startNodeAt(startPos, startLoc);\n      par.expression = val;\n      return this.finishNode(par, \"ParenthesizedExpression\")\n    } else {\n      return val\n    }\n  };\n\n  pp$3.parseParenItem = function(item) {\n    return item\n  };\n\n  pp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n    return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n  };\n\n  // New's precedence is slightly tricky. It must allow its argument to\n  // be a `[]` or dot subscript expression, but not a call — at least,\n  // not without wrapping it in parentheses. Thus, it uses the noCalls\n  // argument to parseSubscripts to prevent it from consuming the\n  // argument list.\n\n  var empty$1 = [];\n\n  pp$3.parseNew = function() {\n    var node = this.startNode();\n    var meta = this.parseIdent(true);\n    if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n      node.meta = meta;\n      var containsEsc = this.containsEsc;\n      node.property = this.parseIdent(true);\n      if (node.property.name !== \"target\" || containsEsc)\n        { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n      if (!this.inNonArrowFunction())\n        { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n      return this.finishNode(node, \"MetaProperty\")\n    }\n    var startPos = this.start, startLoc = this.startLoc, isImport = this.type === types._import;\n    node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n    if (isImport && node.callee.type === \"ImportExpression\") {\n      this.raise(startPos, \"Cannot use new with import()\");\n    }\n    if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n    else { node.arguments = empty$1; }\n    return this.finishNode(node, \"NewExpression\")\n  };\n\n  // Parse template expression.\n\n  pp$3.parseTemplateElement = function(ref) {\n    var isTagged = ref.isTagged;\n\n    var elem = this.startNode();\n    if (this.type === types.invalidTemplate) {\n      if (!isTagged) {\n        this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n      }\n      elem.value = {\n        raw: this.value,\n        cooked: null\n      };\n    } else {\n      elem.value = {\n        raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n        cooked: this.value\n      };\n    }\n    this.next();\n    elem.tail = this.type === types.backQuote;\n    return this.finishNode(elem, \"TemplateElement\")\n  };\n\n  pp$3.parseTemplate = function(ref) {\n    if ( ref === void 0 ) ref = {};\n    var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n    var node = this.startNode();\n    this.next();\n    node.expressions = [];\n    var curElt = this.parseTemplateElement({isTagged: isTagged});\n    node.quasis = [curElt];\n    while (!curElt.tail) {\n      if (this.type === types.eof) { this.raise(this.pos, \"Unterminated template literal\"); }\n      this.expect(types.dollarBraceL);\n      node.expressions.push(this.parseExpression());\n      this.expect(types.braceR);\n      node.quasis.push(curElt = this.parseTemplateElement({isTagged: isTagged}));\n    }\n    this.next();\n    return this.finishNode(node, \"TemplateLiteral\")\n  };\n\n  pp$3.isAsyncProp = function(prop) {\n    return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n      (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n      !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  };\n\n  // Parse an object literal or binding pattern.\n\n  pp$3.parseObj = function(isPattern, refDestructuringErrors) {\n    var node = this.startNode(), first = true, propHash = {};\n    node.properties = [];\n    this.next();\n    while (!this.eat(types.braceR)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (this.options.ecmaVersion >= 5 && this.afterTrailingComma(types.braceR)) { break }\n      } else { first = false; }\n\n      var prop = this.parseProperty(isPattern, refDestructuringErrors);\n      if (!isPattern) { this.checkPropClash(prop, propHash, refDestructuringErrors); }\n      node.properties.push(prop);\n    }\n    return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n  };\n\n  pp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n    var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n    if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n      if (isPattern) {\n        prop.argument = this.parseIdent(false);\n        if (this.type === types.comma) {\n          this.raise(this.start, \"Comma is not permitted after the rest element\");\n        }\n        return this.finishNode(prop, \"RestElement\")\n      }\n      // To disallow parenthesized identifier via `this.toAssignable()`.\n      if (this.type === types.parenL && refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0) {\n          refDestructuringErrors.parenthesizedAssign = this.start;\n        }\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = this.start;\n        }\n      }\n      // Parse argument.\n      prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n      // To disallow trailing comma via `this.toAssignable()`.\n      if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this.start;\n      }\n      // Finish\n      return this.finishNode(prop, \"SpreadElement\")\n    }\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false;\n      prop.shorthand = false;\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start;\n        startLoc = this.startLoc;\n      }\n      if (!isPattern)\n        { isGenerator = this.eat(types.star); }\n    }\n    var containsEsc = this.containsEsc;\n    this.parsePropertyName(prop);\n    if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n      this.parsePropertyName(prop, refDestructuringErrors);\n    } else {\n      isAsync = false;\n    }\n    this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n    return this.finishNode(prop, \"Property\")\n  };\n\n  pp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n    if ((isGenerator || isAsync) && this.type === types.colon)\n      { this.unexpected(); }\n\n    if (this.eat(types.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n      prop.kind = \"init\";\n    } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n      if (isPattern) { this.unexpected(); }\n      prop.kind = \"init\";\n      prop.method = true;\n      prop.value = this.parseMethod(isGenerator, isAsync);\n    } else if (!isPattern && !containsEsc &&\n               this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type !== types.comma && this.type !== types.braceR)) {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      prop.kind = prop.key.name;\n      this.parsePropertyName(prop);\n      prop.value = this.parseMethod(false);\n      var paramCount = prop.kind === \"get\" ? 0 : 1;\n      if (prop.value.params.length !== paramCount) {\n        var start = prop.value.start;\n        if (prop.kind === \"get\")\n          { this.raiseRecoverable(start, \"getter should have no params\"); }\n        else\n          { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n      } else {\n        if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n          { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n      }\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      if (isGenerator || isAsync) { this.unexpected(); }\n      this.checkUnreserved(prop.key);\n      if (prop.key.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = startPos; }\n      prop.kind = \"init\";\n      if (isPattern) {\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else if (this.type === types.eq && refDestructuringErrors) {\n        if (refDestructuringErrors.shorthandAssign < 0)\n          { refDestructuringErrors.shorthandAssign = this.start; }\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n      } else {\n        prop.value = prop.key;\n      }\n      prop.shorthand = true;\n    } else { this.unexpected(); }\n  };\n\n  pp$3.parsePropertyName = function(prop) {\n    if (this.options.ecmaVersion >= 6) {\n      if (this.eat(types.bracketL)) {\n        prop.computed = true;\n        prop.key = this.parseMaybeAssign();\n        this.expect(types.bracketR);\n        return prop.key\n      } else {\n        prop.computed = false;\n      }\n    }\n    return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== \"never\")\n  };\n\n  // Initialize empty function node.\n\n  pp$3.initFunction = function(node) {\n    node.id = null;\n    if (this.options.ecmaVersion >= 6) { node.generator = node.expression = false; }\n    if (this.options.ecmaVersion >= 8) { node.async = false; }\n  };\n\n  // Parse object or class method.\n\n  pp$3.parseMethod = function(isGenerator, isAsync, allowDirectSuper) {\n    var node = this.startNode(), oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 6)\n      { node.generator = isGenerator; }\n    if (this.options.ecmaVersion >= 8)\n      { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n    this.enterScope(functionFlags(isAsync, node.generator) | SCOPE_SUPER | (allowDirectSuper ? SCOPE_DIRECT_SUPER : 0));\n\n    this.expect(types.parenL);\n    node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n    this.checkYieldAwaitInDefaultParams();\n    this.parseFunctionBody(node, false, true);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"FunctionExpression\")\n  };\n\n  // Parse arrow function expression with given parameters.\n\n  pp$3.parseArrowExpression = function(node, params, isAsync) {\n    var oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldAwaitIdentPos = this.awaitIdentPos;\n\n    this.enterScope(functionFlags(isAsync, false) | SCOPE_ARROW);\n    this.initFunction(node);\n    if (this.options.ecmaVersion >= 8) { node.async = !!isAsync; }\n\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    this.awaitIdentPos = 0;\n\n    node.params = this.toAssignableList(params, true);\n    this.parseFunctionBody(node, true, false);\n\n    this.yieldPos = oldYieldPos;\n    this.awaitPos = oldAwaitPos;\n    this.awaitIdentPos = oldAwaitIdentPos;\n    return this.finishNode(node, \"ArrowFunctionExpression\")\n  };\n\n  // Parse function body and check parameters.\n\n  pp$3.parseFunctionBody = function(node, isArrowFunction, isMethod) {\n    var isExpression = isArrowFunction && this.type !== types.braceL;\n    var oldStrict = this.strict, useStrict = false;\n\n    if (isExpression) {\n      node.body = this.parseMaybeAssign();\n      node.expression = true;\n      this.checkParams(node, false);\n    } else {\n      var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n      if (!oldStrict || nonSimple) {\n        useStrict = this.strictDirective(this.end);\n        // If this is a strict mode function, verify that argument names\n        // are not repeated, and it does not try to bind the words `eval`\n        // or `arguments`.\n        if (useStrict && nonSimple)\n          { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n      }\n      // Start a new scope with regard to labels and the `inFunction`\n      // flag (restore them to their old value afterwards).\n      var oldLabels = this.labels;\n      this.labels = [];\n      if (useStrict) { this.strict = true; }\n\n      // Add the params to varDeclaredNames to ensure that an error is thrown\n      // if a let/const declaration in the function clashes with one of the params.\n      this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && !isMethod && this.isSimpleParamList(node.params));\n      node.body = this.parseBlock(false);\n      node.expression = false;\n      this.adaptDirectivePrologue(node.body.body);\n      this.labels = oldLabels;\n    }\n    this.exitScope();\n\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    if (this.strict && node.id) { this.checkLVal(node.id, BIND_OUTSIDE); }\n    this.strict = oldStrict;\n  };\n\n  pp$3.isSimpleParamList = function(params) {\n    for (var i = 0, list = params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      if (param.type !== \"Identifier\") { return false\n    } }\n    return true\n  };\n\n  // Checks function params for various disallowed patterns such as using \"eval\"\n  // or \"arguments\" and duplicate parameters.\n\n  pp$3.checkParams = function(node, allowDuplicates) {\n    var nameHash = {};\n    for (var i = 0, list = node.params; i < list.length; i += 1)\n      {\n      var param = list[i];\n\n      this.checkLVal(param, BIND_VAR, allowDuplicates ? null : nameHash);\n    }\n  };\n\n  // Parses a comma-separated list of expressions, and returns them as\n  // an array. `close` is the token type that ends the list, and\n  // `allowEmpty` can be turned on to allow subsequent commas with\n  // nothing in between them to be parsed as `null` (which is needed\n  // for array literals).\n\n  pp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n    var elts = [], first = true;\n    while (!this.eat(close)) {\n      if (!first) {\n        this.expect(types.comma);\n        if (allowTrailingComma && this.afterTrailingComma(close)) { break }\n      } else { first = false; }\n\n      var elt = (void 0);\n      if (allowEmpty && this.type === types.comma)\n        { elt = null; }\n      else if (this.type === types.ellipsis) {\n        elt = this.parseSpread(refDestructuringErrors);\n        if (refDestructuringErrors && this.type === types.comma && refDestructuringErrors.trailingComma < 0)\n          { refDestructuringErrors.trailingComma = this.start; }\n      } else {\n        elt = this.parseMaybeAssign(false, refDestructuringErrors);\n      }\n      elts.push(elt);\n    }\n    return elts\n  };\n\n  pp$3.checkUnreserved = function(ref) {\n    var start = ref.start;\n    var end = ref.end;\n    var name = ref.name;\n\n    if (this.inGenerator && name === \"yield\")\n      { this.raiseRecoverable(start, \"Cannot use 'yield' as identifier inside a generator\"); }\n    if (this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Cannot use 'await' as identifier inside an async function\"); }\n    if (this.keywords.test(name))\n      { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n    if (this.options.ecmaVersion < 6 &&\n      this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n    var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n    if (re.test(name)) {\n      if (!this.inAsync && name === \"await\")\n        { this.raiseRecoverable(start, \"Cannot use keyword 'await' outside an async function\"); }\n      this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n    }\n  };\n\n  // Parse the next token as an identifier. If `liberal` is true (used\n  // when parsing properties), it will also convert keywords into\n  // identifiers.\n\n  pp$3.parseIdent = function(liberal, isBinding) {\n    var node = this.startNode();\n    if (this.type === types.name) {\n      node.name = this.value;\n    } else if (this.type.keyword) {\n      node.name = this.type.keyword;\n\n      // To fix https://github.com/acornjs/acorn/issues/575\n      // `class` and `function` keywords push new context into this.context.\n      // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n      // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n      if ((node.name === \"class\" || node.name === \"function\") &&\n          (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n        this.context.pop();\n      }\n    } else {\n      this.unexpected();\n    }\n    this.next();\n    this.finishNode(node, \"Identifier\");\n    if (!liberal) {\n      this.checkUnreserved(node);\n      if (node.name === \"await\" && !this.awaitIdentPos)\n        { this.awaitIdentPos = node.start; }\n    }\n    return node\n  };\n\n  // Parses yield expression inside generator.\n\n  pp$3.parseYield = function(noIn) {\n    if (!this.yieldPos) { this.yieldPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n      node.delegate = false;\n      node.argument = null;\n    } else {\n      node.delegate = this.eat(types.star);\n      node.argument = this.parseMaybeAssign(noIn);\n    }\n    return this.finishNode(node, \"YieldExpression\")\n  };\n\n  pp$3.parseAwait = function() {\n    if (!this.awaitPos) { this.awaitPos = this.start; }\n\n    var node = this.startNode();\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    return this.finishNode(node, \"AwaitExpression\")\n  };\n\n  var pp$4 = Parser.prototype;\n\n  // This function is used to raise exceptions on parse errors. It\n  // takes an offset integer (into the current `input`) to indicate\n  // the location of the error, attaches the position to the end\n  // of the error message, and then raises a `SyntaxError` with that\n  // message.\n\n  pp$4.raise = function(pos, message) {\n    var loc = getLineInfo(this.input, pos);\n    message += \" (\" + loc.line + \":\" + loc.column + \")\";\n    var err = new SyntaxError(message);\n    err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n    throw err\n  };\n\n  pp$4.raiseRecoverable = pp$4.raise;\n\n  pp$4.curPosition = function() {\n    if (this.options.locations) {\n      return new Position(this.curLine, this.pos - this.lineStart)\n    }\n  };\n\n  var pp$5 = Parser.prototype;\n\n  var Scope = function Scope(flags) {\n    this.flags = flags;\n    // A list of var-declared names in the current lexical scope\n    this.var = [];\n    // A list of lexically-declared names in the current lexical scope\n    this.lexical = [];\n    // A list of lexically-declared FunctionDeclaration names in the current lexical scope\n    this.functions = [];\n  };\n\n  // The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\n  pp$5.enterScope = function(flags) {\n    this.scopeStack.push(new Scope(flags));\n  };\n\n  pp$5.exitScope = function() {\n    this.scopeStack.pop();\n  };\n\n  // The spec says:\n  // > At the top level of a function, or script, function declarations are\n  // > treated like var declarations rather than like lexical declarations.\n  pp$5.treatFunctionsAsVarInScope = function(scope) {\n    return (scope.flags & SCOPE_FUNCTION) || !this.inModule && (scope.flags & SCOPE_TOP)\n  };\n\n  pp$5.declareName = function(name, bindingType, pos) {\n    var redeclared = false;\n    if (bindingType === BIND_LEXICAL) {\n      var scope = this.currentScope();\n      redeclared = scope.lexical.indexOf(name) > -1 || scope.functions.indexOf(name) > -1 || scope.var.indexOf(name) > -1;\n      scope.lexical.push(name);\n      if (this.inModule && (scope.flags & SCOPE_TOP))\n        { delete this.undefinedExports[name]; }\n    } else if (bindingType === BIND_SIMPLE_CATCH) {\n      var scope$1 = this.currentScope();\n      scope$1.lexical.push(name);\n    } else if (bindingType === BIND_FUNCTION) {\n      var scope$2 = this.currentScope();\n      if (this.treatFunctionsAsVar)\n        { redeclared = scope$2.lexical.indexOf(name) > -1; }\n      else\n        { redeclared = scope$2.lexical.indexOf(name) > -1 || scope$2.var.indexOf(name) > -1; }\n      scope$2.functions.push(name);\n    } else {\n      for (var i = this.scopeStack.length - 1; i >= 0; --i) {\n        var scope$3 = this.scopeStack[i];\n        if (scope$3.lexical.indexOf(name) > -1 && !((scope$3.flags & SCOPE_SIMPLE_CATCH) && scope$3.lexical[0] === name) ||\n            !this.treatFunctionsAsVarInScope(scope$3) && scope$3.functions.indexOf(name) > -1) {\n          redeclared = true;\n          break\n        }\n        scope$3.var.push(name);\n        if (this.inModule && (scope$3.flags & SCOPE_TOP))\n          { delete this.undefinedExports[name]; }\n        if (scope$3.flags & SCOPE_VAR) { break }\n      }\n    }\n    if (redeclared) { this.raiseRecoverable(pos, (\"Identifier '\" + name + \"' has already been declared\")); }\n  };\n\n  pp$5.checkLocalExport = function(id) {\n    // scope.functions must be empty as Module code is always strict.\n    if (this.scopeStack[0].lexical.indexOf(id.name) === -1 &&\n        this.scopeStack[0].var.indexOf(id.name) === -1) {\n      this.undefinedExports[id.name] = id;\n    }\n  };\n\n  pp$5.currentScope = function() {\n    return this.scopeStack[this.scopeStack.length - 1]\n  };\n\n  pp$5.currentVarScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR) { return scope }\n    }\n  };\n\n  // Could be useful for `this`, `new.target`, `super()`, `super.property`, and `super[property]`.\n  pp$5.currentThisScope = function() {\n    for (var i = this.scopeStack.length - 1;; i--) {\n      var scope = this.scopeStack[i];\n      if (scope.flags & SCOPE_VAR && !(scope.flags & SCOPE_ARROW)) { return scope }\n    }\n  };\n\n  var Node = function Node(parser, pos, loc) {\n    this.type = \"\";\n    this.start = pos;\n    this.end = 0;\n    if (parser.options.locations)\n      { this.loc = new SourceLocation(parser, loc); }\n    if (parser.options.directSourceFile)\n      { this.sourceFile = parser.options.directSourceFile; }\n    if (parser.options.ranges)\n      { this.range = [pos, 0]; }\n  };\n\n  // Start an AST node, attaching a start offset.\n\n  var pp$6 = Parser.prototype;\n\n  pp$6.startNode = function() {\n    return new Node(this, this.start, this.startLoc)\n  };\n\n  pp$6.startNodeAt = function(pos, loc) {\n    return new Node(this, pos, loc)\n  };\n\n  // Finish an AST node, adding `type` and `end` properties.\n\n  function finishNodeAt(node, type, pos, loc) {\n    node.type = type;\n    node.end = pos;\n    if (this.options.locations)\n      { node.loc.end = loc; }\n    if (this.options.ranges)\n      { node.range[1] = pos; }\n    return node\n  }\n\n  pp$6.finishNode = function(node, type) {\n    return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n  };\n\n  // Finish node at given position\n\n  pp$6.finishNodeAt = function(node, type, pos, loc) {\n    return finishNodeAt.call(this, node, type, pos, loc)\n  };\n\n  // The algorithm used to determine whether a regexp can appear at a\n\n  var TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n    this.token = token;\n    this.isExpr = !!isExpr;\n    this.preserveSpace = !!preserveSpace;\n    this.override = override;\n    this.generator = !!generator;\n  };\n\n  var types$1 = {\n    b_stat: new TokContext(\"{\", false),\n    b_expr: new TokContext(\"{\", true),\n    b_tmpl: new TokContext(\"${\", false),\n    p_stat: new TokContext(\"(\", false),\n    p_expr: new TokContext(\"(\", true),\n    q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n    f_stat: new TokContext(\"function\", false),\n    f_expr: new TokContext(\"function\", true),\n    f_expr_gen: new TokContext(\"function\", true, false, null, true),\n    f_gen: new TokContext(\"function\", false, false, null, true)\n  };\n\n  var pp$7 = Parser.prototype;\n\n  pp$7.initialContext = function() {\n    return [types$1.b_stat]\n  };\n\n  pp$7.braceIsBlock = function(prevType) {\n    var parent = this.curContext();\n    if (parent === types$1.f_expr || parent === types$1.f_stat)\n      { return true }\n    if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n      { return !parent.isExpr }\n\n    // The check for `tt.name && exprAllowed` detects whether we are\n    // after a `yield` or `of` construct. See the `updateContext` for\n    // `tt.name`.\n    if (prevType === types._return || prevType === types.name && this.exprAllowed)\n      { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n    if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n      { return true }\n    if (prevType === types.braceL)\n      { return parent === types$1.b_stat }\n    if (prevType === types._var || prevType === types._const || prevType === types.name)\n      { return false }\n    return !this.exprAllowed\n  };\n\n  pp$7.inGeneratorContext = function() {\n    for (var i = this.context.length - 1; i >= 1; i--) {\n      var context = this.context[i];\n      if (context.token === \"function\")\n        { return context.generator }\n    }\n    return false\n  };\n\n  pp$7.updateContext = function(prevType) {\n    var update, type = this.type;\n    if (type.keyword && prevType === types.dot)\n      { this.exprAllowed = false; }\n    else if (update = type.updateContext)\n      { update.call(this, prevType); }\n    else\n      { this.exprAllowed = type.beforeExpr; }\n  };\n\n  // Token-specific context update code\n\n  types.parenR.updateContext = types.braceR.updateContext = function() {\n    if (this.context.length === 1) {\n      this.exprAllowed = true;\n      return\n    }\n    var out = this.context.pop();\n    if (out === types$1.b_stat && this.curContext().token === \"function\") {\n      out = this.context.pop();\n    }\n    this.exprAllowed = !out.isExpr;\n  };\n\n  types.braceL.updateContext = function(prevType) {\n    this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n    this.exprAllowed = true;\n  };\n\n  types.dollarBraceL.updateContext = function() {\n    this.context.push(types$1.b_tmpl);\n    this.exprAllowed = true;\n  };\n\n  types.parenL.updateContext = function(prevType) {\n    var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n    this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n    this.exprAllowed = true;\n  };\n\n  types.incDec.updateContext = function() {\n    // tokExprAllowed stays unchanged\n  };\n\n  types._function.updateContext = types._class.updateContext = function(prevType) {\n    if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n        !(prevType === types._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) &&\n        !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n      { this.context.push(types$1.f_expr); }\n    else\n      { this.context.push(types$1.f_stat); }\n    this.exprAllowed = false;\n  };\n\n  types.backQuote.updateContext = function() {\n    if (this.curContext() === types$1.q_tmpl)\n      { this.context.pop(); }\n    else\n      { this.context.push(types$1.q_tmpl); }\n    this.exprAllowed = false;\n  };\n\n  types.star.updateContext = function(prevType) {\n    if (prevType === types._function) {\n      var index = this.context.length - 1;\n      if (this.context[index] === types$1.f_expr)\n        { this.context[index] = types$1.f_expr_gen; }\n      else\n        { this.context[index] = types$1.f_gen; }\n    }\n    this.exprAllowed = true;\n  };\n\n  types.name.updateContext = function(prevType) {\n    var allowed = false;\n    if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n      if (this.value === \"of\" && !this.exprAllowed ||\n          this.value === \"yield\" && this.inGeneratorContext())\n        { allowed = true; }\n    }\n    this.exprAllowed = allowed;\n  };\n\n  // This file contains Unicode properties extracted from the ECMAScript\n  // specification. The lists are extracted like so:\n  // $$('#table-binary-unicode-properties > figure > table > tbody > tr > td:nth-child(1) code').map(el => el.innerText)\n\n  // #table-binary-unicode-properties\n  var ecma9BinaryProperties = \"ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS\";\n  var ecma10BinaryProperties = ecma9BinaryProperties + \" Extended_Pictographic\";\n  var ecma11BinaryProperties = ecma10BinaryProperties;\n  var unicodeBinaryProperties = {\n    9: ecma9BinaryProperties,\n    10: ecma10BinaryProperties,\n    11: ecma11BinaryProperties\n  };\n\n  // #table-unicode-general-category-values\n  var unicodeGeneralCategoryValues = \"Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu\";\n\n  // #table-unicode-script-values\n  var ecma9ScriptValues = \"Adlam Adlm Ahom Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb\";\n  var ecma10ScriptValues = ecma9ScriptValues + \" Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd\";\n  var ecma11ScriptValues = ecma10ScriptValues + \" Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho\";\n  var unicodeScriptValues = {\n    9: ecma9ScriptValues,\n    10: ecma10ScriptValues,\n    11: ecma11ScriptValues\n  };\n\n  var data = {};\n  function buildUnicodeData(ecmaVersion) {\n    var d = data[ecmaVersion] = {\n      binary: wordsRegexp(unicodeBinaryProperties[ecmaVersion] + \" \" + unicodeGeneralCategoryValues),\n      nonBinary: {\n        General_Category: wordsRegexp(unicodeGeneralCategoryValues),\n        Script: wordsRegexp(unicodeScriptValues[ecmaVersion])\n      }\n    };\n    d.nonBinary.Script_Extensions = d.nonBinary.Script;\n\n    d.nonBinary.gc = d.nonBinary.General_Category;\n    d.nonBinary.sc = d.nonBinary.Script;\n    d.nonBinary.scx = d.nonBinary.Script_Extensions;\n  }\n  buildUnicodeData(9);\n  buildUnicodeData(10);\n  buildUnicodeData(11);\n\n  var pp$8 = Parser.prototype;\n\n  var RegExpValidationState = function RegExpValidationState(parser) {\n    this.parser = parser;\n    this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n    this.unicodeProperties = data[parser.options.ecmaVersion >= 11 ? 11 : parser.options.ecmaVersion];\n    this.source = \"\";\n    this.flags = \"\";\n    this.start = 0;\n    this.switchU = false;\n    this.switchN = false;\n    this.pos = 0;\n    this.lastIntValue = 0;\n    this.lastStringValue = \"\";\n    this.lastAssertionIsQuantifiable = false;\n    this.numCapturingParens = 0;\n    this.maxBackReference = 0;\n    this.groupNames = [];\n    this.backReferenceNames = [];\n  };\n\n  RegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n    var unicode = flags.indexOf(\"u\") !== -1;\n    this.start = start | 0;\n    this.source = pattern + \"\";\n    this.flags = flags;\n    this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n    this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n  };\n\n  RegExpValidationState.prototype.raise = function raise (message) {\n    this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n  };\n\n  // If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n  // Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\n  RegExpValidationState.prototype.at = function at (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return -1\n    }\n    var c = s.charCodeAt(i);\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return c\n    }\n    return (c << 10) + s.charCodeAt(i + 1) - 0x35FDC00\n  };\n\n  RegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n    var s = this.source;\n    var l = s.length;\n    if (i >= l) {\n      return l\n    }\n    var c = s.charCodeAt(i);\n    if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n      return i + 1\n    }\n    return i + 2\n  };\n\n  RegExpValidationState.prototype.current = function current () {\n    return this.at(this.pos)\n  };\n\n  RegExpValidationState.prototype.lookahead = function lookahead () {\n    return this.at(this.nextIndex(this.pos))\n  };\n\n  RegExpValidationState.prototype.advance = function advance () {\n    this.pos = this.nextIndex(this.pos);\n  };\n\n  RegExpValidationState.prototype.eat = function eat (ch) {\n    if (this.current() === ch) {\n      this.advance();\n      return true\n    }\n    return false\n  };\n\n  function codePointToString(ch) {\n    if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n    ch -= 0x10000;\n    return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n  }\n\n  /**\n   * Validate the flags part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpFlags = function(state) {\n    var validFlags = state.validFlags;\n    var flags = state.flags;\n\n    for (var i = 0; i < flags.length; i++) {\n      var flag = flags.charAt(i);\n      if (validFlags.indexOf(flag) === -1) {\n        this.raise(state.start, \"Invalid regular expression flag\");\n      }\n      if (flags.indexOf(flag, i + 1) > -1) {\n        this.raise(state.start, \"Duplicate regular expression flag\");\n      }\n    }\n  };\n\n  /**\n   * Validate the pattern part of a given RegExpLiteral.\n   *\n   * @param {RegExpValidationState} state The state to validate RegExp.\n   * @returns {void}\n   */\n  pp$8.validateRegExpPattern = function(state) {\n    this.regexp_pattern(state);\n\n    // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n    // parsing contains a |GroupName|, reparse with the goal symbol\n    // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n    // exception if _P_ did not conform to the grammar, if any elements of _P_\n    // were not matched by the parse, or if any Early Error conditions exist.\n    if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n      state.switchN = true;\n      this.regexp_pattern(state);\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\n  pp$8.regexp_pattern = function(state) {\n    state.pos = 0;\n    state.lastIntValue = 0;\n    state.lastStringValue = \"\";\n    state.lastAssertionIsQuantifiable = false;\n    state.numCapturingParens = 0;\n    state.maxBackReference = 0;\n    state.groupNames.length = 0;\n    state.backReferenceNames.length = 0;\n\n    this.regexp_disjunction(state);\n\n    if (state.pos !== state.source.length) {\n      // Make the same messages as V8.\n      if (state.eat(0x29 /* ) */)) {\n        state.raise(\"Unmatched ')'\");\n      }\n      if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n        state.raise(\"Lone quantifier brackets\");\n      }\n    }\n    if (state.maxBackReference > state.numCapturingParens) {\n      state.raise(\"Invalid escape\");\n    }\n    for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n      var name = list[i];\n\n      if (state.groupNames.indexOf(name) === -1) {\n        state.raise(\"Invalid named capture referenced\");\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\n  pp$8.regexp_disjunction = function(state) {\n    this.regexp_alternative(state);\n    while (state.eat(0x7C /* | */)) {\n      this.regexp_alternative(state);\n    }\n\n    // Make the same message as V8.\n    if (this.regexp_eatQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    if (state.eat(0x7B /* { */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\n  pp$8.regexp_alternative = function(state) {\n    while (state.pos < state.source.length && this.regexp_eatTerm(state))\n      { }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\n  pp$8.regexp_eatTerm = function(state) {\n    if (this.regexp_eatAssertion(state)) {\n      // Handle `QuantifiableAssertion Quantifier` alternative.\n      // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n      // is a QuantifiableAssertion.\n      if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n        // Make the same message as V8.\n        if (state.switchU) {\n          state.raise(\"Invalid quantifier\");\n        }\n      }\n      return true\n    }\n\n    if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n      this.regexp_eatQuantifier(state);\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\n  pp$8.regexp_eatAssertion = function(state) {\n    var start = state.pos;\n    state.lastAssertionIsQuantifiable = false;\n\n    // ^, $\n    if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n      return true\n    }\n\n    // \\b \\B\n    if (state.eat(0x5C /* \\ */)) {\n      if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    // Lookahead / Lookbehind\n    if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n      var lookbehind = false;\n      if (this.options.ecmaVersion >= 9) {\n        lookbehind = state.eat(0x3C /* < */);\n      }\n      if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n        this.regexp_disjunction(state);\n        if (!state.eat(0x29 /* ) */)) {\n          state.raise(\"Unterminated group\");\n        }\n        state.lastAssertionIsQuantifiable = !lookbehind;\n        return true\n      }\n    }\n\n    state.pos = start;\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\n  pp$8.regexp_eatQuantifier = function(state, noError) {\n    if ( noError === void 0 ) noError = false;\n\n    if (this.regexp_eatQuantifierPrefix(state, noError)) {\n      state.eat(0x3F /* ? */);\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\n  pp$8.regexp_eatQuantifierPrefix = function(state, noError) {\n    return (\n      state.eat(0x2A /* * */) ||\n      state.eat(0x2B /* + */) ||\n      state.eat(0x3F /* ? */) ||\n      this.regexp_eatBracedQuantifier(state, noError)\n    )\n  };\n  pp$8.regexp_eatBracedQuantifier = function(state, noError) {\n    var start = state.pos;\n    if (state.eat(0x7B /* { */)) {\n      var min = 0, max = -1;\n      if (this.regexp_eatDecimalDigits(state)) {\n        min = state.lastIntValue;\n        if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n          max = state.lastIntValue;\n        }\n        if (state.eat(0x7D /* } */)) {\n          // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n          if (max !== -1 && max < min && !noError) {\n            state.raise(\"numbers out of order in {} quantifier\");\n          }\n          return true\n        }\n      }\n      if (state.switchU && !noError) {\n        state.raise(\"Incomplete quantifier\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\n  pp$8.regexp_eatAtom = function(state) {\n    return (\n      this.regexp_eatPatternCharacters(state) ||\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state)\n    )\n  };\n  pp$8.regexp_eatReverseSolidusAtomEscape = function(state) {\n    var start = state.pos;\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatAtomEscape(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatUncapturingGroup = function(state) {\n    var start = state.pos;\n    if (state.eat(0x28 /* ( */)) {\n      if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n        this.regexp_disjunction(state);\n        if (state.eat(0x29 /* ) */)) {\n          return true\n        }\n        state.raise(\"Unterminated group\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatCapturingGroup = function(state) {\n    if (state.eat(0x28 /* ( */)) {\n      if (this.options.ecmaVersion >= 9) {\n        this.regexp_groupSpecifier(state);\n      } else if (state.current() === 0x3F /* ? */) {\n        state.raise(\"Invalid group\");\n      }\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        state.numCapturingParens += 1;\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\n  pp$8.regexp_eatExtendedAtom = function(state) {\n    return (\n      state.eat(0x2E /* . */) ||\n      this.regexp_eatReverseSolidusAtomEscape(state) ||\n      this.regexp_eatCharacterClass(state) ||\n      this.regexp_eatUncapturingGroup(state) ||\n      this.regexp_eatCapturingGroup(state) ||\n      this.regexp_eatInvalidBracedQuantifier(state) ||\n      this.regexp_eatExtendedPatternCharacter(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\n  pp$8.regexp_eatInvalidBracedQuantifier = function(state) {\n    if (this.regexp_eatBracedQuantifier(state, true)) {\n      state.raise(\"Nothing to repeat\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\n  pp$8.regexp_eatSyntaxCharacter = function(state) {\n    var ch = state.current();\n    if (isSyntaxCharacter(ch)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isSyntaxCharacter(ch) {\n    return (\n      ch === 0x24 /* $ */ ||\n      ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n      ch === 0x2E /* . */ ||\n      ch === 0x3F /* ? */ ||\n      ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n      ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n  // But eat eager.\n  pp$8.regexp_eatPatternCharacters = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n      state.advance();\n    }\n    return state.pos !== start\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\n  pp$8.regexp_eatExtendedPatternCharacter = function(state) {\n    var ch = state.current();\n    if (\n      ch !== -1 &&\n      ch !== 0x24 /* $ */ &&\n      !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n      ch !== 0x2E /* . */ &&\n      ch !== 0x3F /* ? */ &&\n      ch !== 0x5B /* [ */ &&\n      ch !== 0x5E /* ^ */ &&\n      ch !== 0x7C /* | */\n    ) {\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // GroupSpecifier[U] ::\n  //   [empty]\n  //   `?` GroupName[?U]\n  pp$8.regexp_groupSpecifier = function(state) {\n    if (state.eat(0x3F /* ? */)) {\n      if (this.regexp_eatGroupName(state)) {\n        if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n          state.raise(\"Duplicate capture group name\");\n        }\n        state.groupNames.push(state.lastStringValue);\n        return\n      }\n      state.raise(\"Invalid group\");\n    }\n  };\n\n  // GroupName[U] ::\n  //   `<` RegExpIdentifierName[?U] `>`\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatGroupName = function(state) {\n    state.lastStringValue = \"\";\n    if (state.eat(0x3C /* < */)) {\n      if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n        return true\n      }\n      state.raise(\"Invalid capture group name\");\n    }\n    return false\n  };\n\n  // RegExpIdentifierName[U] ::\n  //   RegExpIdentifierStart[?U]\n  //   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n  // Note: this updates `state.lastStringValue` property with the eaten name.\n  pp$8.regexp_eatRegExpIdentifierName = function(state) {\n    state.lastStringValue = \"\";\n    if (this.regexp_eatRegExpIdentifierStart(state)) {\n      state.lastStringValue += codePointToString(state.lastIntValue);\n      while (this.regexp_eatRegExpIdentifierPart(state)) {\n        state.lastStringValue += codePointToString(state.lastIntValue);\n      }\n      return true\n    }\n    return false\n  };\n\n  // RegExpIdentifierStart[U] ::\n  //   UnicodeIDStart\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  pp$8.regexp_eatRegExpIdentifierStart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierStart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierStart(ch) {\n    return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n  }\n\n  // RegExpIdentifierPart[U] ::\n  //   UnicodeIDContinue\n  //   `$`\n  //   `_`\n  //   `\\` RegExpUnicodeEscapeSequence[?U]\n  //   <ZWNJ>\n  //   <ZWJ>\n  pp$8.regexp_eatRegExpIdentifierPart = function(state) {\n    var start = state.pos;\n    var ch = state.current();\n    state.advance();\n\n    if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n      ch = state.lastIntValue;\n    }\n    if (isRegExpIdentifierPart(ch)) {\n      state.lastIntValue = ch;\n      return true\n    }\n\n    state.pos = start;\n    return false\n  };\n  function isRegExpIdentifierPart(ch) {\n    return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\n  pp$8.regexp_eatAtomEscape = function(state) {\n    if (\n      this.regexp_eatBackReference(state) ||\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state) ||\n      (state.switchN && this.regexp_eatKGroupName(state))\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      if (state.current() === 0x63 /* c */) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    return false\n  };\n  pp$8.regexp_eatBackReference = function(state) {\n    var start = state.pos;\n    if (this.regexp_eatDecimalEscape(state)) {\n      var n = state.lastIntValue;\n      if (state.switchU) {\n        // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n        if (n > state.maxBackReference) {\n          state.maxBackReference = n;\n        }\n        return true\n      }\n      if (n <= state.numCapturingParens) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatKGroupName = function(state) {\n    if (state.eat(0x6B /* k */)) {\n      if (this.regexp_eatGroupName(state)) {\n        state.backReferenceNames.push(state.lastStringValue);\n        return true\n      }\n      state.raise(\"Invalid named reference\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\n  pp$8.regexp_eatCharacterEscape = function(state) {\n    return (\n      this.regexp_eatControlEscape(state) ||\n      this.regexp_eatCControlLetter(state) ||\n      this.regexp_eatZero(state) ||\n      this.regexp_eatHexEscapeSequence(state) ||\n      this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n      (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n      this.regexp_eatIdentityEscape(state)\n    )\n  };\n  pp$8.regexp_eatCControlLetter = function(state) {\n    var start = state.pos;\n    if (state.eat(0x63 /* c */)) {\n      if (this.regexp_eatControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n    return false\n  };\n  pp$8.regexp_eatZero = function(state) {\n    if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n      state.lastIntValue = 0;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\n  pp$8.regexp_eatControlEscape = function(state) {\n    var ch = state.current();\n    if (ch === 0x74 /* t */) {\n      state.lastIntValue = 0x09; /* \\t */\n      state.advance();\n      return true\n    }\n    if (ch === 0x6E /* n */) {\n      state.lastIntValue = 0x0A; /* \\n */\n      state.advance();\n      return true\n    }\n    if (ch === 0x76 /* v */) {\n      state.lastIntValue = 0x0B; /* \\v */\n      state.advance();\n      return true\n    }\n    if (ch === 0x66 /* f */) {\n      state.lastIntValue = 0x0C; /* \\f */\n      state.advance();\n      return true\n    }\n    if (ch === 0x72 /* r */) {\n      state.lastIntValue = 0x0D; /* \\r */\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\n  pp$8.regexp_eatControlLetter = function(state) {\n    var ch = state.current();\n    if (isControlLetter(ch)) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n  function isControlLetter(ch) {\n    return (\n      (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n    )\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\n  pp$8.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x75 /* u */)) {\n      if (this.regexp_eatFixedHexDigits(state, 4)) {\n        var lead = state.lastIntValue;\n        if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n          var leadSurrogateEnd = state.pos;\n          if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n            var trail = state.lastIntValue;\n            if (trail >= 0xDC00 && trail <= 0xDFFF) {\n              state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n              return true\n            }\n          }\n          state.pos = leadSurrogateEnd;\n          state.lastIntValue = lead;\n        }\n        return true\n      }\n      if (\n        state.switchU &&\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatHexDigits(state) &&\n        state.eat(0x7D /* } */) &&\n        isValidUnicode(state.lastIntValue)\n      ) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid unicode escape\");\n      }\n      state.pos = start;\n    }\n\n    return false\n  };\n  function isValidUnicode(ch) {\n    return ch >= 0 && ch <= 0x10FFFF\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\n  pp$8.regexp_eatIdentityEscape = function(state) {\n    if (state.switchU) {\n      if (this.regexp_eatSyntaxCharacter(state)) {\n        return true\n      }\n      if (state.eat(0x2F /* / */)) {\n        state.lastIntValue = 0x2F; /* / */\n        return true\n      }\n      return false\n    }\n\n    var ch = state.current();\n    if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\n  pp$8.regexp_eatDecimalEscape = function(state) {\n    state.lastIntValue = 0;\n    var ch = state.current();\n    if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n      do {\n        state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n        state.advance();\n      } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\n  pp$8.regexp_eatCharacterClassEscape = function(state) {\n    var ch = state.current();\n\n    if (isCharacterClassEscape(ch)) {\n      state.lastIntValue = -1;\n      state.advance();\n      return true\n    }\n\n    if (\n      state.switchU &&\n      this.options.ecmaVersion >= 9 &&\n      (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n    ) {\n      state.lastIntValue = -1;\n      state.advance();\n      if (\n        state.eat(0x7B /* { */) &&\n        this.regexp_eatUnicodePropertyValueExpression(state) &&\n        state.eat(0x7D /* } */)\n      ) {\n        return true\n      }\n      state.raise(\"Invalid property name\");\n    }\n\n    return false\n  };\n  function isCharacterClassEscape(ch) {\n    return (\n      ch === 0x64 /* d */ ||\n      ch === 0x44 /* D */ ||\n      ch === 0x73 /* s */ ||\n      ch === 0x53 /* S */ ||\n      ch === 0x77 /* w */ ||\n      ch === 0x57 /* W */\n    )\n  }\n\n  // UnicodePropertyValueExpression ::\n  //   UnicodePropertyName `=` UnicodePropertyValue\n  //   LoneUnicodePropertyNameOrValue\n  pp$8.regexp_eatUnicodePropertyValueExpression = function(state) {\n    var start = state.pos;\n\n    // UnicodePropertyName `=` UnicodePropertyValue\n    if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n      var name = state.lastStringValue;\n      if (this.regexp_eatUnicodePropertyValue(state)) {\n        var value = state.lastStringValue;\n        this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n        return true\n      }\n    }\n    state.pos = start;\n\n    // LoneUnicodePropertyNameOrValue\n    if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n      var nameOrValue = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n      return true\n    }\n    return false\n  };\n  pp$8.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n    if (!has(state.unicodeProperties.nonBinary, name))\n      { state.raise(\"Invalid property name\"); }\n    if (!state.unicodeProperties.nonBinary[name].test(value))\n      { state.raise(\"Invalid property value\"); }\n  };\n  pp$8.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n    if (!state.unicodeProperties.binary.test(nameOrValue))\n      { state.raise(\"Invalid property name\"); }\n  };\n\n  // UnicodePropertyName ::\n  //   UnicodePropertyNameCharacters\n  pp$8.regexp_eatUnicodePropertyName = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyNameCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyNameCharacter(ch) {\n    return isControlLetter(ch) || ch === 0x5F /* _ */\n  }\n\n  // UnicodePropertyValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatUnicodePropertyValue = function(state) {\n    var ch = 0;\n    state.lastStringValue = \"\";\n    while (isUnicodePropertyValueCharacter(ch = state.current())) {\n      state.lastStringValue += codePointToString(ch);\n      state.advance();\n    }\n    return state.lastStringValue !== \"\"\n  };\n  function isUnicodePropertyValueCharacter(ch) {\n    return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n  }\n\n  // LoneUnicodePropertyNameOrValue ::\n  //   UnicodePropertyValueCharacters\n  pp$8.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n    return this.regexp_eatUnicodePropertyValue(state)\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\n  pp$8.regexp_eatCharacterClass = function(state) {\n    if (state.eat(0x5B /* [ */)) {\n      state.eat(0x5E /* ^ */);\n      this.regexp_classRanges(state);\n      if (state.eat(0x5D /* [ */)) {\n        return true\n      }\n      // Unreachable since it threw \"unterminated regular expression\" error before.\n      state.raise(\"Unterminated character class\");\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\n  pp$8.regexp_classRanges = function(state) {\n    while (this.regexp_eatClassAtom(state)) {\n      var left = state.lastIntValue;\n      if (state.eat(0x2D /* - */) && this.regexp_eatClassAtom(state)) {\n        var right = state.lastIntValue;\n        if (state.switchU && (left === -1 || right === -1)) {\n          state.raise(\"Invalid character class\");\n        }\n        if (left !== -1 && right !== -1 && left > right) {\n          state.raise(\"Range out of order in character class\");\n        }\n      }\n    }\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\n  pp$8.regexp_eatClassAtom = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x5C /* \\ */)) {\n      if (this.regexp_eatClassEscape(state)) {\n        return true\n      }\n      if (state.switchU) {\n        // Make the same message as V8.\n        var ch$1 = state.current();\n        if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n          state.raise(\"Invalid class escape\");\n        }\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n\n    var ch = state.current();\n    if (ch !== 0x5D /* [ */) {\n      state.lastIntValue = ch;\n      state.advance();\n      return true\n    }\n\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\n  pp$8.regexp_eatClassEscape = function(state) {\n    var start = state.pos;\n\n    if (state.eat(0x62 /* b */)) {\n      state.lastIntValue = 0x08; /* <BS> */\n      return true\n    }\n\n    if (state.switchU && state.eat(0x2D /* - */)) {\n      state.lastIntValue = 0x2D; /* - */\n      return true\n    }\n\n    if (!state.switchU && state.eat(0x63 /* c */)) {\n      if (this.regexp_eatClassControlLetter(state)) {\n        return true\n      }\n      state.pos = start;\n    }\n\n    return (\n      this.regexp_eatCharacterClassEscape(state) ||\n      this.regexp_eatCharacterEscape(state)\n    )\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\n  pp$8.regexp_eatClassControlLetter = function(state) {\n    var ch = state.current();\n    if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n      state.lastIntValue = ch % 0x20;\n      state.advance();\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatHexEscapeSequence = function(state) {\n    var start = state.pos;\n    if (state.eat(0x78 /* x */)) {\n      if (this.regexp_eatFixedHexDigits(state, 2)) {\n        return true\n      }\n      if (state.switchU) {\n        state.raise(\"Invalid escape\");\n      }\n      state.pos = start;\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\n  pp$8.regexp_eatDecimalDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isDecimalDigit(ch = state.current())) {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\n  pp$8.regexp_eatHexDigits = function(state) {\n    var start = state.pos;\n    var ch = 0;\n    state.lastIntValue = 0;\n    while (isHexDigit(ch = state.current())) {\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return state.pos !== start\n  };\n  function isHexDigit(ch) {\n    return (\n      (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n      (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n      (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n    )\n  }\n  function hexToInt(ch) {\n    if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n      return 10 + (ch - 0x41 /* A */)\n    }\n    if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n      return 10 + (ch - 0x61 /* a */)\n    }\n    return ch - 0x30 /* 0 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n  // Allows only 0-377(octal) i.e. 0-255(decimal).\n  pp$8.regexp_eatLegacyOctalEscapeSequence = function(state) {\n    if (this.regexp_eatOctalDigit(state)) {\n      var n1 = state.lastIntValue;\n      if (this.regexp_eatOctalDigit(state)) {\n        var n2 = state.lastIntValue;\n        if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n          state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n        } else {\n          state.lastIntValue = n1 * 8 + n2;\n        }\n      } else {\n        state.lastIntValue = n1;\n      }\n      return true\n    }\n    return false\n  };\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\n  pp$8.regexp_eatOctalDigit = function(state) {\n    var ch = state.current();\n    if (isOctalDigit(ch)) {\n      state.lastIntValue = ch - 0x30; /* 0 */\n      state.advance();\n      return true\n    }\n    state.lastIntValue = 0;\n    return false\n  };\n  function isOctalDigit(ch) {\n    return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n  }\n\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n  // https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n  // And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\n  pp$8.regexp_eatFixedHexDigits = function(state, length) {\n    var start = state.pos;\n    state.lastIntValue = 0;\n    for (var i = 0; i < length; ++i) {\n      var ch = state.current();\n      if (!isHexDigit(ch)) {\n        state.pos = start;\n        return false\n      }\n      state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n      state.advance();\n    }\n    return true\n  };\n\n  // Object type used to represent tokens. Note that normally, tokens\n  // simply exist as properties on the parser object. This is only\n  // used for the onToken callback and the external tokenizer.\n\n  var Token = function Token(p) {\n    this.type = p.type;\n    this.value = p.value;\n    this.start = p.start;\n    this.end = p.end;\n    if (p.options.locations)\n      { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n    if (p.options.ranges)\n      { this.range = [p.start, p.end]; }\n  };\n\n  // ## Tokenizer\n\n  var pp$9 = Parser.prototype;\n\n  // Move to the next token\n\n  pp$9.next = function() {\n    if (this.options.onToken)\n      { this.options.onToken(new Token(this)); }\n\n    this.lastTokEnd = this.end;\n    this.lastTokStart = this.start;\n    this.lastTokEndLoc = this.endLoc;\n    this.lastTokStartLoc = this.startLoc;\n    this.nextToken();\n  };\n\n  pp$9.getToken = function() {\n    this.next();\n    return new Token(this)\n  };\n\n  // If we're in an ES6 environment, make parsers iterable\n  if (typeof Symbol !== \"undefined\")\n    { pp$9[Symbol.iterator] = function() {\n      var this$1 = this;\n\n      return {\n        next: function () {\n          var token = this$1.getToken();\n          return {\n            done: token.type === types.eof,\n            value: token\n          }\n        }\n      }\n    }; }\n\n  // Toggle strict mode. Re-reads the next number or string to please\n  // pedantic tests (`\"use strict\"; 010;` should fail).\n\n  pp$9.curContext = function() {\n    return this.context[this.context.length - 1]\n  };\n\n  // Read a single token, updating the parser object's token-related\n  // properties.\n\n  pp$9.nextToken = function() {\n    var curContext = this.curContext();\n    if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n    this.start = this.pos;\n    if (this.options.locations) { this.startLoc = this.curPosition(); }\n    if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n    if (curContext.override) { return curContext.override(this) }\n    else { this.readToken(this.fullCharCodeAtPos()); }\n  };\n\n  pp$9.readToken = function(code) {\n    // Identifier or keyword. '\\uXXXX' sequences are allowed in\n    // identifiers, so '\\' also dispatches to that.\n    if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n      { return this.readWord() }\n\n    return this.getTokenFromCode(code)\n  };\n\n  pp$9.fullCharCodeAtPos = function() {\n    var code = this.input.charCodeAt(this.pos);\n    if (code <= 0xd7ff || code >= 0xe000) { return code }\n    var next = this.input.charCodeAt(this.pos + 1);\n    return (code << 10) + next - 0x35fdc00\n  };\n\n  pp$9.skipBlockComment = function() {\n    var startLoc = this.options.onComment && this.curPosition();\n    var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n    if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n    this.pos = end + 2;\n    if (this.options.locations) {\n      lineBreakG.lastIndex = start;\n      var match;\n      while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n        ++this.curLine;\n        this.lineStart = match.index + match[0].length;\n      }\n    }\n    if (this.options.onComment)\n      { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  pp$9.skipLineComment = function(startSkip) {\n    var start = this.pos;\n    var startLoc = this.options.onComment && this.curPosition();\n    var ch = this.input.charCodeAt(this.pos += startSkip);\n    while (this.pos < this.input.length && !isNewLine(ch)) {\n      ch = this.input.charCodeAt(++this.pos);\n    }\n    if (this.options.onComment)\n      { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                             startLoc, this.curPosition()); }\n  };\n\n  // Called at the start of the parse and after every token. Skips\n  // whitespace and comments, and.\n\n  pp$9.skipSpace = function() {\n    loop: while (this.pos < this.input.length) {\n      var ch = this.input.charCodeAt(this.pos);\n      switch (ch) {\n      case 32: case 160: // ' '\n        ++this.pos;\n        break\n      case 13:\n        if (this.input.charCodeAt(this.pos + 1) === 10) {\n          ++this.pos;\n        }\n      case 10: case 8232: case 8233:\n        ++this.pos;\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        break\n      case 47: // '/'\n        switch (this.input.charCodeAt(this.pos + 1)) {\n        case 42: // '*'\n          this.skipBlockComment();\n          break\n        case 47:\n          this.skipLineComment(2);\n          break\n        default:\n          break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this.pos;\n        } else {\n          break loop\n        }\n      }\n    }\n  };\n\n  // Called at the end of every token. Sets `end`, `val`, and\n  // maintains `context` and `exprAllowed`, and skips the space after\n  // the token, so that the next one's `start` will point at the\n  // right position.\n\n  pp$9.finishToken = function(type, val) {\n    this.end = this.pos;\n    if (this.options.locations) { this.endLoc = this.curPosition(); }\n    var prevType = this.type;\n    this.type = type;\n    this.value = val;\n\n    this.updateContext(prevType);\n  };\n\n  // ### Token reading\n\n  // This is the function that is called to fetch the next token. It\n  // is somewhat obscure, because it works in character codes rather\n  // than characters, and because operator parsing has been inlined\n  // into it.\n  //\n  // All in the name of speed.\n  //\n  pp$9.readToken_dot = function() {\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next >= 48 && next <= 57) { return this.readNumber(true) }\n    var next2 = this.input.charCodeAt(this.pos + 2);\n    if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n      this.pos += 3;\n      return this.finishToken(types.ellipsis)\n    } else {\n      ++this.pos;\n      return this.finishToken(types.dot)\n    }\n  };\n\n  pp$9.readToken_slash = function() { // '/'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.slash, 1)\n  };\n\n  pp$9.readToken_mult_modulo_exp = function(code) { // '%*'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    var tokentype = code === 42 ? types.star : types.modulo;\n\n    // exponentiation operator ** and **=\n    if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n      ++size;\n      tokentype = types.starstar;\n      next = this.input.charCodeAt(this.pos + 2);\n    }\n\n    if (next === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(tokentype, size)\n  };\n\n  pp$9.readToken_pipe_amp = function(code) { // '|&'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n  };\n\n  pp$9.readToken_caret = function() { // '^'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.bitwiseXOR, 1)\n  };\n\n  pp$9.readToken_plus_min = function(code) { // '+-'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === code) {\n      if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n          (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n        // A `-->` line comment\n        this.skipLineComment(3);\n        this.skipSpace();\n        return this.nextToken()\n      }\n      return this.finishOp(types.incDec, 2)\n    }\n    if (next === 61) { return this.finishOp(types.assign, 2) }\n    return this.finishOp(types.plusMin, 1)\n  };\n\n  pp$9.readToken_lt_gt = function(code) { // '<>'\n    var next = this.input.charCodeAt(this.pos + 1);\n    var size = 1;\n    if (next === code) {\n      size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n      if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n      return this.finishOp(types.bitShift, size)\n    }\n    if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n        this.input.charCodeAt(this.pos + 3) === 45) {\n      // `<!--`, an XML-style comment that should be interpreted as a line comment\n      this.skipLineComment(4);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    if (next === 61) { size = 2; }\n    return this.finishOp(types.relational, size)\n  };\n\n  pp$9.readToken_eq_excl = function(code) { // '=!'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n    if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n      this.pos += 2;\n      return this.finishToken(types.arrow)\n    }\n    return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n  };\n\n  pp$9.getTokenFromCode = function(code) {\n    switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46: // '.'\n      return this.readToken_dot()\n\n    // Punctuation tokens.\n    case 40: ++this.pos; return this.finishToken(types.parenL)\n    case 41: ++this.pos; return this.finishToken(types.parenR)\n    case 59: ++this.pos; return this.finishToken(types.semi)\n    case 44: ++this.pos; return this.finishToken(types.comma)\n    case 91: ++this.pos; return this.finishToken(types.bracketL)\n    case 93: ++this.pos; return this.finishToken(types.bracketR)\n    case 123: ++this.pos; return this.finishToken(types.braceL)\n    case 125: ++this.pos; return this.finishToken(types.braceR)\n    case 58: ++this.pos; return this.finishToken(types.colon)\n    case 63: ++this.pos; return this.finishToken(types.question)\n\n    case 96: // '`'\n      if (this.options.ecmaVersion < 6) { break }\n      ++this.pos;\n      return this.finishToken(types.backQuote)\n\n    case 48: // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n        if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n      return this.readNumber(false)\n\n    // Quotes produce strings.\n    case 34: case 39: // '\"', \"'\"\n      return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47: // '/'\n      return this.readToken_slash()\n\n    case 37: case 42: // '%*'\n      return this.readToken_mult_modulo_exp(code)\n\n    case 124: case 38: // '|&'\n      return this.readToken_pipe_amp(code)\n\n    case 94: // '^'\n      return this.readToken_caret()\n\n    case 43: case 45: // '+-'\n      return this.readToken_plus_min(code)\n\n    case 60: case 62: // '<>'\n      return this.readToken_lt_gt(code)\n\n    case 61: case 33: // '=!'\n      return this.readToken_eq_excl(code)\n\n    case 126: // '~'\n      return this.finishOp(types.prefix, 1)\n    }\n\n    this.raise(this.pos, \"Unexpected character '\" + codePointToString$1(code) + \"'\");\n  };\n\n  pp$9.finishOp = function(type, size) {\n    var str = this.input.slice(this.pos, this.pos + size);\n    this.pos += size;\n    return this.finishToken(type, str)\n  };\n\n  pp$9.readRegexp = function() {\n    var escaped, inClass, start = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(start, \"Unterminated regular expression\"); }\n      var ch = this.input.charAt(this.pos);\n      if (lineBreak.test(ch)) { this.raise(start, \"Unterminated regular expression\"); }\n      if (!escaped) {\n        if (ch === \"[\") { inClass = true; }\n        else if (ch === \"]\" && inClass) { inClass = false; }\n        else if (ch === \"/\" && !inClass) { break }\n        escaped = ch === \"\\\\\";\n      } else { escaped = false; }\n      ++this.pos;\n    }\n    var pattern = this.input.slice(start, this.pos);\n    ++this.pos;\n    var flagsStart = this.pos;\n    var flags = this.readWord1();\n    if (this.containsEsc) { this.unexpected(flagsStart); }\n\n    // Validate pattern\n    var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n    state.reset(start, pattern, flags);\n    this.validateRegExpFlags(state);\n    this.validateRegExpPattern(state);\n\n    // Create Literal#value property value.\n    var value = null;\n    try {\n      value = new RegExp(pattern, flags);\n    } catch (e) {\n      // ESTree requires null if it failed to instantiate RegExp object.\n      // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n    }\n\n    return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n  };\n\n  // Read an integer in the given radix. Return null if zero digits\n  // were read, the integer value otherwise. When `len` is given, this\n  // will return `null` unless the integer has exactly `len` digits.\n\n  pp$9.readInt = function(radix, len) {\n    var start = this.pos, total = 0;\n    for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n      var code = this.input.charCodeAt(this.pos), val = (void 0);\n      if (code >= 97) { val = code - 97 + 10; } // a\n      else if (code >= 65) { val = code - 65 + 10; } // A\n      else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n      else { val = Infinity; }\n      if (val >= radix) { break }\n      ++this.pos;\n      total = total * radix + val;\n    }\n    if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n    return total\n  };\n\n  pp$9.readRadixNumber = function(radix) {\n    var start = this.pos;\n    this.pos += 2; // 0x\n    var val = this.readInt(radix);\n    if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n    if (this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110) {\n      val = typeof BigInt !== \"undefined\" ? BigInt(this.input.slice(start, this.pos)) : null;\n      ++this.pos;\n    } else if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n    return this.finishToken(types.num, val)\n  };\n\n  // Read an integer, octal integer, or floating-point number.\n\n  pp$9.readNumber = function(startsWithDot) {\n    var start = this.pos;\n    if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n    if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n    if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n    var next = this.input.charCodeAt(this.pos);\n    if (!octal && !startsWithDot && this.options.ecmaVersion >= 11 && next === 110) {\n      var str$1 = this.input.slice(start, this.pos);\n      var val$1 = typeof BigInt !== \"undefined\" ? BigInt(str$1) : null;\n      ++this.pos;\n      if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n      return this.finishToken(types.num, val$1)\n    }\n    if (next === 46 && !octal) { // '.'\n      ++this.pos;\n      this.readInt(10);\n      next = this.input.charCodeAt(this.pos);\n    }\n    if ((next === 69 || next === 101) && !octal) { // 'eE'\n      next = this.input.charCodeAt(++this.pos);\n      if (next === 43 || next === 45) { ++this.pos; } // '+-'\n      if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n    }\n    if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n    var str = this.input.slice(start, this.pos);\n    var val = octal ? parseInt(str, 8) : parseFloat(str);\n    return this.finishToken(types.num, val)\n  };\n\n  // Read a string value, interpreting backslash-escapes.\n\n  pp$9.readCodePoint = function() {\n    var ch = this.input.charCodeAt(this.pos), code;\n\n    if (ch === 123) { // '{'\n      if (this.options.ecmaVersion < 6) { this.unexpected(); }\n      var codePos = ++this.pos;\n      code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n      ++this.pos;\n      if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n    } else {\n      code = this.readHexChar(4);\n    }\n    return code\n  };\n\n  function codePointToString$1(code) {\n    // UTF-16 Decoding\n    if (code <= 0xFFFF) { return String.fromCharCode(code) }\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n  }\n\n  pp$9.readString = function(quote) {\n    var out = \"\", chunkStart = ++this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated string constant\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === quote) { break }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(false);\n        chunkStart = this.pos;\n      } else {\n        if (isNewLine(ch, this.options.ecmaVersion >= 10)) { this.raise(this.start, \"Unterminated string constant\"); }\n        ++this.pos;\n      }\n    }\n    out += this.input.slice(chunkStart, this.pos++);\n    return this.finishToken(types.string, out)\n  };\n\n  // Reads template string tokens.\n\n  var INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\n  pp$9.tryReadTemplateToken = function() {\n    this.inTemplateElement = true;\n    try {\n      this.readTmplToken();\n    } catch (err) {\n      if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n        this.readInvalidTemplateToken();\n      } else {\n        throw err\n      }\n    }\n\n    this.inTemplateElement = false;\n  };\n\n  pp$9.invalidStringToken = function(position, message) {\n    if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n      throw INVALID_TEMPLATE_ESCAPE_ERROR\n    } else {\n      this.raise(position, message);\n    }\n  };\n\n  pp$9.readTmplToken = function() {\n    var out = \"\", chunkStart = this.pos;\n    for (;;) {\n      if (this.pos >= this.input.length) { this.raise(this.start, \"Unterminated template\"); }\n      var ch = this.input.charCodeAt(this.pos);\n      if (ch === 96 || ch === 36 && this.input.charCodeAt(this.pos + 1) === 123) { // '`', '${'\n        if (this.pos === this.start && (this.type === types.template || this.type === types.invalidTemplate)) {\n          if (ch === 36) {\n            this.pos += 2;\n            return this.finishToken(types.dollarBraceL)\n          } else {\n            ++this.pos;\n            return this.finishToken(types.backQuote)\n          }\n        }\n        out += this.input.slice(chunkStart, this.pos);\n        return this.finishToken(types.template, out)\n      }\n      if (ch === 92) { // '\\'\n        out += this.input.slice(chunkStart, this.pos);\n        out += this.readEscapedChar(true);\n        chunkStart = this.pos;\n      } else if (isNewLine(ch)) {\n        out += this.input.slice(chunkStart, this.pos);\n        ++this.pos;\n        switch (ch) {\n        case 13:\n          if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; }\n        case 10:\n          out += \"\\n\";\n          break\n        default:\n          out += String.fromCharCode(ch);\n          break\n        }\n        if (this.options.locations) {\n          ++this.curLine;\n          this.lineStart = this.pos;\n        }\n        chunkStart = this.pos;\n      } else {\n        ++this.pos;\n      }\n    }\n  };\n\n  // Reads a template token to search for the end, without validating any escape sequences\n  pp$9.readInvalidTemplateToken = function() {\n    for (; this.pos < this.input.length; this.pos++) {\n      switch (this.input[this.pos]) {\n      case \"\\\\\":\n        ++this.pos;\n        break\n\n      case \"$\":\n        if (this.input[this.pos + 1] !== \"{\") {\n          break\n        }\n      // falls through\n\n      case \"`\":\n        return this.finishToken(types.invalidTemplate, this.input.slice(this.start, this.pos))\n\n      // no default\n      }\n    }\n    this.raise(this.start, \"Unterminated template\");\n  };\n\n  // Used to read escaped characters\n\n  pp$9.readEscapedChar = function(inTemplate) {\n    var ch = this.input.charCodeAt(++this.pos);\n    ++this.pos;\n    switch (ch) {\n    case 110: return \"\\n\" // 'n' -> '\\n'\n    case 114: return \"\\r\" // 'r' -> '\\r'\n    case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n    case 117: return codePointToString$1(this.readCodePoint()) // 'u'\n    case 116: return \"\\t\" // 't' -> '\\t'\n    case 98: return \"\\b\" // 'b' -> '\\b'\n    case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n    case 102: return \"\\f\" // 'f' -> '\\f'\n    case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n    case 10: // ' \\n'\n      if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n      return \"\"\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(\n            this.pos - 1 - octalStr.length,\n            inTemplate\n              ? \"Octal literal in template string\"\n              : \"Octal literal in strict mode\"\n          );\n        }\n        return String.fromCharCode(octal)\n      }\n      if (isNewLine(ch)) {\n        // Unicode new line characters after \\ get removed from output in both\n        // template literals and strings\n        return \"\"\n      }\n      return String.fromCharCode(ch)\n    }\n  };\n\n  // Used to read character escape sequences ('\\x', '\\u', '\\U').\n\n  pp$9.readHexChar = function(len) {\n    var codePos = this.pos;\n    var n = this.readInt(16, len);\n    if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n    return n\n  };\n\n  // Read an identifier, and return it as a string. Sets `this.containsEsc`\n  // to whether the word contained a '\\u' escape.\n  //\n  // Incrementally adds only escaped chars, adding other chunks as-is\n  // as a micro-optimization.\n\n  pp$9.readWord1 = function() {\n    this.containsEsc = false;\n    var word = \"\", first = true, chunkStart = this.pos;\n    var astral = this.options.ecmaVersion >= 6;\n    while (this.pos < this.input.length) {\n      var ch = this.fullCharCodeAtPos();\n      if (isIdentifierChar(ch, astral)) {\n        this.pos += ch <= 0xffff ? 1 : 2;\n      } else if (ch === 92) { // \"\\\"\n        this.containsEsc = true;\n        word += this.input.slice(chunkStart, this.pos);\n        var escStart = this.pos;\n        if (this.input.charCodeAt(++this.pos) !== 117) // \"u\"\n          { this.invalidStringToken(this.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n        ++this.pos;\n        var esc = this.readCodePoint();\n        if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n          { this.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n        word += codePointToString$1(esc);\n        chunkStart = this.pos;\n      } else {\n        break\n      }\n      first = false;\n    }\n    return word + this.input.slice(chunkStart, this.pos)\n  };\n\n  // Read an identifier or keyword token. Will check for reserved\n  // words when necessary.\n\n  pp$9.readWord = function() {\n    var word = this.readWord1();\n    var type = types.name;\n    if (this.keywords.test(word)) {\n      if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n      type = keywords$1[word];\n    }\n    return this.finishToken(type, word)\n  };\n\n  // Acorn is a tiny, fast JavaScript parser written in JavaScript.\n\n  var version = \"7.1.0\";\n\n  Parser.acorn = {\n    Parser: Parser,\n    version: version,\n    defaultOptions: defaultOptions,\n    Position: Position,\n    SourceLocation: SourceLocation,\n    getLineInfo: getLineInfo,\n    Node: Node,\n    TokenType: TokenType,\n    tokTypes: types,\n    keywordTypes: keywords$1,\n    TokContext: TokContext,\n    tokContexts: types$1,\n    isIdentifierChar: isIdentifierChar,\n    isIdentifierStart: isIdentifierStart,\n    Token: Token,\n    isNewLine: isNewLine,\n    lineBreak: lineBreak,\n    lineBreakG: lineBreakG,\n    nonASCIIwhitespace: nonASCIIwhitespace\n  };\n\n  // The main exported interface (under `self.acorn` when in the\n  // browser) is a `parse` function that takes a code string and\n  // returns an abstract syntax tree as specified by [Mozilla parser\n  // API][api].\n  //\n  // [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\n  function parse(input, options) {\n    return Parser.parse(input, options)\n  }\n\n  // This function tries to parse a single expression at a given\n  // offset in a string. Useful for parsing mixed-language formats\n  // that embed JavaScript expressions.\n\n  function parseExpressionAt(input, pos, options) {\n    return Parser.parseExpressionAt(input, pos, options)\n  }\n\n  // Acorn is organized as a tokenizer and a recursive-descent parser.\n  // The `tokenizer` export provides an interface to the tokenizer.\n\n  function tokenizer(input, options) {\n    return Parser.tokenizer(input, options)\n  }\n\n  exports.Node = Node;\n  exports.Parser = Parser;\n  exports.Position = Position;\n  exports.SourceLocation = SourceLocation;\n  exports.TokContext = TokContext;\n  exports.Token = Token;\n  exports.TokenType = TokenType;\n  exports.defaultOptions = defaultOptions;\n  exports.getLineInfo = getLineInfo;\n  exports.isIdentifierChar = isIdentifierChar;\n  exports.isIdentifierStart = isIdentifierStart;\n  exports.isNewLine = isNewLine;\n  exports.keywordTypes = keywords$1;\n  exports.lineBreak = lineBreak;\n  exports.lineBreakG = lineBreakG;\n  exports.nonASCIIwhitespace = nonASCIIwhitespace;\n  exports.parse = parse;\n  exports.parseExpressionAt = parseExpressionAt;\n  exports.tokContexts = types$1;\n  exports.tokTypes = types;\n  exports.tokenizer = tokenizer;\n  exports.version = version;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n","/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/tests.js":"// Tests largely based on those of Esprima\n// (http://esprima.org/test/)\n\nif (typeof exports != \"undefined\") {\n  var driver = require(\"./driver.js\");\n  var test = driver.test, testFail = driver.testFail, testAssert = driver.testAssert, misMatch = driver.misMatch;\n  var acorn = require(\"../acorn\");\n}\n\ntest(\"import ''\", {\n  type: \"Program\",\n  start: 0,\n  end: 9,\n  body: [\n    {\n      type: \"ImportDeclaration\",\n      start: 0,\n      end: 9,\n      specifiers: [],\n      source: {\n        type: \"Literal\",\n        start: 7,\n        end: 9,\n        value: \"\",\n        raw: \"''\"\n      }\n    }\n  ]\n}, {\n  ecmaVersion: 5,\n  sourceType: \"module\"\n});\n\ntestFail(\"import('')\", \"Unexpected token (1:6)\", {\n  ecmaVersion: 5,\n  sourceType: \"module\"\n});\n\ntest(\"new Object\", {\n  type: \"Program\",\n  start: 0,\n  end: 10,\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      start: 0,\n      end: 10,\n      expression: {\n        type: \"NewExpression\",\n        start: 0,\n        end: 10,\n        callee: {\n          type: \"Identifier\",\n          start: 4,\n          end: 10,\n          name: \"Object\"\n        },\n        arguments: []\n      }\n    }\n  ]\n}, {\n  allowReserved: \"never\"\n});\n\ntest(\"this\\n\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"ThisExpression\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 0\n    }\n  }\n});\n\ntest(\"null\\n\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: null,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 0\n    }\n  }\n});\n\ntest(\"\\n    42\\n\\n\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 2,\n            column: 4\n          },\n          end: {\n            line: 2,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 2,\n          column: 4\n        },\n        end: {\n          line: 2,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 4,\n      column: 0\n    }\n  }\n});\n\ntest(\"/foobar/\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: /foobar/,\n        regex: {\n          pattern: \"foobar\",\n          flags: \"\"\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 8\n          }\n        }\n      }\n    }\n  ]\n});\n\ntest(\"/[a-z]/g\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: /[a-z]/g,\n        regex: {\n          pattern: \"[a-z]\",\n          flags: \"g\"\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 8\n          }\n        }\n      }\n    }\n  ]\n});\n\ntest(\"(1 + 2 ) * 3\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Literal\",\n            value: 1,\n            loc: {\n              start: {\n                line: 1,\n                column: 1\n              },\n              end: {\n                line: 1,\n                column: 2\n              }\n            }\n          },\n          operator: \"+\",\n          right: {\n            type: \"Literal\",\n            value: 2,\n            loc: {\n              start: {\n                line: 1,\n                column: 5\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        operator: \"*\",\n        right: {\n          type: \"Literal\",\n          value: 3,\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 12\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 12\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 12\n    }\n  }\n});\n\ntest(\"(1 + 2 ) * 3\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"ParenthesizedExpression\",\n          expression: {\n            type: \"BinaryExpression\",\n            left: {\n              type: \"Literal\",\n              value: 1,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 1\n                },\n                end: {\n                  line: 1,\n                  column: 2\n                }\n              }\n            },\n            operator: \"+\",\n            right: {\n              type: \"Literal\",\n              value: 2,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 5\n                },\n                end: {\n                  line: 1,\n                  column: 6\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 1\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        operator: \"*\",\n        right: {\n          type: \"Literal\",\n          value: 3,\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 12\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 12\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 12\n    }\n  }\n}, {\n  locations: true,\n  preserveParens: true\n});\n\ntest(\"(x = 23)\", {\n  body: [\n    {\n      expression: {\n        type: \"ParenthesizedExpression\",\n        expression: {\n          type: \"AssignmentExpression\",\n          operator: \"=\",\n          left: {\n            name: \"x\",\n            type: \"Identifier\",\n          },\n          right: {\n            value: 23,\n            raw: \"23\",\n            type: \"Literal\",\n          },\n        },\n      },\n      type: \"ExpressionStatement\",\n    }\n  ],\n  type: \"Program\",\n}, {preserveParens: true});\n\ntest(\"x = []\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x = [ ]\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x = [ 42 ]\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [\n            {\n              type: \"Literal\",\n              value: 42,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 6\n                },\n                end: {\n                  line: 1,\n                  column: 8\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 10\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 10\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 10\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 10\n    }\n  }\n});\n\ntest(\"x = [ 42, ]\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [\n            {\n              type: \"Literal\",\n              value: 42,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 6\n                },\n                end: {\n                  line: 1,\n                  column: 8\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"x = [ ,, 42 ]\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [\n            null,\n            null,\n            {\n              type: \"Literal\",\n              value: 42,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 11\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 13\n    }\n  }\n});\n\ntest(\"x = [ 1, 2, 3, ]\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [\n            {\n              type: \"Literal\",\n              value: 1,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 6\n                },\n                end: {\n                  line: 1,\n                  column: 7\n                }\n              }\n            },\n            {\n              type: \"Literal\",\n              value: 2,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 10\n                }\n              }\n            },\n            {\n              type: \"Literal\",\n              value: 3,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 12\n                },\n                end: {\n                  line: 1,\n                  column: 13\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 16\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"x = [ 1, 2,, 3, ]\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [\n            {\n              type: \"Literal\",\n              value: 1,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 6\n                },\n                end: {\n                  line: 1,\n                  column: 7\n                }\n              }\n            },\n            {\n              type: \"Literal\",\n              value: 2,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 10\n                }\n              }\n            },\n            null,\n            {\n              type: \"Literal\",\n              value: 3,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 14\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 17\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 17\n    }\n  }\n});\n\ntest(\"日本語 = []\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"日本語\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 3\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 8\n    }\n  }\n});\n\ntest(\"T‿ = []\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"T‿\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 2\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"T‌ = []\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"T‌\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 2\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"T‍ = []\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"T‍\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 2\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"ⅣⅡ = []\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"ⅣⅡ\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 2\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"ⅣⅡ = []\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"ⅣⅡ\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 2\n            }\n          }\n        },\n        right: {\n          type: \"ArrayExpression\",\n          elements: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x = {}\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x = { }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x = { answer: 42 }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"answer\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 12\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 42,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 14\n                  },\n                  end: {\n                    line: 1,\n                    column: 16\n                  }\n                }\n              },\n              kind: \"init\"\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 18\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 18\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 18\n    }\n  }\n});\n\ntest(\"x = { if: 42 }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"if\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 8\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 42,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 12\n                  }\n                }\n              },\n              kind: \"init\"\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 14\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"x = { true: 42 }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"true\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 10\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 42,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 12\n                  },\n                  end: {\n                    line: 1,\n                    column: 14\n                  }\n                }\n              },\n              kind: \"init\"\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 16\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"x = { false: 42 }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"false\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 11\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 42,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 13\n                  },\n                  end: {\n                    line: 1,\n                    column: 15\n                  }\n                }\n              },\n              kind: \"init\"\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 17\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 17\n    }\n  }\n});\n\ntest(\"x = { null: 42 }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"null\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 10\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 42,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 12\n                  },\n                  end: {\n                    line: 1,\n                    column: 14\n                  }\n                }\n              },\n              kind: \"init\"\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 16\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"x = { \\\"answer\\\": 42 }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Literal\",\n                value: \"answer\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 14\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 42,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 16\n                  },\n                  end: {\n                    line: 1,\n                    column: 18\n                  }\n                }\n              },\n              kind: \"init\"\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 20\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 20\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 20\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 20\n    }\n  }\n});\n\ntest(\"x = { x: 1, x: 2 }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"x\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 7\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 1,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 9\n                  },\n                  end: {\n                    line: 1,\n                    column: 10\n                  }\n                }\n              },\n              kind: \"init\"\n            },\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"x\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 12\n                  },\n                  end: {\n                    line: 1,\n                    column: 13\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 2,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 15\n                  },\n                  end: {\n                    line: 1,\n                    column: 16\n                  }\n                }\n              },\n              kind: \"init\"\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 18\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 18\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 18\n    }\n  }\n});\n\ntest(\"x = { get width() { return m_width } }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"width\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 15\n                  }\n                }\n              },\n              kind: \"get\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [\n                    {\n                      type: \"ReturnStatement\",\n                      argument: {\n                        type: \"Identifier\",\n                        name: \"m_width\",\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 27\n                          },\n                          end: {\n                            line: 1,\n                            column: 34\n                          }\n                        }\n                      },\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 20\n                        },\n                        end: {\n                          line: 1,\n                          column: 34\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 18\n                    },\n                    end: {\n                      line: 1,\n                      column: 36\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 15\n                  },\n                  end: {\n                    line: 1,\n                    column: 36\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 38\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 38\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 38\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 38\n    }\n  }\n});\n\ntest(\"x = { get undef() {} }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"undef\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 15\n                  }\n                }\n              },\n              kind: \"get\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 18\n                    },\n                    end: {\n                      line: 1,\n                      column: 20\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 15\n                  },\n                  end: {\n                    line: 1,\n                    column: 20\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 22\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 22\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 22\n    }\n  }\n});\n\ntest(\"x = { get if() {} }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"if\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 12\n                  }\n                }\n              },\n              kind: \"get\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 15\n                    },\n                    end: {\n                      line: 1,\n                      column: 17\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 12\n                  },\n                  end: {\n                    line: 1,\n                    column: 17\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 19\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 19\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 19\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 19\n    }\n  }\n});\n\ntest(\"x = { get true() {} }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"true\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 14\n                  }\n                }\n              },\n              kind: \"get\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 17\n                    },\n                    end: {\n                      line: 1,\n                      column: 19\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 14\n                  },\n                  end: {\n                    line: 1,\n                    column: 19\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 21\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 21\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 21\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 21\n    }\n  }\n});\n\ntest(\"x = { get false() {} }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"false\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 15\n                  }\n                }\n              },\n              kind: \"get\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 18\n                    },\n                    end: {\n                      line: 1,\n                      column: 20\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 15\n                  },\n                  end: {\n                    line: 1,\n                    column: 20\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 22\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 22\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 22\n    }\n  }\n});\n\ntest(\"x = { get null() {} }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"null\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 14\n                  }\n                }\n              },\n              kind: \"get\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 17\n                    },\n                    end: {\n                      line: 1,\n                      column: 19\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 14\n                  },\n                  end: {\n                    line: 1,\n                    column: 19\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 21\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 21\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 21\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 21\n    }\n  }\n});\n\ntest(\"x = { get \\\"undef\\\"() {} }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Literal\",\n                value: \"undef\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 17\n                  }\n                }\n              },\n              kind: \"get\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 20\n                    },\n                    end: {\n                      line: 1,\n                      column: 22\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 17\n                  },\n                  end: {\n                    line: 1,\n                    column: 22\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 24\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 24\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 24\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 24\n    }\n  }\n});\n\ntest(\"x = { get 10() {} }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Literal\",\n                value: 10,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 12\n                  }\n                }\n              },\n              kind: \"get\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 15\n                    },\n                    end: {\n                      line: 1,\n                      column: 17\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 12\n                  },\n                  end: {\n                    line: 1,\n                    column: 17\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 19\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 19\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 19\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 19\n    }\n  }\n});\n\ntest(\"x = { set width(w) { m_width = w } }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"width\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 15\n                  }\n                }\n              },\n              kind: \"set\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [\n                  {\n                    type: \"Identifier\",\n                    name: \"w\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 16\n                      },\n                      end: {\n                        line: 1,\n                        column: 17\n                      }\n                    }\n                  }\n                ],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [\n                    {\n                      type: \"ExpressionStatement\",\n                      expression: {\n                        type: \"AssignmentExpression\",\n                        operator: \"=\",\n                        left: {\n                          type: \"Identifier\",\n                          name: \"m_width\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 21\n                            },\n                            end: {\n                              line: 1,\n                              column: 28\n                            }\n                          }\n                        },\n                        right: {\n                          type: \"Identifier\",\n                          name: \"w\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 31\n                            },\n                            end: {\n                              line: 1,\n                              column: 32\n                            }\n                          }\n                        },\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 21\n                          },\n                          end: {\n                            line: 1,\n                            column: 32\n                          }\n                        }\n                      },\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 21\n                        },\n                        end: {\n                          line: 1,\n                          column: 32\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 19\n                    },\n                    end: {\n                      line: 1,\n                      column: 34\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 15\n                  },\n                  end: {\n                    line: 1,\n                    column: 34\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 36\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 36\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 36\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 36\n    }\n  }\n});\n\ntest(\"x = { set if(w) { m_if = w } }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"if\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 12\n                  }\n                }\n              },\n              kind: \"set\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [\n                  {\n                    type: \"Identifier\",\n                    name: \"w\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 13\n                      },\n                      end: {\n                        line: 1,\n                        column: 14\n                      }\n                    }\n                  }\n                ],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [\n                    {\n                      type: \"ExpressionStatement\",\n                      expression: {\n                        type: \"AssignmentExpression\",\n                        operator: \"=\",\n                        left: {\n                          type: \"Identifier\",\n                          name: \"m_if\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 18\n                            },\n                            end: {\n                              line: 1,\n                              column: 22\n                            }\n                          }\n                        },\n                        right: {\n                          type: \"Identifier\",\n                          name: \"w\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 25\n                            },\n                            end: {\n                              line: 1,\n                              column: 26\n                            }\n                          }\n                        },\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 18\n                          },\n                          end: {\n                            line: 1,\n                            column: 26\n                          }\n                        }\n                      },\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 18\n                        },\n                        end: {\n                          line: 1,\n                          column: 26\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 16\n                    },\n                    end: {\n                      line: 1,\n                      column: 28\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 12\n                  },\n                  end: {\n                    line: 1,\n                    column: 28\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 30\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 30\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 30\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 30\n    }\n  }\n});\n\ntest(\"x = { set true(w) { m_true = w } }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"true\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 14\n                  }\n                }\n              },\n              kind: \"set\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [\n                  {\n                    type: \"Identifier\",\n                    name: \"w\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 15\n                      },\n                      end: {\n                        line: 1,\n                        column: 16\n                      }\n                    }\n                  }\n                ],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [\n                    {\n                      type: \"ExpressionStatement\",\n                      expression: {\n                        type: \"AssignmentExpression\",\n                        operator: \"=\",\n                        left: {\n                          type: \"Identifier\",\n                          name: \"m_true\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 20\n                            },\n                            end: {\n                              line: 1,\n                              column: 26\n                            }\n                          }\n                        },\n                        right: {\n                          type: \"Identifier\",\n                          name: \"w\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 29\n                            },\n                            end: {\n                              line: 1,\n                              column: 30\n                            }\n                          }\n                        },\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 20\n                          },\n                          end: {\n                            line: 1,\n                            column: 30\n                          }\n                        }\n                      },\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 20\n                        },\n                        end: {\n                          line: 1,\n                          column: 30\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 18\n                    },\n                    end: {\n                      line: 1,\n                      column: 32\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 14\n                  },\n                  end: {\n                    line: 1,\n                    column: 32\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 34\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 34\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 34\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 34\n    }\n  }\n});\n\ntest(\"x = { set false(w) { m_false = w } }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"false\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 15\n                  }\n                }\n              },\n              kind: \"set\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [\n                  {\n                    type: \"Identifier\",\n                    name: \"w\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 16\n                      },\n                      end: {\n                        line: 1,\n                        column: 17\n                      }\n                    }\n                  }\n                ],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [\n                    {\n                      type: \"ExpressionStatement\",\n                      expression: {\n                        type: \"AssignmentExpression\",\n                        operator: \"=\",\n                        left: {\n                          type: \"Identifier\",\n                          name: \"m_false\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 21\n                            },\n                            end: {\n                              line: 1,\n                              column: 28\n                            }\n                          }\n                        },\n                        right: {\n                          type: \"Identifier\",\n                          name: \"w\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 31\n                            },\n                            end: {\n                              line: 1,\n                              column: 32\n                            }\n                          }\n                        },\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 21\n                          },\n                          end: {\n                            line: 1,\n                            column: 32\n                          }\n                        }\n                      },\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 21\n                        },\n                        end: {\n                          line: 1,\n                          column: 32\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 19\n                    },\n                    end: {\n                      line: 1,\n                      column: 34\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 15\n                  },\n                  end: {\n                    line: 1,\n                    column: 34\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 36\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 36\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 36\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 36\n    }\n  }\n});\n\ntest(\"x = { set null(w) { m_null = w } }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"null\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 14\n                  }\n                }\n              },\n              kind: \"set\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [\n                  {\n                    type: \"Identifier\",\n                    name: \"w\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 15\n                      },\n                      end: {\n                        line: 1,\n                        column: 16\n                      }\n                    }\n                  }\n                ],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [\n                    {\n                      type: \"ExpressionStatement\",\n                      expression: {\n                        type: \"AssignmentExpression\",\n                        operator: \"=\",\n                        left: {\n                          type: \"Identifier\",\n                          name: \"m_null\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 20\n                            },\n                            end: {\n                              line: 1,\n                              column: 26\n                            }\n                          }\n                        },\n                        right: {\n                          type: \"Identifier\",\n                          name: \"w\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 29\n                            },\n                            end: {\n                              line: 1,\n                              column: 30\n                            }\n                          }\n                        },\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 20\n                          },\n                          end: {\n                            line: 1,\n                            column: 30\n                          }\n                        }\n                      },\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 20\n                        },\n                        end: {\n                          line: 1,\n                          column: 30\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 18\n                    },\n                    end: {\n                      line: 1,\n                      column: 32\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 14\n                  },\n                  end: {\n                    line: 1,\n                    column: 32\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 34\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 34\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 34\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 34\n    }\n  }\n});\n\ntest(\"x = { set \\\"null\\\"(w) { m_null = w } }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Literal\",\n                value: \"null\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 16\n                  }\n                }\n              },\n              kind: \"set\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [\n                  {\n                    type: \"Identifier\",\n                    name: \"w\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 17\n                      },\n                      end: {\n                        line: 1,\n                        column: 18\n                      }\n                    }\n                  }\n                ],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [\n                    {\n                      type: \"ExpressionStatement\",\n                      expression: {\n                        type: \"AssignmentExpression\",\n                        operator: \"=\",\n                        left: {\n                          type: \"Identifier\",\n                          name: \"m_null\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 22\n                            },\n                            end: {\n                              line: 1,\n                              column: 28\n                            }\n                          }\n                        },\n                        right: {\n                          type: \"Identifier\",\n                          name: \"w\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 31\n                            },\n                            end: {\n                              line: 1,\n                              column: 32\n                            }\n                          }\n                        },\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 22\n                          },\n                          end: {\n                            line: 1,\n                            column: 32\n                          }\n                        }\n                      },\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 22\n                        },\n                        end: {\n                          line: 1,\n                          column: 32\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 20\n                    },\n                    end: {\n                      line: 1,\n                      column: 34\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 16\n                  },\n                  end: {\n                    line: 1,\n                    column: 34\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 36\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 36\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 36\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 36\n    }\n  }\n});\n\ntest(\"x = { set 10(w) { m_null = w } }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Literal\",\n                value: 10,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 12\n                  }\n                }\n              },\n              kind: \"set\",\n              value: {\n                type: \"FunctionExpression\",\n                id: null,\n                params: [\n                  {\n                    type: \"Identifier\",\n                    name: \"w\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 13\n                      },\n                      end: {\n                        line: 1,\n                        column: 14\n                      }\n                    }\n                  }\n                ],\n                body: {\n                  type: \"BlockStatement\",\n                  body: [\n                    {\n                      type: \"ExpressionStatement\",\n                      expression: {\n                        type: \"AssignmentExpression\",\n                        operator: \"=\",\n                        left: {\n                          type: \"Identifier\",\n                          name: \"m_null\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 18\n                            },\n                            end: {\n                              line: 1,\n                              column: 24\n                            }\n                          }\n                        },\n                        right: {\n                          type: \"Identifier\",\n                          name: \"w\",\n                          loc: {\n                            start: {\n                              line: 1,\n                              column: 27\n                            },\n                            end: {\n                              line: 1,\n                              column: 28\n                            }\n                          }\n                        },\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 18\n                          },\n                          end: {\n                            line: 1,\n                            column: 28\n                          }\n                        }\n                      },\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 18\n                        },\n                        end: {\n                          line: 1,\n                          column: 28\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 16\n                    },\n                    end: {\n                      line: 1,\n                      column: 30\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 12\n                  },\n                  end: {\n                    line: 1,\n                    column: 30\n                  }\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 32\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 32\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 32\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 32\n    }\n  }\n});\n\ntest(\"x = { get: 42 }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"get\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 9\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 42,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 11\n                  },\n                  end: {\n                    line: 1,\n                    column: 13\n                  }\n                }\n              },\n              kind: \"init\"\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 15\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 15\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 15\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 15\n    }\n  }\n});\n\ntest(\"x = { set: 43 }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"ObjectExpression\",\n          properties: [\n            {\n              type: \"Property\",\n              key: {\n                type: \"Identifier\",\n                name: \"set\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 9\n                  }\n                }\n              },\n              value: {\n                type: \"Literal\",\n                value: 43,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 11\n                  },\n                  end: {\n                    line: 1,\n                    column: 13\n                  }\n                }\n              },\n              kind: \"init\"\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 15\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 15\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 15\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 15\n    }\n  }\n});\n\ntest(\"/* block comment */ 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 1,\n            column: 20\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 20\n        },\n        end: {\n          line: 1,\n          column: 22\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 22\n    }\n  }\n});\n\ntest(\"42 /*The*/ /*Answer*/\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 21\n    }\n  }\n});\n\ntest(\"42 /*the*/ /*answer*/\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 21\n    }\n  }\n});\n\ntest(\"/* multiline\\ncomment\\nshould\\nbe\\nignored */ 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 5,\n            column: 11\n          },\n          end: {\n            line: 5,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 5,\n          column: 11\n        },\n        end: {\n          line: 5,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 5,\n      column: 13\n    }\n  }\n});\n\ntest(\"/*a\\r\\nb*/ 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 2,\n            column: 4\n          },\n          end: {\n            line: 2,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 2,\n          column: 4\n        },\n        end: {\n          line: 2,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 6\n    }\n  }\n});\n\ntest(\"/*a\\rb*/ 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 2,\n            column: 4\n          },\n          end: {\n            line: 2,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 2,\n          column: 4\n        },\n        end: {\n          line: 2,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 6\n    }\n  }\n});\n\ntest(\"/*a\\nb*/ 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 2,\n            column: 4\n          },\n          end: {\n            line: 2,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 2,\n          column: 4\n        },\n        end: {\n          line: 2,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 6\n    }\n  }\n});\n\ntest(\"/*a\\nc*/ 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 2,\n            column: 4\n          },\n          end: {\n            line: 2,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 2,\n          column: 4\n        },\n        end: {\n          line: 2,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 6\n    }\n  }\n});\n\ntest(\"// line comment\\n42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 2,\n            column: 0\n          },\n          end: {\n            line: 2,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 2,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 2\n    }\n  }\n});\n\ntest(\"42 // line comment\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 18\n    }\n  }\n});\n\ntest(\"// Hello, world!\\n42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 2,\n            column: 0\n          },\n          end: {\n            line: 2,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 2,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 2\n    }\n  }\n});\n\ntest(\"// Hello, world!\\n\", {\n  type: \"Program\",\n  body: [],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 0\n    }\n  }\n});\n\ntest(\"// Hallo, world!\\n\", {\n  type: \"Program\",\n  body: [],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 0\n    }\n  }\n});\n\ntest(\"//\\n42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 2,\n            column: 0\n          },\n          end: {\n            line: 2,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 2,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 2\n    }\n  }\n});\n\ntest(\"//\", {\n  type: \"Program\",\n  body: [],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 2\n    }\n  }\n});\n\ntest(\"// \", {\n  type: \"Program\",\n  body: [],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 3\n    }\n  }\n});\n\ntest(\"/**/42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 4\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"// Hello, world!\\n\\n//   Another hello\\n42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 4,\n            column: 0\n          },\n          end: {\n            line: 4,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 4,\n          column: 0\n        },\n        end: {\n          line: 4,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 4,\n      column: 2\n    }\n  }\n});\n\ntest(\"if (x) { // Some comment\\ndoThat(); }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"IfStatement\",\n      test: {\n        type: \"Identifier\",\n        name: \"x\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      consequent: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"CallExpression\",\n              callee: {\n                type: \"Identifier\",\n                name: \"doThat\",\n                loc: {\n                  start: {\n                    line: 2,\n                    column: 0\n                  },\n                  end: {\n                    line: 2,\n                    column: 6\n                  }\n                }\n              },\n              arguments: [],\n              loc: {\n                start: {\n                  line: 2,\n                  column: 0\n                },\n                end: {\n                  line: 2,\n                  column: 8\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 9\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 2,\n            column: 11\n          }\n        }\n      },\n      alternate: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 11\n    }\n  }\n});\n\ntest(\"switch (answer) { case 42: /* perfect */ bingo() }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"SwitchStatement\",\n      discriminant: {\n        type: \"Identifier\",\n        name: \"answer\",\n        loc: {\n          start: {\n            line: 1,\n            column: 8\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      cases: [\n        {\n          type: \"SwitchCase\",\n          consequent: [\n            {\n              type: \"ExpressionStatement\",\n              expression: {\n                type: \"CallExpression\",\n                callee: {\n                  type: \"Identifier\",\n                  name: \"bingo\",\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 41\n                    },\n                    end: {\n                      line: 1,\n                      column: 46\n                    }\n                  }\n                },\n                arguments: [],\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 41\n                  },\n                  end: {\n                    line: 1,\n                    column: 48\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 41\n                },\n                end: {\n                  line: 1,\n                  column: 48\n                }\n              }\n            }\n          ],\n          test: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 23\n              },\n              end: {\n                line: 1,\n                column: 25\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 18\n            },\n            end: {\n              line: 1,\n              column: 48\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 50\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 50\n    }\n  }\n});\n\ntest(\"0\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 0,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 1\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 1\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 1\n    }\n  }\n});\n\ntest(\"3\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 3,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 1\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 1\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 1\n    }\n  }\n});\n\ntest(\"5\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 5,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 1\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 1\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 1\n    }\n  }\n});\n\ntest(\"42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 42,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 2\n    }\n  }\n});\n\ntest(\".14\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 0.14,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 3\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 3\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 3\n    }\n  }\n});\n\ntest(\"3.14159\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 3.14159,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"6.02214179e+23\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 6.02214179e+23,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"1.492417830e-10\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 1.49241783e-10,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 15\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 15\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 15\n    }\n  }\n});\n\ntest(\"0x0\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 0,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 3\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 3\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 3\n    }\n  }\n});\n\ntest(\"0e+100\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 0,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"0xabc\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 2748,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"0xdef\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 3567,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"0X1A\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 26,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 4\n    }\n  }\n});\n\ntest(\"0x10\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 16,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 4\n    }\n  }\n});\n\ntest(\"0x100\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 256,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"0X04\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 4,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 4\n    }\n  }\n});\n\ntest(\"02\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 2,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 2\n    }\n  }\n});\n\ntest(\"012\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 10,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 3\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 3\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 3\n    }\n  }\n});\n\ntest(\"0012\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: 10,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 4\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"\\\"\\\\n\\\\r\\\\t\\\\v\\\\b\\\\f\\\\\\\\\\\\'\\\\\\\"\\\\0\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"\\n\\r\\t\\u000b\\b\\f\\\\'\\\"\\u0000\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 22\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 22\n    }\n  }\n});\n\ntest(\"\\\"\\\\u0061\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"a\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 8\n    }\n  }\n});\n\ntest(\"\\\"\\\\x61\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"a\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\nworld\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello\\nworld\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\\\nworld\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Helloworld\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 2,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 6\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\\\u2028world\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Helloworld\",\n        raw: \"\\\"Hello\\\\\\u2028world\\\"\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\\\u2029world\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Helloworld\",\n        raw: \"\\\"Hello\\\\\\u2029world\\\"\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\02World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello\\u0002World\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 15\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 15\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 15\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\012World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello\\nWorld\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\122World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"HelloRWorld\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\0122World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello\\n2World\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 17\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 17\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\312World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"HelloÊWorld\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\412World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello!2World\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\812World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello812World\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\712World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello92World\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\0World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello\\u0000World\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\\\r\\nworld\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Helloworld\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 2,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 6\n    }\n  }\n});\n\ntest(\"\\\"Hello\\\\1World\\\"\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"Hello\\u0001World\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"var x = /[a-z]/i\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: /[a-z]/i,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 16\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 16\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"var x = /[x-z]/i\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: /[x-z]/i,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 16\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 16\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"var x = /[a-c]/i\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: /[a-c]/i,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 16\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 16\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"var x = /[P QR]/i\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: /[P QR]/i,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 17\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 17\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 17\n    }\n  }\n});\n\ntest(\"var x = /foo\\\\/bar/\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: /foo\\/bar/,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 18\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 18\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 18\n    }\n  }\n});\n\ntest(\"var x = /=([^=\\\\s])+/g\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: /=([^=\\s])+/g,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 21\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 21\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 21\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 21\n    }\n  }\n});\n\ntestFail(\"var x = /[P QR]/\\\\u0067\", \"Unexpected token (1:16)\");\n\ntest(\"new Button\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"NewExpression\",\n        callee: {\n          type: \"Identifier\",\n          name: \"Button\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 10\n            }\n          }\n        },\n        arguments: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 10\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 10\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 10\n    }\n  }\n});\n\ntest(\"new Button()\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"NewExpression\",\n        callee: {\n          type: \"Identifier\",\n          name: \"Button\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 10\n            }\n          }\n        },\n        arguments: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 12\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 12\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 12\n    }\n  }\n});\n\ntest(\"new new foo\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"NewExpression\",\n        callee: {\n          type: \"NewExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"foo\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }\n          },\n          arguments: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        arguments: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"new new foo()\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"NewExpression\",\n        callee: {\n          type: \"NewExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"foo\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }\n          },\n          arguments: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        arguments: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 13\n    }\n  }\n});\n\ntest(\"new foo().bar()\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"NewExpression\",\n            callee: {\n              type: \"Identifier\",\n              name: \"foo\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 4\n                },\n                end: {\n                  line: 1,\n                  column: 7\n                }\n              }\n            },\n            arguments: [],\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"bar\",\n            loc: {\n              start: {\n                line: 1,\n                column: 10\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          computed: false,\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        arguments: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 15\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 15\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 15\n    }\n  }\n});\n\ntest(\"new foo[bar]\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"NewExpression\",\n        callee: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"Identifier\",\n            name: \"foo\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 7\n              }\n            }\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"bar\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }\n          },\n          computed: true,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        },\n        arguments: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 12\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 12\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 12\n    }\n  }\n});\n\ntest(\"new foo.bar()\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"NewExpression\",\n        callee: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"Identifier\",\n            name: \"foo\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 7\n              }\n            }\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"bar\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }\n          },\n          computed: false,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        arguments: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 13\n    }\n  }\n});\n\ntest(\"( new foo).bar()\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"NewExpression\",\n            callee: {\n              type: \"Identifier\",\n              name: \"foo\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 6\n                },\n                end: {\n                  line: 1,\n                  column: 9\n                }\n              }\n            },\n            arguments: [],\n            loc: {\n              start: {\n                line: 1,\n                column: 2\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"bar\",\n            loc: {\n              start: {\n                line: 1,\n                column: 11\n              },\n              end: {\n                line: 1,\n                column: 14\n              }\n            }\n          },\n          computed: false,\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 14\n            }\n          }\n        },\n        arguments: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 16\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 16\n    }\n  }\n});\n\ntest(\"foo(bar, baz)\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"Identifier\",\n          name: \"foo\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 3\n            }\n          }\n        },\n        arguments: [\n          {\n            type: \"Identifier\",\n            name: \"bar\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 7\n              }\n            }\n          },\n          {\n            type: \"Identifier\",\n            name: \"baz\",\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 12\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 13\n    }\n  }\n});\n\ntest(\"(    foo  )()\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"Identifier\",\n          name: \"foo\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        arguments: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 13\n    }\n  }\n});\n\ntest(\"universe.milkyway\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"Identifier\",\n          name: \"universe\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"milkyway\",\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 17\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 17\n    }\n  }\n});\n\ntest(\"universe.milkyway.solarsystem\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"Identifier\",\n            name: \"universe\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"milkyway\",\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 17\n              }\n            }\n          },\n          computed: false,\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"solarsystem\",\n          loc: {\n            start: {\n              line: 1,\n              column: 18\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 29\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 29\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 29\n    }\n  }\n});\n\ntest(\"universe.milkyway.solarsystem.Earth\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"MemberExpression\",\n            object: {\n              type: \"Identifier\",\n              name: \"universe\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 0\n                },\n                end: {\n                  line: 1,\n                  column: 8\n                }\n              }\n            },\n            property: {\n              type: \"Identifier\",\n              name: \"milkyway\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 17\n                }\n              }\n            },\n            computed: false,\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 17\n              }\n            }\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"solarsystem\",\n            loc: {\n              start: {\n                line: 1,\n                column: 18\n              },\n              end: {\n                line: 1,\n                column: 29\n              }\n            }\n          },\n          computed: false,\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"Earth\",\n          loc: {\n            start: {\n              line: 1,\n              column: 30\n            },\n            end: {\n              line: 1,\n              column: 35\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 35\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 35\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 35\n    }\n  }\n});\n\ntest(\"universe[galaxyName, otherUselessName]\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"Identifier\",\n          name: \"universe\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        property: {\n          type: \"SequenceExpression\",\n          expressions: [\n            {\n              type: \"Identifier\",\n              name: \"galaxyName\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 19\n                }\n              }\n            },\n            {\n              type: \"Identifier\",\n              name: \"otherUselessName\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 21\n                },\n                end: {\n                  line: 1,\n                  column: 37\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 37\n            }\n          }\n        },\n        computed: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 38\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 38\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 38\n    }\n  }\n});\n\ntest(\"universe[galaxyName]\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"Identifier\",\n          name: \"universe\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"galaxyName\",\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 19\n            }\n          }\n        },\n        computed: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 20\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 20\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 20\n    }\n  }\n});\n\ntest(\"universe[42].galaxies\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"Identifier\",\n            name: \"universe\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }\n          },\n          property: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }\n          },\n          computed: true,\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"galaxies\",\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 21\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 21\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 21\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 21\n    }\n  }\n});\n\ntest(\"universe(42).galaxies\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"universe\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }\n          },\n          arguments: [\n            {\n              type: \"Literal\",\n              value: 42,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 11\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"galaxies\",\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 21\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 21\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 21\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 21\n    }\n  }\n});\n\ntest(\"universe(42).galaxies(14, 3, 77).milkyway\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"MemberExpression\",\n            object: {\n              type: \"CallExpression\",\n              callee: {\n                type: \"Identifier\",\n                name: \"universe\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 0\n                  },\n                  end: {\n                    line: 1,\n                    column: 8\n                  }\n                }\n              },\n              arguments: [\n                {\n                  type: \"Literal\",\n                  value: 42,\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 9\n                    },\n                    end: {\n                      line: 1,\n                      column: 11\n                    }\n                  }\n                }\n              ],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 0\n                },\n                end: {\n                  line: 1,\n                  column: 12\n                }\n              }\n            },\n            property: {\n              type: \"Identifier\",\n              name: \"galaxies\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 21\n                }\n              }\n            },\n            computed: false,\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 21\n              }\n            }\n          },\n          arguments: [\n            {\n              type: \"Literal\",\n              value: 14,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 22\n                },\n                end: {\n                  line: 1,\n                  column: 24\n                }\n              }\n            },\n            {\n              type: \"Literal\",\n              value: 3,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 26\n                },\n                end: {\n                  line: 1,\n                  column: 27\n                }\n              }\n            },\n            {\n              type: \"Literal\",\n              value: 77,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 29\n                },\n                end: {\n                  line: 1,\n                  column: 31\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 32\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"milkyway\",\n          loc: {\n            start: {\n              line: 1,\n              column: 33\n            },\n            end: {\n              line: 1,\n              column: 41\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 41\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 41\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 41\n    }\n  }\n});\n\ntest(\"earth.asia.Indonesia.prepareForElection(2014)\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"MemberExpression\",\n            object: {\n              type: \"MemberExpression\",\n              object: {\n                type: \"Identifier\",\n                name: \"earth\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 0\n                  },\n                  end: {\n                    line: 1,\n                    column: 5\n                  }\n                }\n              },\n              property: {\n                type: \"Identifier\",\n                name: \"asia\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 10\n                  }\n                }\n              },\n              computed: false,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 0\n                },\n                end: {\n                  line: 1,\n                  column: 10\n                }\n              }\n            },\n            property: {\n              type: \"Identifier\",\n              name: \"Indonesia\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 11\n                },\n                end: {\n                  line: 1,\n                  column: 20\n                }\n              }\n            },\n            computed: false,\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"prepareForElection\",\n            loc: {\n              start: {\n                line: 1,\n                column: 21\n              },\n              end: {\n                line: 1,\n                column: 39\n              }\n            }\n          },\n          computed: false,\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 39\n            }\n          }\n        },\n        arguments: [\n          {\n            type: \"Literal\",\n            value: 2014,\n            loc: {\n              start: {\n                line: 1,\n                column: 40\n              },\n              end: {\n                line: 1,\n                column: 44\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 45\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 45\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 45\n    }\n  }\n});\n\ntest(\"universe.if\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"Identifier\",\n          name: \"universe\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"if\",\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"universe.true\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"Identifier\",\n          name: \"universe\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"true\",\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 13\n    }\n  }\n});\n\ntest(\"universe.false\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"Identifier\",\n          name: \"universe\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"false\",\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 14\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"universe.null\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"MemberExpression\",\n        object: {\n          type: \"Identifier\",\n          name: \"universe\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        property: {\n          type: \"Identifier\",\n          name: \"null\",\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        computed: false,\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 13\n    }\n  }\n});\n\ntest(\"x++\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"++\",\n        prefix: false,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 3\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 3\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 3\n    }\n  }\n});\n\ntest(\"x--\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"--\",\n        prefix: false,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 3\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 3\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 3\n    }\n  }\n});\n\ntest(\"eval++\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"++\",\n        prefix: false,\n        argument: {\n          type: \"Identifier\",\n          name: \"eval\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 4\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"eval--\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"--\",\n        prefix: false,\n        argument: {\n          type: \"Identifier\",\n          name: \"eval\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 4\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"arguments++\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"++\",\n        prefix: false,\n        argument: {\n          type: \"Identifier\",\n          name: \"arguments\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"arguments--\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"--\",\n        prefix: false,\n        argument: {\n          type: \"Identifier\",\n          name: \"arguments\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"++x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"++\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 3\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 3\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 3\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 3\n    }\n  }\n});\n\ntest(\"--x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"--\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 3\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 3\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 3\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 3\n    }\n  }\n});\n\ntest(\"++eval\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"++\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"eval\",\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"--eval\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"--\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"eval\",\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"++arguments\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"++\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"arguments\",\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"--arguments\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UpdateExpression\",\n        operator: \"--\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"arguments\",\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"+x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UnaryExpression\",\n        operator: \"+\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 2\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 2\n    }\n  }\n});\n\ntest(\"-x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UnaryExpression\",\n        operator: \"-\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 2\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 2\n    }\n  }\n});\n\ntest(\"~x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UnaryExpression\",\n        operator: \"~\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 2\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 2\n    }\n  }\n});\n\ntest(\"!x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UnaryExpression\",\n        operator: \"!\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 1,\n              column: 2\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 2\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 2\n    }\n  }\n});\n\ntest(\"void x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UnaryExpression\",\n        operator: \"void\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"delete x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UnaryExpression\",\n        operator: \"delete\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 7\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 8\n    }\n  }\n});\n\ntest(\"typeof x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"UnaryExpression\",\n        operator: \"typeof\",\n        prefix: true,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 7\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 8\n    }\n  }\n});\n\ntest(\"x * y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"*\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x / y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"/\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x % y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"%\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x + y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"+\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x - y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"-\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x << y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"<<\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x >> y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \">>\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x >>> y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \">>>\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x < y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"<\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x > y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \">\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x <= y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"<=\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x >= y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \">=\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x in y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"in\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x instanceof y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"instanceof\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 14\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"x < y < z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"<\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"<\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x == y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"==\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x != y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"!=\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x === y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"===\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x !== y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"!==\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x & y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"&\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x ^ y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"^\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x | y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"|\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"x + y + z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"+\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"+\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x - y + z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"-\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"+\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x + y - z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"+\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"-\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x - y - z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"-\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"-\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x + y * z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"+\",\n        right: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          operator: \"*\",\n          right: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x + y / z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"+\",\n        right: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          operator: \"/\",\n          right: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x - y % z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"-\",\n        right: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          operator: \"%\",\n          right: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x * y * z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"*\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"*\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x * y / z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"*\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"/\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x * y % z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"*\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"%\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x % y * z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"%\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"*\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x << y << z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"<<\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 5\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        operator: \"<<\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 10\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"x | y | z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"|\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"|\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x & y & z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"&\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"&\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x ^ y ^ z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"^\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"^\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x & y | z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"&\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        operator: \"|\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x | y ^ z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"|\",\n        right: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          operator: \"^\",\n          right: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x | y & z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"|\",\n        right: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          operator: \"&\",\n          right: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x || y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"LogicalExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"||\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x && y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"LogicalExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"&&\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"x || y || z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"LogicalExpression\",\n        left: {\n          type: \"LogicalExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"||\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 5\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        operator: \"||\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 10\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"x && y && z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"LogicalExpression\",\n        left: {\n          type: \"LogicalExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"&&\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 5\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        operator: \"&&\",\n        right: {\n          type: \"Identifier\",\n          name: \"z\",\n          loc: {\n            start: {\n              line: 1,\n              column: 10\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"x || y && z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"LogicalExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"||\",\n        right: {\n          type: \"LogicalExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 5\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          operator: \"&&\",\n          right: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 10\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"x || y ^ z\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"LogicalExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        operator: \"||\",\n        right: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 5\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          operator: \"^\",\n          right: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 10\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 10\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 10\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 10\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 10\n    }\n  }\n});\n\ntest(\"y ? 1 : 2\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"ConditionalExpression\",\n        test: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        consequent: {\n          type: \"Literal\",\n          value: 1,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        alternate: {\n          type: \"Literal\",\n          value: 2,\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x && y ? 1 : 2\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"ConditionalExpression\",\n        test: {\n          type: \"LogicalExpression\",\n          left: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          operator: \"&&\",\n          right: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 5\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        consequent: {\n          type: \"Literal\",\n          value: 1,\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 10\n            }\n          }\n        },\n        alternate: {\n          type: \"Literal\",\n          value: 2,\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 14\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"x = 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 6\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"eval = 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"eval\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 4\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 7\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"arguments = 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"arguments\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 12\n            },\n            end: {\n              line: 1,\n              column: 14\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"x *= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"*=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x /= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"/=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x %= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"%=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x += 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"+=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x -= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"-=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x <<= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"<<=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 8\n    }\n  }\n});\n\ntest(\"x >>= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \">>=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 8\n    }\n  }\n});\n\ntest(\"x >>>= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \">>>=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 7\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"x &= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"&=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x ^= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"^=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"x |= 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"|=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 1\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 5\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"{ foo }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"Identifier\",\n            name: \"foo\",\n            loc: {\n              start: {\n                line: 1,\n                column: 2\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"{ doThis(); doThat(); }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"CallExpression\",\n            callee: {\n              type: \"Identifier\",\n              name: \"doThis\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 2\n                },\n                end: {\n                  line: 1,\n                  column: 8\n                }\n              }\n            },\n            arguments: [],\n            loc: {\n              start: {\n                line: 1,\n                column: 2\n              },\n              end: {\n                line: 1,\n                column: 10\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"CallExpression\",\n            callee: {\n              type: \"Identifier\",\n              name: \"doThat\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 12\n                },\n                end: {\n                  line: 1,\n                  column: 18\n                }\n              }\n            },\n            arguments: [],\n            loc: {\n              start: {\n                line: 1,\n                column: 12\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 12\n            },\n            end: {\n              line: 1,\n              column: 21\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 23\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 23\n    }\n  }\n});\n\ntest(\"{}\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 2\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 2\n    }\n  }\n});\n\ntest(\"var x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n});\n\ntest(\"var await\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"await\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"var x, y;\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 7\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 7\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"var x = 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 10\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 10\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 10\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 10\n    }\n  }\n});\n\ntest(\"var eval = 42, arguments = 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"eval\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 11\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"arguments\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 24\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 27\n              },\n              end: {\n                line: 1,\n                column: 29\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 29\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 29\n    }\n  }\n});\n\ntest(\"var x = 14, y = 3, z = 1977\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 14,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 10\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 10\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 12\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 3,\n            loc: {\n              start: {\n                line: 1,\n                column: 16\n              },\n              end: {\n                line: 1,\n                column: 17\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 12\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 19\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 1977,\n            loc: {\n              start: {\n                line: 1,\n                column: 23\n              },\n              end: {\n                line: 1,\n                column: 27\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 27\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 27\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 27\n    }\n  }\n});\n\ntest(\"var implements, interface, package\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"implements\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 14\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 14\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"interface\",\n            loc: {\n              start: {\n                line: 1,\n                column: 16\n              },\n              end: {\n                line: 1,\n                column: 25\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 16\n            },\n            end: {\n              line: 1,\n              column: 25\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"package\",\n            loc: {\n              start: {\n                line: 1,\n                column: 27\n              },\n              end: {\n                line: 1,\n                column: 34\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 27\n            },\n            end: {\n              line: 1,\n              column: 34\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 34\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 34\n    }\n  }\n});\n\ntest(\"var private, protected, public, static\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"private\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 11\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"protected\",\n            loc: {\n              start: {\n                line: 1,\n                column: 13\n              },\n              end: {\n                line: 1,\n                column: 22\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 22\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"public\",\n            loc: {\n              start: {\n                line: 1,\n                column: 24\n              },\n              end: {\n                line: 1,\n                column: 30\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 24\n            },\n            end: {\n              line: 1,\n              column: 30\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"static\",\n            loc: {\n              start: {\n                line: 1,\n                column: 32\n              },\n              end: {\n                line: 1,\n                column: 38\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 32\n            },\n            end: {\n              line: 1,\n              column: 38\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 38\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 38\n    }\n  }\n});\n\ntest(\";\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"EmptyStatement\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 1\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 1\n    }\n  }\n});\n\ntest(\"x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Identifier\",\n        name: \"x\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 1\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 1\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 1\n    }\n  }\n});\n\ntest(\"x, y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"SequenceExpression\",\n        expressions: [\n          {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 0\n              },\n              end: {\n                line: 1,\n                column: 1\n              }\n            }\n          },\n          {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 3\n              },\n              end: {\n                line: 1,\n                column: 4\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 4\n    }\n  }\n});\n\ntest(\"\\\\u0061\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Identifier\",\n        name: \"a\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 6\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 6\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 6\n    }\n  }\n});\n\ntest(\"a\\\\u0061\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Identifier\",\n        name: \"aa\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 7\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 7\n    }\n  }\n});\n\ntest(\"if (morning) goodMorning()\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"IfStatement\",\n      test: {\n        type: \"Identifier\",\n        name: \"morning\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      consequent: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"goodMorning\",\n            loc: {\n              start: {\n                line: 1,\n                column: 13\n              },\n              end: {\n                line: 1,\n                column: 24\n              }\n            }\n          },\n          arguments: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 26\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 26\n          }\n        }\n      },\n      alternate: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 26\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 26\n    }\n  }\n});\n\ntest(\"if (morning) (function(){})\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"IfStatement\",\n      test: {\n        type: \"Identifier\",\n        name: \"morning\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      consequent: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"FunctionExpression\",\n          id: null,\n          params: [],\n          body: {\n            type: \"BlockStatement\",\n            body: [],\n            loc: {\n              start: {\n                line: 1,\n                column: 24\n              },\n              end: {\n                line: 1,\n                column: 26\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 14\n            },\n            end: {\n              line: 1,\n              column: 26\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 27\n          }\n        }\n      },\n      alternate: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 27\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 27\n    }\n  }\n});\n\ntest(\"if (morning) var x = 0;\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"IfStatement\",\n      test: {\n        type: \"Identifier\",\n        name: \"morning\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      consequent: {\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 17\n                },\n                end: {\n                  line: 1,\n                  column: 18\n                }\n              }\n            },\n            init: {\n              type: \"Literal\",\n              value: 0,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 21\n                },\n                end: {\n                  line: 1,\n                  column: 22\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 17\n              },\n              end: {\n                line: 1,\n                column: 22\n              }\n            }\n          }\n        ],\n        kind: \"var\",\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 23\n          }\n        }\n      },\n      alternate: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 23\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 23\n    }\n  }\n});\n\ntest(\"if (morning) function a(){}\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"IfStatement\",\n      test: {\n        type: \"Identifier\",\n        name: \"morning\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      consequent: {\n        type: \"FunctionDeclaration\",\n        id: {\n          type: \"Identifier\",\n          name: \"a\",\n          loc: {\n            start: {\n              line: 1,\n              column: 22\n            },\n            end: {\n              line: 1,\n              column: 23\n            }\n          }\n        },\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 25\n            },\n            end: {\n              line: 1,\n              column: 27\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 27\n          }\n        }\n      },\n      alternate: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 27\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 27\n    }\n  }\n});\n\ntest(\"if (morning) goodMorning(); else goodDay()\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"IfStatement\",\n      test: {\n        type: \"Identifier\",\n        name: \"morning\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      consequent: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"goodMorning\",\n            loc: {\n              start: {\n                line: 1,\n                column: 13\n              },\n              end: {\n                line: 1,\n                column: 24\n              }\n            }\n          },\n          arguments: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 26\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 27\n          }\n        }\n      },\n      alternate: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"goodDay\",\n            loc: {\n              start: {\n                line: 1,\n                column: 33\n              },\n              end: {\n                line: 1,\n                column: 40\n              }\n            }\n          },\n          arguments: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 33\n            },\n            end: {\n              line: 1,\n              column: 42\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 33\n          },\n          end: {\n            line: 1,\n            column: 42\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 42\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 42\n    }\n  }\n});\n\ntest(\"do keep(); while (true)\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"DoWhileStatement\",\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"keep\",\n            loc: {\n              start: {\n                line: 1,\n                column: 3\n              },\n              end: {\n                line: 1,\n                column: 7\n              }\n            }\n          },\n          arguments: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 3\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 3\n          },\n          end: {\n            line: 1,\n            column: 10\n          }\n        }\n      },\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 18\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 23\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 23\n    }\n  }\n});\n\ntest(\"do keep(); while (true);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"DoWhileStatement\",\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"keep\",\n            loc: {\n              start: {\n                line: 1,\n                column: 3\n              },\n              end: {\n                line: 1,\n                column: 7\n              }\n            }\n          },\n          arguments: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 3\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 3\n          },\n          end: {\n            line: 1,\n            column: 10\n          }\n        }\n      },\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 18\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 24\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 24\n    }\n  }\n});\n\ntest(\"do { x++; y--; } while (x < 10)\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"DoWhileStatement\",\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"UpdateExpression\",\n              operator: \"++\",\n              prefix: false,\n              argument: {\n                type: \"Identifier\",\n                name: \"x\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 5\n                  },\n                  end: {\n                    line: 1,\n                    column: 6\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 5\n                },\n                end: {\n                  line: 1,\n                  column: 8\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 5\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"UpdateExpression\",\n              operator: \"--\",\n              prefix: false,\n              argument: {\n                type: \"Identifier\",\n                name: \"y\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 11\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 10\n                },\n                end: {\n                  line: 1,\n                  column: 13\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 10\n              },\n              end: {\n                line: 1,\n                column: 14\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 3\n          },\n          end: {\n            line: 1,\n            column: 16\n          }\n        }\n      },\n      test: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 24\n            },\n            end: {\n              line: 1,\n              column: 25\n            }\n          }\n        },\n        operator: \"<\",\n        right: {\n          type: \"Literal\",\n          value: 10,\n          loc: {\n            start: {\n              line: 1,\n              column: 28\n            },\n            end: {\n              line: 1,\n              column: 30\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 24\n          },\n          end: {\n            line: 1,\n            column: 30\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 31\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 31\n    }\n  }\n});\n\ntest(\"{ do { } while (false);false }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [\n        {\n          type: \"DoWhileStatement\",\n          body: {\n            type: \"BlockStatement\",\n            body: [],\n            loc: {\n              start: {\n                line: 1,\n                column: 5\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }\n          },\n          test: {\n            type: \"Literal\",\n            value: false,\n            loc: {\n              start: {\n                line: 1,\n                column: 16\n              },\n              end: {\n                line: 1,\n                column: 21\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 23\n            }\n          }\n        },\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"Literal\",\n            value: false,\n            loc: {\n              start: {\n                line: 1,\n                column: 23\n              },\n              end: {\n                line: 1,\n                column: 28\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 23\n            },\n            end: {\n              line: 1,\n              column: 28\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 30\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 30\n    }\n  }\n});\n\ntest(\"while (true) doSomething()\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"doSomething\",\n            loc: {\n              start: {\n                line: 1,\n                column: 13\n              },\n              end: {\n                line: 1,\n                column: 24\n              }\n            }\n          },\n          arguments: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 26\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 26\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 26\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 26\n    }\n  }\n});\n\ntest(\"while (x < 10) { x++; y--; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 7\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        },\n        operator: \"<\",\n        right: {\n          type: \"Literal\",\n          value: 10,\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"UpdateExpression\",\n              operator: \"++\",\n              prefix: false,\n              argument: {\n                type: \"Identifier\",\n                name: \"x\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 17\n                  },\n                  end: {\n                    line: 1,\n                    column: 18\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 17\n                },\n                end: {\n                  line: 1,\n                  column: 20\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 17\n              },\n              end: {\n                line: 1,\n                column: 21\n              }\n            }\n          },\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"UpdateExpression\",\n              operator: \"--\",\n              prefix: false,\n              argument: {\n                type: \"Identifier\",\n                name: \"y\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 22\n                  },\n                  end: {\n                    line: 1,\n                    column: 23\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 22\n                },\n                end: {\n                  line: 1,\n                  column: 25\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 22\n              },\n              end: {\n                line: 1,\n                column: 26\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 15\n          },\n          end: {\n            line: 1,\n            column: 28\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 28\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 28\n    }\n  }\n});\n\ntest(\"for(;;);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: null,\n      test: null,\n      update: null,\n      body: {\n        type: \"EmptyStatement\",\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 8\n    }\n  }\n});\n\ntest(\"for(;;){}\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: null,\n      test: null,\n      update: null,\n      body: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"for(x = 0;;);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 0,\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      test: null,\n      update: null,\n      body: {\n        type: \"EmptyStatement\",\n        loc: {\n          start: {\n            line: 1,\n            column: 12\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 13\n    }\n  }\n});\n\ntest(\"for(var x = 0;;);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: {\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 8\n                },\n                end: {\n                  line: 1,\n                  column: 9\n                }\n              }\n            },\n            init: {\n              type: \"Literal\",\n              value: 0,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 12\n                },\n                end: {\n                  line: 1,\n                  column: 13\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          }\n        ],\n        kind: \"var\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      test: null,\n      update: null,\n      body: {\n        type: \"EmptyStatement\",\n        loc: {\n          start: {\n            line: 1,\n            column: 16\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 17\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 17\n    }\n  }\n});\n\ntest(\"for(var x = 0, y = 1;;);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: {\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 8\n                },\n                end: {\n                  line: 1,\n                  column: 9\n                }\n              }\n            },\n            init: {\n              type: \"Literal\",\n              value: 0,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 12\n                },\n                end: {\n                  line: 1,\n                  column: 13\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"y\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 15\n                },\n                end: {\n                  line: 1,\n                  column: 16\n                }\n              }\n            },\n            init: {\n              type: \"Literal\",\n              value: 1,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 19\n                },\n                end: {\n                  line: 1,\n                  column: 20\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          }\n        ],\n        kind: \"var\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 20\n          }\n        }\n      },\n      test: null,\n      update: null,\n      body: {\n        type: \"EmptyStatement\",\n        loc: {\n          start: {\n            line: 1,\n            column: 23\n          },\n          end: {\n            line: 1,\n            column: 24\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 24\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 24\n    }\n  }\n});\n\ntest(\"for(x = 0; x < 42;);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 0,\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      test: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        },\n        operator: \"<\",\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 11\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      update: null,\n      body: {\n        type: \"EmptyStatement\",\n        loc: {\n          start: {\n            line: 1,\n            column: 19\n          },\n          end: {\n            line: 1,\n            column: 20\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 20\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 20\n    }\n  }\n});\n\ntest(\"for(x = 0; x < 42; x++);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 0,\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      test: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        },\n        operator: \"<\",\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 11\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      update: {\n        type: \"UpdateExpression\",\n        operator: \"++\",\n        prefix: false,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 20\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 19\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      body: {\n        type: \"EmptyStatement\",\n        loc: {\n          start: {\n            line: 1,\n            column: 23\n          },\n          end: {\n            line: 1,\n            column: 24\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 24\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 24\n    }\n  }\n});\n\ntest(\"for(x = 0; x < 42; x++) process(x);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        right: {\n          type: \"Literal\",\n          value: 0,\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 9\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      test: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        },\n        operator: \"<\",\n        right: {\n          type: \"Literal\",\n          value: 42,\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 11\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      update: {\n        type: \"UpdateExpression\",\n        operator: \"++\",\n        prefix: false,\n        argument: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 20\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 19\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"process\",\n            loc: {\n              start: {\n                line: 1,\n                column: 24\n              },\n              end: {\n                line: 1,\n                column: 31\n              }\n            }\n          },\n          arguments: [\n            {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 32\n                },\n                end: {\n                  line: 1,\n                  column: 33\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 24\n            },\n            end: {\n              line: 1,\n              column: 34\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 24\n          },\n          end: {\n            line: 1,\n            column: 35\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 35\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 35\n    }\n  }\n});\n\ntest(\"for(x in list) process(x);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForInStatement\",\n      left: {\n        type: \"Identifier\",\n        name: \"x\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      right: {\n        type: \"Identifier\",\n        name: \"list\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"process\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 22\n              }\n            }\n          },\n          arguments: [\n            {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 23\n                },\n                end: {\n                  line: 1,\n                  column: 24\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 25\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 15\n          },\n          end: {\n            line: 1,\n            column: 26\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 26\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 26\n    }\n  }\n});\n\ntest(\"for (var x in list) process(x);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForInStatement\",\n      left: {\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 10\n                }\n              }\n            },\n            init: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 10\n              }\n            }\n          }\n        ],\n        kind: \"var\",\n        loc: {\n          start: {\n            line: 1,\n            column: 5\n          },\n          end: {\n            line: 1,\n            column: 10\n          }\n        }\n      },\n      right: {\n        type: \"Identifier\",\n        name: \"list\",\n        loc: {\n          start: {\n            line: 1,\n            column: 14\n          },\n          end: {\n            line: 1,\n            column: 18\n          }\n        }\n      },\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"process\",\n            loc: {\n              start: {\n                line: 1,\n                column: 20\n              },\n              end: {\n                line: 1,\n                column: 27\n              }\n            }\n          },\n          arguments: [\n            {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 28\n                },\n                end: {\n                  line: 1,\n                  column: 29\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 20\n            },\n            end: {\n              line: 1,\n              column: 30\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 20\n          },\n          end: {\n            line: 1,\n            column: 31\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 31\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 31\n    }\n  }\n});\ntestFail(\"var x; for (x = 0 in list) process(x);\", \"Invalid left-hand side in for-loop (1:12)\", { ecmaVersion: 6 })\ntestFail(\"'use strict'; for (var x = 0 in list) process(x);\", \"for-in loop variable declaration may not have an initializer (1:19)\")\ntestFail(\"for (var [x] = 0 in list) process(x);\", \"for-in loop variable declaration may not have an initializer (1:5)\", { ecmaVersion: 6 })\ntestFail(\"for (var {x} = 0 in list) process(x);\", \"for-in loop variable declaration may not have an initializer (1:5)\", { ecmaVersion: 6 })\ntestFail(\"for (var x = 42 in list) process(x);\", \"for-in loop variable declaration may not have an initializer (1:5)\", { ecmaVersion: 6 })\n\ntest(\"for (var x = 42 in list) process(x);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForInStatement\",\n      left: {\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 10\n                }\n              }\n            },\n            init: {\n              type: \"Literal\",\n              value: 42,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 15\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 15\n              }\n            }\n          }\n        ],\n        kind: \"var\",\n        loc: {\n          start: {\n            line: 1,\n            column: 5\n          },\n          end: {\n            line: 1,\n            column: 15\n          }\n        }\n      },\n      right: {\n        type: \"Identifier\",\n        name: \"list\",\n        loc: {\n          start: {\n            line: 1,\n            column: 19\n          },\n          end: {\n            line: 1,\n            column: 23\n          }\n        }\n      },\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"process\",\n            loc: {\n              start: {\n                line: 1,\n                column: 25\n              },\n              end: {\n                line: 1,\n                column: 32\n              }\n            }\n          },\n          arguments: [\n            {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 33\n                },\n                end: {\n                  line: 1,\n                  column: 34\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 25\n            },\n            end: {\n              line: 1,\n              column: 35\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 25\n          },\n          end: {\n            line: 1,\n            column: 36\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 36\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 36\n    }\n  }\n}, { ecmaVersion: 8, locations: true });\n\ntest(\"for (var i = function() { return 10 in [] } in list) process(x);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForInStatement\",\n      left: {\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"i\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 10\n                }\n              }\n            },\n            init: {\n              type: \"FunctionExpression\",\n              id: null,\n              params: [],\n              body: {\n                type: \"BlockStatement\",\n                body: [\n                  {\n                    type: \"ReturnStatement\",\n                    argument: {\n                      type: \"BinaryExpression\",\n                      left: {\n                        type: \"Literal\",\n                        value: 10,\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 33\n                          },\n                          end: {\n                            line: 1,\n                            column: 35\n                          }\n                        }\n                      },\n                      operator: \"in\",\n                      right: {\n                        type: \"ArrayExpression\",\n                        elements: [],\n                        loc: {\n                          start: {\n                            line: 1,\n                            column: 39\n                          },\n                          end: {\n                            line: 1,\n                            column: 41\n                          }\n                        }\n                      },\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 33\n                        },\n                        end: {\n                          line: 1,\n                          column: 41\n                        }\n                      }\n                    },\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 26\n                      },\n                      end: {\n                        line: 1,\n                        column: 41\n                      }\n                    }\n                  }\n                ],\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 24\n                  },\n                  end: {\n                    line: 1,\n                    column: 43\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 43\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 43\n              }\n            }\n          }\n        ],\n        kind: \"var\",\n        loc: {\n          start: {\n            line: 1,\n            column: 5\n          },\n          end: {\n            line: 1,\n            column: 43\n          }\n        }\n      },\n      right: {\n        type: \"Identifier\",\n        name: \"list\",\n        loc: {\n          start: {\n            line: 1,\n            column: 47\n          },\n          end: {\n            line: 1,\n            column: 51\n          }\n        }\n      },\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"process\",\n            loc: {\n              start: {\n                line: 1,\n                column: 53\n              },\n              end: {\n                line: 1,\n                column: 60\n              }\n            }\n          },\n          arguments: [\n            {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 61\n                },\n                end: {\n                  line: 1,\n                  column: 62\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 53\n            },\n            end: {\n              line: 1,\n              column: 63\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 53\n          },\n          end: {\n            line: 1,\n            column: 64\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 64\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 64\n    }\n  }\n}, { ecmaVersion: 8, locations: true });\n\ntest(\"while (true) { continue; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ContinueStatement\",\n            label: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 24\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 26\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 26\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 26\n    }\n  }\n});\n\ntest(\"while (true) { continue }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ContinueStatement\",\n            label: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 23\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 25\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 25\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 25\n    }\n  }\n});\n\ntest(\"done: while (true) { continue done }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"LabeledStatement\",\n      body: {\n        type: \"WhileStatement\",\n        test: {\n          type: \"Literal\",\n          value: true,\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"ContinueStatement\",\n              label: {\n                type: \"Identifier\",\n                name: \"done\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 30\n                  },\n                  end: {\n                    line: 1,\n                    column: 34\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 21\n                },\n                end: {\n                  line: 1,\n                  column: 34\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 36\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 36\n          }\n        }\n      },\n      label: {\n        type: \"Identifier\",\n        name: \"done\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 36\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 36\n    }\n  }\n});\n\ntest(\"done: while (true) { continue done; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"LabeledStatement\",\n      body: {\n        type: \"WhileStatement\",\n        test: {\n          type: \"Literal\",\n          value: true,\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"ContinueStatement\",\n              label: {\n                type: \"Identifier\",\n                name: \"done\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 30\n                  },\n                  end: {\n                    line: 1,\n                    column: 34\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 21\n                },\n                end: {\n                  line: 1,\n                  column: 35\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 37\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 37\n          }\n        }\n      },\n      label: {\n        type: \"Identifier\",\n        name: \"done\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 37\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 37\n    }\n  }\n});\n\ntest(\"while (true) { break }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"BreakStatement\",\n            label: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 22\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 22\n    }\n  }\n});\n\ntest(\"done: while (true) { break done }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"LabeledStatement\",\n      body: {\n        type: \"WhileStatement\",\n        test: {\n          type: \"Literal\",\n          value: true,\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"BreakStatement\",\n              label: {\n                type: \"Identifier\",\n                name: \"done\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 27\n                  },\n                  end: {\n                    line: 1,\n                    column: 31\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 21\n                },\n                end: {\n                  line: 1,\n                  column: 31\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 33\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 33\n          }\n        }\n      },\n      label: {\n        type: \"Identifier\",\n        name: \"done\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 33\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 33\n    }\n  }\n});\n\ntest(\"done: while (true) { break done; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"LabeledStatement\",\n      body: {\n        type: \"WhileStatement\",\n        test: {\n          type: \"Literal\",\n          value: true,\n          loc: {\n            start: {\n              line: 1,\n              column: 13\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"BreakStatement\",\n              label: {\n                type: \"Identifier\",\n                name: \"done\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 27\n                  },\n                  end: {\n                    line: 1,\n                    column: 31\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 21\n                },\n                end: {\n                  line: 1,\n                  column: 32\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 34\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 34\n          }\n        }\n      },\n      label: {\n        type: \"Identifier\",\n        name: \"done\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 34\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 34\n    }\n  }\n});\n\ntest(\"done: switch (a) { default: break done }\", {\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 40,\n  \"body\": [\n    {\n      \"type\": \"LabeledStatement\",\n      \"start\": 0,\n      \"end\": 40,\n      \"body\": {\n        \"type\": \"SwitchStatement\",\n        \"start\": 6,\n        \"end\": 40,\n        \"discriminant\": {\n          \"type\": \"Identifier\",\n          \"start\": 14,\n          \"end\": 15,\n          \"name\": \"a\"\n        },\n        \"cases\": [\n          {\n            \"type\": \"SwitchCase\",\n            \"start\": 19,\n            \"end\": 38,\n            \"consequent\": [\n              {\n                \"type\": \"BreakStatement\",\n                \"start\": 28,\n                \"end\": 38,\n                \"label\": {\n                  \"type\": \"Identifier\",\n                  \"start\": 34,\n                  \"end\": 38,\n                  \"name\": \"done\"\n                }\n              }\n            ],\n            \"test\": null\n          }\n        ]\n      },\n      \"label\": {\n        \"type\": \"Identifier\",\n        \"start\": 0,\n        \"end\": 4,\n        \"name\": \"done\"\n      }\n    }\n  ]\n});\n\ntest(\"target1: target2: while (true) { continue target1; }\", {});\ntest(\"target1: target2: target3: while (true) { continue target1; }\", {});\n\ntest(\"(function(){ return })\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"FunctionExpression\",\n        id: null,\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"ReturnStatement\",\n              argument: null,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 19\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 21\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 1,\n            column: 21\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 22\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 22\n    }\n  }\n});\n\ntest(\"(function(){ return; })\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"FunctionExpression\",\n        id: null,\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"ReturnStatement\",\n              argument: null,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 20\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 22\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 23\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 23\n    }\n  }\n});\n\ntest(\"(function(){ return x; })\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"FunctionExpression\",\n        id: null,\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"ReturnStatement\",\n              argument: {\n                type: \"Identifier\",\n                name: \"x\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 20\n                  },\n                  end: {\n                    line: 1,\n                    column: 21\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 22\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 24\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 1,\n            column: 24\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 25\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 25\n    }\n  }\n});\n\ntest(\"(function(){ return x * y })\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"FunctionExpression\",\n        id: null,\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"ReturnStatement\",\n              argument: {\n                type: \"BinaryExpression\",\n                left: {\n                  type: \"Identifier\",\n                  name: \"x\",\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 20\n                    },\n                    end: {\n                      line: 1,\n                      column: 21\n                    }\n                  }\n                },\n                operator: \"*\",\n                right: {\n                  type: \"Identifier\",\n                  name: \"y\",\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 24\n                    },\n                    end: {\n                      line: 1,\n                      column: 25\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 20\n                  },\n                  end: {\n                    line: 1,\n                    column: 25\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 25\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 27\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 1,\n            column: 27\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 28\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 28\n    }\n  }\n});\n\ntest(\"with (x) foo = bar\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WithStatement\",\n      object: {\n        type: \"Identifier\",\n        name: \"x\",\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"AssignmentExpression\",\n          operator: \"=\",\n          left: {\n            type: \"Identifier\",\n            name: \"foo\",\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 12\n              }\n            }\n          },\n          right: {\n            type: \"Identifier\",\n            name: \"bar\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 18\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 18\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 18\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 18\n    }\n  }\n});\n\ntest(\"with (x) foo = bar;\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WithStatement\",\n      object: {\n        type: \"Identifier\",\n        name: \"x\",\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"AssignmentExpression\",\n          operator: \"=\",\n          left: {\n            type: \"Identifier\",\n            name: \"foo\",\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 12\n              }\n            }\n          },\n          right: {\n            type: \"Identifier\",\n            name: \"bar\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 18\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 19\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 19\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 19\n    }\n  }\n});\n\n// Test that innocuous string that evaluates to `use strict` is not promoted to\n// Use Strict directive.\ntest(\"'use\\\\x20strict'; with (x) foo = bar;\", {});\n\n// Test that innocuous string that evaluates to `use strict` is not promoted to\n// Use Strict directive.\ntest('\"use\\\\x20strict\"; with (x) foo = bar;', {});\n\ntest(\"with (x) { foo = bar }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WithStatement\",\n      object: {\n        type: \"Identifier\",\n        name: \"x\",\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"AssignmentExpression\",\n              operator: \"=\",\n              left: {\n                type: \"Identifier\",\n                name: \"foo\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 11\n                  },\n                  end: {\n                    line: 1,\n                    column: 14\n                  }\n                }\n              },\n              right: {\n                type: \"Identifier\",\n                name: \"bar\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 17\n                  },\n                  end: {\n                    line: 1,\n                    column: 20\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 11\n                },\n                end: {\n                  line: 1,\n                  column: 20\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 11\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 22\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 22\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 22\n    }\n  }\n});\n\ntest(\"switch (x) {}\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"SwitchStatement\",\n      discriminant: {\n        type: \"Identifier\",\n        name: \"x\",\n        loc: {\n          start: {\n            line: 1,\n            column: 8\n          },\n          end: {\n            line: 1,\n            column: 9\n          }\n        }\n      },\n      cases: [],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 13\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 13\n    }\n  }\n});\n\ntest(\"switch (answer) { case 42: hi(); break; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"SwitchStatement\",\n      discriminant: {\n        type: \"Identifier\",\n        name: \"answer\",\n        loc: {\n          start: {\n            line: 1,\n            column: 8\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      cases: [\n        {\n          type: \"SwitchCase\",\n          consequent: [\n            {\n              type: \"ExpressionStatement\",\n              expression: {\n                type: \"CallExpression\",\n                callee: {\n                  type: \"Identifier\",\n                  name: \"hi\",\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 27\n                    },\n                    end: {\n                      line: 1,\n                      column: 29\n                    }\n                  }\n                },\n                arguments: [],\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 27\n                  },\n                  end: {\n                    line: 1,\n                    column: 31\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 27\n                },\n                end: {\n                  line: 1,\n                  column: 32\n                }\n              }\n            },\n            {\n              type: \"BreakStatement\",\n              label: null,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 33\n                },\n                end: {\n                  line: 1,\n                  column: 39\n                }\n              }\n            }\n          ],\n          test: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 23\n              },\n              end: {\n                line: 1,\n                column: 25\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 18\n            },\n            end: {\n              line: 1,\n              column: 39\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 41\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 41\n    }\n  }\n});\n\ntest(\"switch (answer) { case 42: hi(); break; default: break }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"SwitchStatement\",\n      discriminant: {\n        type: \"Identifier\",\n        name: \"answer\",\n        loc: {\n          start: {\n            line: 1,\n            column: 8\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      cases: [\n        {\n          type: \"SwitchCase\",\n          consequent: [\n            {\n              type: \"ExpressionStatement\",\n              expression: {\n                type: \"CallExpression\",\n                callee: {\n                  type: \"Identifier\",\n                  name: \"hi\",\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 27\n                    },\n                    end: {\n                      line: 1,\n                      column: 29\n                    }\n                  }\n                },\n                arguments: [],\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 27\n                  },\n                  end: {\n                    line: 1,\n                    column: 31\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 27\n                },\n                end: {\n                  line: 1,\n                  column: 32\n                }\n              }\n            },\n            {\n              type: \"BreakStatement\",\n              label: null,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 33\n                },\n                end: {\n                  line: 1,\n                  column: 39\n                }\n              }\n            }\n          ],\n          test: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 23\n              },\n              end: {\n                line: 1,\n                column: 25\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 18\n            },\n            end: {\n              line: 1,\n              column: 39\n            }\n          }\n        },\n        {\n          type: \"SwitchCase\",\n          consequent: [\n            {\n              type: \"BreakStatement\",\n              label: null,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 49\n                },\n                end: {\n                  line: 1,\n                  column: 54\n                }\n              }\n            }\n          ],\n          test: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 40\n            },\n            end: {\n              line: 1,\n              column: 54\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 56\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 56\n    }\n  }\n});\n\ntest(\"start: for (;;) break start\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"LabeledStatement\",\n      body: {\n        type: \"ForStatement\",\n        init: null,\n        test: null,\n        update: null,\n        body: {\n          type: \"BreakStatement\",\n          label: {\n            type: \"Identifier\",\n            name: \"start\",\n            loc: {\n              start: {\n                line: 1,\n                column: 22\n              },\n              end: {\n                line: 1,\n                column: 27\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 16\n            },\n            end: {\n              line: 1,\n              column: 27\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 27\n          }\n        }\n      },\n      label: {\n        type: \"Identifier\",\n        name: \"start\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 27\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 27\n    }\n  }\n});\n\ntest(\"start: while (true) break start\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"LabeledStatement\",\n      body: {\n        type: \"WhileStatement\",\n        test: {\n          type: \"Literal\",\n          value: true,\n          loc: {\n            start: {\n              line: 1,\n              column: 14\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }\n        },\n        body: {\n          type: \"BreakStatement\",\n          label: {\n            type: \"Identifier\",\n            name: \"start\",\n            loc: {\n              start: {\n                line: 1,\n                column: 26\n              },\n              end: {\n                line: 1,\n                column: 31\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 20\n            },\n            end: {\n              line: 1,\n              column: 31\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 31\n          }\n        }\n      },\n      label: {\n        type: \"Identifier\",\n        name: \"start\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 31\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 31\n    }\n  }\n});\n\ntest(\"throw x;\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ThrowStatement\",\n      argument: {\n        type: \"Identifier\",\n        name: \"x\",\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 8\n    }\n  }\n});\n\ntest(\"throw x * y\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ThrowStatement\",\n      argument: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\",\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 7\n            }\n          }\n        },\n        operator: \"*\",\n        right: {\n          type: \"Identifier\",\n          name: \"y\",\n          loc: {\n            start: {\n              line: 1,\n              column: 10\n            },\n            end: {\n              line: 1,\n              column: 11\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 11\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 11\n    }\n  }\n});\n\ntest(\"throw { message: \\\"Error\\\" }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ThrowStatement\",\n      argument: {\n        type: \"ObjectExpression\",\n        properties: [\n          {\n            type: \"Property\",\n            key: {\n              type: \"Identifier\",\n              name: \"message\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 8\n                },\n                end: {\n                  line: 1,\n                  column: 15\n                }\n              }\n            },\n            value: {\n              type: \"Literal\",\n              value: \"Error\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 17\n                },\n                end: {\n                  line: 1,\n                  column: 24\n                }\n              }\n            },\n            kind: \"init\"\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 6\n          },\n          end: {\n            line: 1,\n            column: 26\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 26\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 26\n    }\n  }\n});\n\ntest(\"try { } catch (e) { }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"TryStatement\",\n      block: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      handler: {\n          type: \"CatchClause\",\n          param: {\n            type: \"Identifier\",\n            name: \"e\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 16\n              }\n            }\n          },\n          body: {\n            type: \"BlockStatement\",\n            body: [],\n            loc: {\n              start: {\n                line: 1,\n                column: 18\n              },\n              end: {\n                line: 1,\n                column: 21\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 21\n            }\n          }\n        }\n      ,\n      finalizer: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 21\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 21\n    }\n  }\n});\n\ntest(\"try { } catch (eval) { }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"TryStatement\",\n      block: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      handler:\n        {\n          type: \"CatchClause\",\n          param: {\n            type: \"Identifier\",\n            name: \"eval\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 19\n              }\n            }\n          },\n          body: {\n            type: \"BlockStatement\",\n            body: [],\n            loc: {\n              start: {\n                line: 1,\n                column: 21\n              },\n              end: {\n                line: 1,\n                column: 24\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 24\n            }\n          }\n        }\n      ,\n      finalizer: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 24\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 24\n    }\n  }\n});\n\ntest(\"try { } catch (arguments) { }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"TryStatement\",\n      block: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      handler:\n        {\n          type: \"CatchClause\",\n          param: {\n            type: \"Identifier\",\n            name: \"arguments\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 24\n              }\n            }\n          },\n          body: {\n            type: \"BlockStatement\",\n            body: [],\n            loc: {\n              start: {\n                line: 1,\n                column: 26\n              },\n              end: {\n                line: 1,\n                column: 29\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }\n        }\n      ,\n      finalizer: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 29\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 29\n    }\n  }\n});\n\ntest(\"try { } catch (e) { say(e) }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"TryStatement\",\n      block: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      handler:\n        {\n          type: \"CatchClause\",\n          param: {\n            type: \"Identifier\",\n            name: \"e\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 16\n              }\n            }\n          },\n          body: {\n            type: \"BlockStatement\",\n            body: [\n              {\n                type: \"ExpressionStatement\",\n                expression: {\n                  type: \"CallExpression\",\n                  callee: {\n                    type: \"Identifier\",\n                    name: \"say\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 20\n                      },\n                      end: {\n                        line: 1,\n                        column: 23\n                      }\n                    }\n                  },\n                  arguments: [\n                    {\n                      type: \"Identifier\",\n                      name: \"e\",\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 24\n                        },\n                        end: {\n                          line: 1,\n                          column: 25\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 20\n                    },\n                    end: {\n                      line: 1,\n                      column: 26\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 20\n                  },\n                  end: {\n                    line: 1,\n                    column: 26\n                  }\n                }\n              }\n            ],\n            loc: {\n              start: {\n                line: 1,\n                column: 18\n              },\n              end: {\n                line: 1,\n                column: 28\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 8\n            },\n            end: {\n              line: 1,\n              column: 28\n            }\n          }\n        }\n      ,\n      finalizer: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 28\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 28\n    }\n  }\n});\n\ntest(\"try { } finally { cleanup(stuff) }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"TryStatement\",\n      block: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 7\n          }\n        }\n      },\n      handler: null,\n      finalizer: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"CallExpression\",\n              callee: {\n                type: \"Identifier\",\n                name: \"cleanup\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 18\n                  },\n                  end: {\n                    line: 1,\n                    column: 25\n                  }\n                }\n              },\n              arguments: [\n                {\n                  type: \"Identifier\",\n                  name: \"stuff\",\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 26\n                    },\n                    end: {\n                      line: 1,\n                      column: 31\n                    }\n                  }\n                }\n              ],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 18\n                },\n                end: {\n                  line: 1,\n                  column: 32\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 18\n              },\n              end: {\n                line: 1,\n                column: 32\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 16\n          },\n          end: {\n            line: 1,\n            column: 34\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 34\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 34\n    }\n  }\n});\n\ntest(\"try { doThat(); } catch (e) { say(e) }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"TryStatement\",\n      block: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"CallExpression\",\n              callee: {\n                type: \"Identifier\",\n                name: \"doThat\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 12\n                  }\n                }\n              },\n              arguments: [],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 6\n                },\n                end: {\n                  line: 1,\n                  column: 14\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 6\n              },\n              end: {\n                line: 1,\n                column: 15\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      handler:\n        {\n          type: \"CatchClause\",\n          param: {\n            type: \"Identifier\",\n            name: \"e\",\n            loc: {\n              start: {\n                line: 1,\n                column: 25\n              },\n              end: {\n                line: 1,\n                column: 26\n              }\n            }\n          },\n          body: {\n            type: \"BlockStatement\",\n            body: [\n              {\n                type: \"ExpressionStatement\",\n                expression: {\n                  type: \"CallExpression\",\n                  callee: {\n                    type: \"Identifier\",\n                    name: \"say\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 30\n                      },\n                      end: {\n                        line: 1,\n                        column: 33\n                      }\n                    }\n                  },\n                  arguments: [\n                    {\n                      type: \"Identifier\",\n                      name: \"e\",\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 34\n                        },\n                        end: {\n                          line: 1,\n                          column: 35\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 30\n                    },\n                    end: {\n                      line: 1,\n                      column: 36\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 30\n                  },\n                  end: {\n                    line: 1,\n                    column: 36\n                  }\n                }\n              }\n            ],\n            loc: {\n              start: {\n                line: 1,\n                column: 28\n              },\n              end: {\n                line: 1,\n                column: 38\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 18\n            },\n            end: {\n              line: 1,\n              column: 38\n            }\n          }\n        }\n      ,\n      finalizer: null,\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 38\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 38\n    }\n  }\n});\n\ntest(\"try { doThat(); } catch (e) { say(e) } finally { cleanup(stuff) }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"TryStatement\",\n      block: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"CallExpression\",\n              callee: {\n                type: \"Identifier\",\n                name: \"doThat\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 12\n                  }\n                }\n              },\n              arguments: [],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 6\n                },\n                end: {\n                  line: 1,\n                  column: 14\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 6\n              },\n              end: {\n                line: 1,\n                column: 15\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      handler:\n        {\n          type: \"CatchClause\",\n          param: {\n            type: \"Identifier\",\n            name: \"e\",\n            loc: {\n              start: {\n                line: 1,\n                column: 25\n              },\n              end: {\n                line: 1,\n                column: 26\n              }\n            }\n          },\n          body: {\n            type: \"BlockStatement\",\n            body: [\n              {\n                type: \"ExpressionStatement\",\n                expression: {\n                  type: \"CallExpression\",\n                  callee: {\n                    type: \"Identifier\",\n                    name: \"say\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 30\n                      },\n                      end: {\n                        line: 1,\n                        column: 33\n                      }\n                    }\n                  },\n                  arguments: [\n                    {\n                      type: \"Identifier\",\n                      name: \"e\",\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 34\n                        },\n                        end: {\n                          line: 1,\n                          column: 35\n                        }\n                      }\n                    }\n                  ],\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 30\n                    },\n                    end: {\n                      line: 1,\n                      column: 36\n                    }\n                  }\n                },\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 30\n                  },\n                  end: {\n                    line: 1,\n                    column: 36\n                  }\n                }\n              }\n            ],\n            loc: {\n              start: {\n                line: 1,\n                column: 28\n              },\n              end: {\n                line: 1,\n                column: 38\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 18\n            },\n            end: {\n              line: 1,\n              column: 38\n            }\n          }\n        }\n      ,\n      finalizer: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"CallExpression\",\n              callee: {\n                type: \"Identifier\",\n                name: \"cleanup\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 49\n                  },\n                  end: {\n                    line: 1,\n                    column: 56\n                  }\n                }\n              },\n              arguments: [\n                {\n                  type: \"Identifier\",\n                  name: \"stuff\",\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 57\n                    },\n                    end: {\n                      line: 1,\n                      column: 62\n                    }\n                  }\n                }\n              ],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 49\n                },\n                end: {\n                  line: 1,\n                  column: 63\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 49\n              },\n              end: {\n                line: 1,\n                column: 63\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 47\n          },\n          end: {\n            line: 1,\n            column: 65\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 65\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 65\n    }\n  }\n});\n\ntest(\"debugger;\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"DebuggerStatement\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n});\n\ntest(\"function hello() { sayHi(); }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {\n        type: \"Identifier\",\n        name: \"hello\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      params: [],\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"CallExpression\",\n              callee: {\n                type: \"Identifier\",\n                name: \"sayHi\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 19\n                  },\n                  end: {\n                    line: 1,\n                    column: 24\n                  }\n                }\n              },\n              arguments: [],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 19\n                },\n                end: {\n                  line: 1,\n                  column: 26\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 19\n              },\n              end: {\n                line: 1,\n                column: 27\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 17\n          },\n          end: {\n            line: 1,\n            column: 29\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 29\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 29\n    }\n  }\n});\n\ntest(\"function eval() { }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {\n        type: \"Identifier\",\n        name: \"eval\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      params: [],\n      body: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 16\n          },\n          end: {\n            line: 1,\n            column: 19\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 19\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 19\n    }\n  }\n});\n\ntest(\"function arguments() { }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {\n        type: \"Identifier\",\n        name: \"arguments\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 18\n          }\n        }\n      },\n      params: [],\n      body: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 21\n          },\n          end: {\n            line: 1,\n            column: 24\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 24\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 24\n    }\n  }\n});\n\ntest(\"function test(t, t) { }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {\n        type: \"Identifier\",\n        name: \"test\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      params: [\n        {\n          type: \"Identifier\",\n          name: \"t\",\n          loc: {\n            start: {\n              line: 1,\n              column: 14\n            },\n            end: {\n              line: 1,\n              column: 15\n            }\n          }\n        },\n        {\n          type: \"Identifier\",\n          name: \"t\",\n          loc: {\n            start: {\n              line: 1,\n              column: 17\n            },\n            end: {\n              line: 1,\n              column: 18\n            }\n          }\n        }\n      ],\n      body: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 20\n          },\n          end: {\n            line: 1,\n            column: 23\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 23\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 23\n    }\n  }\n});\n\ntest(\"(function test(t, t) { })\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"FunctionExpression\",\n        id: {\n          type: \"Identifier\",\n          name: \"test\",\n          loc: {\n            start: {\n              line: 1,\n              column: 10\n            },\n            end: {\n              line: 1,\n              column: 14\n            }\n          }\n        },\n        params: [\n          {\n            type: \"Identifier\",\n            name: \"t\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 16\n              }\n            }\n          },\n          {\n            type: \"Identifier\",\n            name: \"t\",\n            loc: {\n              start: {\n                line: 1,\n                column: 18\n              },\n              end: {\n                line: 1,\n                column: 19\n              }\n            }\n          }\n        ],\n        body: {\n          type: \"BlockStatement\",\n          body: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 21\n            },\n            end: {\n              line: 1,\n              column: 24\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 1,\n            column: 24\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 25\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 25\n    }\n  }\n});\n\ntest(\"function eval() { function inner() { \\\"use strict\\\" } }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {\n        type: \"Identifier\",\n        name: \"eval\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      params: [],\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"FunctionDeclaration\",\n            id: {\n              type: \"Identifier\",\n              name: \"inner\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 27\n                },\n                end: {\n                  line: 1,\n                  column: 32\n                }\n              }\n            },\n            params: [],\n            body: {\n              type: \"BlockStatement\",\n              body: [\n                {\n                  type: \"ExpressionStatement\",\n                  expression: {\n                    type: \"Literal\",\n                    value: \"use strict\",\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 37\n                      },\n                      end: {\n                        line: 1,\n                        column: 49\n                      }\n                    }\n                  },\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 37\n                    },\n                    end: {\n                      line: 1,\n                      column: 49\n                    }\n                  }\n                }\n              ],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 35\n                },\n                end: {\n                  line: 1,\n                  column: 51\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 18\n              },\n              end: {\n                line: 1,\n                column: 51\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 16\n          },\n          end: {\n            line: 1,\n            column: 53\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 53\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 53\n    }\n  }\n});\n\ntest(\"function hello(a) { sayHi(); }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {\n        type: \"Identifier\",\n        name: \"hello\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      params: [\n        {\n          type: \"Identifier\",\n          name: \"a\",\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 16\n            }\n          }\n        }\n      ],\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"CallExpression\",\n              callee: {\n                type: \"Identifier\",\n                name: \"sayHi\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 20\n                  },\n                  end: {\n                    line: 1,\n                    column: 25\n                  }\n                }\n              },\n              arguments: [],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 20\n                },\n                end: {\n                  line: 1,\n                  column: 27\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 20\n              },\n              end: {\n                line: 1,\n                column: 28\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 18\n          },\n          end: {\n            line: 1,\n            column: 30\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 30\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 30\n    }\n  }\n});\n\ntest(\"function hello(a, b) { sayHi(); }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {\n        type: \"Identifier\",\n        name: \"hello\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      params: [\n        {\n          type: \"Identifier\",\n          name: \"a\",\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 16\n            }\n          }\n        },\n        {\n          type: \"Identifier\",\n          name: \"b\",\n          loc: {\n            start: {\n              line: 1,\n              column: 18\n            },\n            end: {\n              line: 1,\n              column: 19\n            }\n          }\n        }\n      ],\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"CallExpression\",\n              callee: {\n                type: \"Identifier\",\n                name: \"sayHi\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 23\n                  },\n                  end: {\n                    line: 1,\n                    column: 28\n                  }\n                }\n              },\n              arguments: [],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 23\n                },\n                end: {\n                  line: 1,\n                  column: 30\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 23\n              },\n              end: {\n                line: 1,\n                column: 31\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 21\n          },\n          end: {\n            line: 1,\n            column: 33\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 33\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 33\n    }\n  }\n});\n\ntest(\"function hello(...rest) { }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {\n        type: \"Identifier\",\n        name: \"hello\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      params: [{\n        type: \"RestElement\",\n        argument: {\n          type: \"Identifier\",\n          name: \"rest\",\n          loc: {\n            start: {\n              line: 1,\n              column: 18\n            },\n            end: {\n              line: 1,\n              column: 22\n            }\n          }\n        }\n      }],\n      body: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 24\n          },\n          end: {\n            line: 1,\n            column: 27\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 27\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 27\n    }\n  }\n}, {\n  ecmaVersion: 6,\n  locations: true\n});\n\ntest(\"function hello(a, ...rest) { }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {\n        type: \"Identifier\",\n        name: \"hello\",\n        loc: {\n          start: {\n            line: 1,\n            column: 9\n          },\n          end: {\n            line: 1,\n            column: 14\n          }\n        }\n      },\n      params: [\n        {\n          type: \"Identifier\",\n          name: \"a\",\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 16\n            }\n          }\n        },\n        {\n          type: \"RestElement\",\n          argument: {\n            type: \"Identifier\",\n            name: \"rest\",\n            loc: {\n              start: {\n                line: 1,\n                column: 21\n              },\n              end: {\n                line: 1,\n                column: 25\n              }\n            }\n          }\n        }\n      ],\n      body: {\n        type: \"BlockStatement\",\n        body: [],\n        loc: {\n          start: {\n            line: 1,\n            column: 27\n          },\n          end: {\n            line: 1,\n            column: 30\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 30\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 30\n    }\n  }\n}, {\n  ecmaVersion: 6,\n  locations: true\n});\n\ntest(\"var hi = function() { sayHi() };\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"hi\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          init: {\n            type: \"FunctionExpression\",\n            id: null,\n            params: [],\n            body: {\n              type: \"BlockStatement\",\n              body: [\n                {\n                  type: \"ExpressionStatement\",\n                  expression: {\n                    type: \"CallExpression\",\n                    callee: {\n                      type: \"Identifier\",\n                      name: \"sayHi\",\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 22\n                        },\n                        end: {\n                          line: 1,\n                          column: 27\n                        }\n                      }\n                    },\n                    arguments: [],\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 22\n                      },\n                      end: {\n                        line: 1,\n                        column: 29\n                      }\n                    }\n                  },\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 22\n                    },\n                    end: {\n                      line: 1,\n                      column: 29\n                    }\n                  }\n                }\n              ],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 20\n                },\n                end: {\n                  line: 1,\n                  column: 31\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 31\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 31\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 32\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 32\n    }\n  }\n});\n\ntest(\"var hi = function (...r) { sayHi() };\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"hi\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          init: {\n            type: \"FunctionExpression\",\n            id: null,\n            params: [{\n              type: \"RestElement\",\n              argument: {\n                type: \"Identifier\",\n                name: \"r\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 22\n                  },\n                  end: {\n                    line: 1,\n                    column: 23\n                  }\n                }\n              }\n            }],\n            body: {\n              type: \"BlockStatement\",\n              body: [\n                {\n                  type: \"ExpressionStatement\",\n                  expression: {\n                    type: \"CallExpression\",\n                    callee: {\n                      type: \"Identifier\",\n                      name: \"sayHi\",\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 27\n                        },\n                        end: {\n                          line: 1,\n                          column: 32\n                        }\n                      }\n                    },\n                    arguments: [],\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 27\n                      },\n                      end: {\n                        line: 1,\n                        column: 34\n                      }\n                    }\n                  },\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 27\n                    },\n                    end: {\n                      line: 1,\n                      column: 34\n                    }\n                  }\n                }\n              ],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 25\n                },\n                end: {\n                  line: 1,\n                  column: 36\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 36\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 36\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 37\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 37\n    }\n  }\n}, {\n  ecmaVersion: 6,\n  locations: true\n});\n\ntest(\"var hi = function eval() { };\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"hi\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          init: {\n            type: \"FunctionExpression\",\n            id: {\n              type: \"Identifier\",\n              name: \"eval\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 18\n                },\n                end: {\n                  line: 1,\n                  column: 22\n                }\n              }\n            },\n            params: [],\n            body: {\n              type: \"BlockStatement\",\n              body: [],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 25\n                },\n                end: {\n                  line: 1,\n                  column: 28\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 28\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 28\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 29\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 29\n    }\n  }\n});\n\ntest(\"var hi = function arguments() { };\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"hi\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 6\n              }\n            }\n          },\n          init: {\n            type: \"FunctionExpression\",\n            id: {\n              type: \"Identifier\",\n              name: \"arguments\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 18\n                },\n                end: {\n                  line: 1,\n                  column: 27\n                }\n              }\n            },\n            params: [],\n            body: {\n              type: \"BlockStatement\",\n              body: [],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 30\n                },\n                end: {\n                  line: 1,\n                  column: 33\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 33\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 33\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 34\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 34\n    }\n  }\n});\n\ntest(\"var hello = function hi() { sayHi() };\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"hello\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 9\n              }\n            }\n          },\n          init: {\n            type: \"FunctionExpression\",\n            id: {\n              type: \"Identifier\",\n              name: \"hi\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 21\n                },\n                end: {\n                  line: 1,\n                  column: 23\n                }\n              }\n            },\n            params: [],\n            body: {\n              type: \"BlockStatement\",\n              body: [\n                {\n                  type: \"ExpressionStatement\",\n                  expression: {\n                    type: \"CallExpression\",\n                    callee: {\n                      type: \"Identifier\",\n                      name: \"sayHi\",\n                      loc: {\n                        start: {\n                          line: 1,\n                          column: 28\n                        },\n                        end: {\n                          line: 1,\n                          column: 33\n                        }\n                      }\n                    },\n                    arguments: [],\n                    loc: {\n                      start: {\n                        line: 1,\n                        column: 28\n                      },\n                      end: {\n                        line: 1,\n                        column: 35\n                      }\n                    }\n                  },\n                  loc: {\n                    start: {\n                      line: 1,\n                      column: 28\n                    },\n                    end: {\n                      line: 1,\n                      column: 35\n                    }\n                  }\n                }\n              ],\n              loc: {\n                start: {\n                  line: 1,\n                  column: 26\n                },\n                end: {\n                  line: 1,\n                  column: 37\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 12\n              },\n              end: {\n                line: 1,\n                column: 37\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 37\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 38\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 38\n    }\n  }\n});\n\ntest(\"(function(){})\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"FunctionExpression\",\n        id: null,\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: [],\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 14\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 14\n    }\n  }\n});\n\ntest(\"{ x\\n++y }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 2\n              },\n              end: {\n                line: 1,\n                column: 3\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 3\n            }\n          }\n        },\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"UpdateExpression\",\n            operator: \"++\",\n            prefix: true,\n            argument: {\n              type: \"Identifier\",\n              name: \"y\",\n              loc: {\n                start: {\n                  line: 2,\n                  column: 2\n                },\n                end: {\n                  line: 2,\n                  column: 3\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 3\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 2,\n              column: 0\n            },\n            end: {\n              line: 2,\n              column: 3\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 5\n    }\n  }\n});\n\ntest(\"{ x\\n--y }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 2\n              },\n              end: {\n                line: 1,\n                column: 3\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 3\n            }\n          }\n        },\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"UpdateExpression\",\n            operator: \"--\",\n            prefix: true,\n            argument: {\n              type: \"Identifier\",\n              name: \"y\",\n              loc: {\n                start: {\n                  line: 2,\n                  column: 2\n                },\n                end: {\n                  line: 2,\n                  column: 3\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 3\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 2,\n              column: 0\n            },\n            end: {\n              line: 2,\n              column: 3\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 5\n    }\n  }\n});\n\ntest(\"var x /* comment */;\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        }\n      ],\n      kind: \"var\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 20\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 20\n    }\n  }\n});\n\ntest(\"{ var x = 14, y = 3\\nz; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [\n        {\n          type: \"VariableDeclaration\",\n          declarations: [\n            {\n              type: \"VariableDeclarator\",\n              id: {\n                type: \"Identifier\",\n                name: \"x\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 6\n                  },\n                  end: {\n                    line: 1,\n                    column: 7\n                  }\n                }\n              },\n              init: {\n                type: \"Literal\",\n                value: 14,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 10\n                  },\n                  end: {\n                    line: 1,\n                    column: 12\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 6\n                },\n                end: {\n                  line: 1,\n                  column: 12\n                }\n              }\n            },\n            {\n              type: \"VariableDeclarator\",\n              id: {\n                type: \"Identifier\",\n                name: \"y\",\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 14\n                  },\n                  end: {\n                    line: 1,\n                    column: 15\n                  }\n                }\n              },\n              init: {\n                type: \"Literal\",\n                value: 3,\n                loc: {\n                  start: {\n                    line: 1,\n                    column: 18\n                  },\n                  end: {\n                    line: 1,\n                    column: 19\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 1,\n                  column: 14\n                },\n                end: {\n                  line: 1,\n                  column: 19\n                }\n              }\n            }\n          ],\n          kind: \"var\",\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 19\n            }\n          }\n        },\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 1\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 2,\n              column: 0\n            },\n            end: {\n              line: 2,\n              column: 2\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 4\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 4\n    }\n  }\n});\n\ntest(\"while (true) { continue\\nthere; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ContinueStatement\",\n            label: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 23\n              }\n            }\n          },\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"Identifier\",\n              name: \"there\",\n              loc: {\n                start: {\n                  line: 2,\n                  column: 0\n                },\n                end: {\n                  line: 2,\n                  column: 5\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 6\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 2,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 8\n    }\n  }\n});\n\ntest(\"while (true) { continue // Comment\\nthere; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ContinueStatement\",\n            label: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 23\n              }\n            }\n          },\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"Identifier\",\n              name: \"there\",\n              loc: {\n                start: {\n                  line: 2,\n                  column: 0\n                },\n                end: {\n                  line: 2,\n                  column: 5\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 6\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 2,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 8\n    }\n  }\n});\n\ntest(\"while (true) { continue /* Multiline\\nComment */there; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"ContinueStatement\",\n            label: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 23\n              }\n            }\n          },\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"Identifier\",\n              name: \"there\",\n              loc: {\n                start: {\n                  line: 2,\n                  column: 10\n                },\n                end: {\n                  line: 2,\n                  column: 15\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 2,\n                column: 10\n              },\n              end: {\n                line: 2,\n                column: 16\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 2,\n            column: 18\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 18\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 18\n    }\n  }\n});\n\ntest(\"while (true) { break\\nthere; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"BreakStatement\",\n            label: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          },\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"Identifier\",\n              name: \"there\",\n              loc: {\n                start: {\n                  line: 2,\n                  column: 0\n                },\n                end: {\n                  line: 2,\n                  column: 5\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 6\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 2,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 8\n    }\n  }\n});\n\ntest(\"while (true) { break // Comment\\nthere; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"BreakStatement\",\n            label: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          },\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"Identifier\",\n              name: \"there\",\n              loc: {\n                start: {\n                  line: 2,\n                  column: 0\n                },\n                end: {\n                  line: 2,\n                  column: 5\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 6\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 2,\n            column: 8\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 8\n    }\n  }\n});\n\ntest(\"while (true) { break /* Multiline\\nComment */there; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"WhileStatement\",\n      test: {\n        type: \"Literal\",\n        value: true,\n        loc: {\n          start: {\n            line: 1,\n            column: 7\n          },\n          end: {\n            line: 1,\n            column: 11\n          }\n        }\n      },\n      body: {\n        type: \"BlockStatement\",\n        body: [\n          {\n            type: \"BreakStatement\",\n            label: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          },\n          {\n            type: \"ExpressionStatement\",\n            expression: {\n              type: \"Identifier\",\n              name: \"there\",\n              loc: {\n                start: {\n                  line: 2,\n                  column: 10\n                },\n                end: {\n                  line: 2,\n                  column: 15\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 2,\n                column: 10\n              },\n              end: {\n                line: 2,\n                column: 16\n              }\n            }\n          }\n        ],\n        loc: {\n          start: {\n            line: 1,\n            column: 13\n          },\n          end: {\n            line: 2,\n            column: 18\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 18\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 18\n    }\n  }\n});\n\ntest(\"(function(){ return\\nx; })\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"FunctionExpression\",\n        id: null,\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"ReturnStatement\",\n              argument: null,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 19\n                }\n              }\n            },\n            {\n              type: \"ExpressionStatement\",\n              expression: {\n                type: \"Identifier\",\n                name: \"x\",\n                loc: {\n                  start: {\n                    line: 2,\n                    column: 0\n                  },\n                  end: {\n                    line: 2,\n                    column: 1\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 2,\n                  column: 0\n                },\n                end: {\n                  line: 2,\n                  column: 2\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 2,\n              column: 4\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 2,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 5\n    }\n  }\n});\n\ntest(\"(function(){ return // Comment\\nx; })\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"FunctionExpression\",\n        id: null,\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"ReturnStatement\",\n              argument: null,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 19\n                }\n              }\n            },\n            {\n              type: \"ExpressionStatement\",\n              expression: {\n                type: \"Identifier\",\n                name: \"x\",\n                loc: {\n                  start: {\n                    line: 2,\n                    column: 0\n                  },\n                  end: {\n                    line: 2,\n                    column: 1\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 2,\n                  column: 0\n                },\n                end: {\n                  line: 2,\n                  column: 2\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 2,\n              column: 4\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 2,\n            column: 4\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 5\n    }\n  }\n});\n\ntest(\"(function(){ return/* Multiline\\nComment */x; })\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"FunctionExpression\",\n        id: null,\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: [\n            {\n              type: \"ReturnStatement\",\n              argument: null,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 13\n                },\n                end: {\n                  line: 1,\n                  column: 19\n                }\n              }\n            },\n            {\n              type: \"ExpressionStatement\",\n              expression: {\n                type: \"Identifier\",\n                name: \"x\",\n                loc: {\n                  start: {\n                    line: 2,\n                    column: 10\n                  },\n                  end: {\n                    line: 2,\n                    column: 11\n                  }\n                }\n              },\n              loc: {\n                start: {\n                  line: 2,\n                  column: 10\n                },\n                end: {\n                  line: 2,\n                  column: 12\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 11\n            },\n            end: {\n              line: 2,\n              column: 14\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 2,\n            column: 14\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 15\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 15\n    }\n  }\n});\n\ntest(\"{ throw error\\nerror; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [\n        {\n          type: \"ThrowStatement\",\n          argument: {\n            type: \"Identifier\",\n            name: \"error\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"Identifier\",\n            name: \"error\",\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 2,\n              column: 0\n            },\n            end: {\n              line: 2,\n              column: 6\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 8\n    }\n  }\n});\n\ntest(\"{ throw error// Comment\\nerror; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [\n        {\n          type: \"ThrowStatement\",\n          argument: {\n            type: \"Identifier\",\n            name: \"error\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"Identifier\",\n            name: \"error\",\n            loc: {\n              start: {\n                line: 2,\n                column: 0\n              },\n              end: {\n                line: 2,\n                column: 5\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 2,\n              column: 0\n            },\n            end: {\n              line: 2,\n              column: 6\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 8\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 8\n    }\n  }\n});\n\ntest(\"{ throw error/* Multiline\\nComment */error; }\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: [\n        {\n          type: \"ThrowStatement\",\n          argument: {\n            type: \"Identifier\",\n            name: \"error\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 2\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        {\n          type: \"ExpressionStatement\",\n          expression: {\n            type: \"Identifier\",\n            name: \"error\",\n            loc: {\n              start: {\n                line: 2,\n                column: 10\n              },\n              end: {\n                line: 2,\n                column: 15\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 2,\n              column: 10\n            },\n            end: {\n              line: 2,\n              column: 16\n            }\n          }\n        }\n      ],\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 2,\n          column: 18\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 2,\n      column: 18\n    }\n  }\n});\n\ntest(\"\", {\n  type: \"Program\",\n  body: [],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 0\n    }\n  }\n});\n\ntest(\"foo: if (true) break foo;\", {\n  type: \"Program\",\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 25\n    }\n  },\n  body: [\n    {\n      type: \"LabeledStatement\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 25\n        }\n      },\n      body: {\n        type: \"IfStatement\",\n        loc: {\n          start: {\n            line: 1,\n            column: 5\n          },\n          end: {\n            line: 1,\n            column: 25\n          }\n        },\n        test: {\n          type: \"Literal\",\n          loc: {\n            start: {\n              line: 1,\n              column: 9\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          },\n          value: true\n        },\n        consequent: {\n          type: \"BreakStatement\",\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 25\n            }\n          },\n          label: {\n            type: \"Identifier\",\n            loc: {\n              start: {\n                line: 1,\n                column: 21\n              },\n              end: {\n                line: 1,\n                column: 24\n              }\n            },\n            name: \"foo\"\n          }\n        },\n        alternate: null\n      },\n      label: {\n        type: \"Identifier\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 3\n          }\n        },\n        name: \"foo\"\n      }\n    }\n  ]\n});\n\ntest(\"a: { b: switch(x) {} }\", {\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 22,\n  \"body\": [\n    {\n      \"type\": \"LabeledStatement\",\n      \"start\": 0,\n      \"end\": 22,\n      \"body\": {\n        \"type\": \"BlockStatement\",\n        \"start\": 3,\n        \"end\": 22,\n        \"body\": [\n          {\n            \"type\": \"LabeledStatement\",\n            \"start\": 5,\n            \"end\": 20,\n            \"body\": {\n              \"type\": \"SwitchStatement\",\n              \"start\": 8,\n              \"end\": 20,\n              \"discriminant\": {\n                \"type\": \"Identifier\",\n                \"start\": 15,\n                \"end\": 16,\n                \"name\": \"x\"\n              },\n              \"cases\": []\n            },\n            \"label\": {\n              \"type\": \"Identifier\",\n              \"start\": 5,\n              \"end\": 6,\n              \"name\": \"b\"\n            }\n          }\n        ]\n      },\n      \"label\": {\n        \"type\": \"Identifier\",\n        \"start\": 0,\n        \"end\": 1,\n        \"name\": \"a\"\n      }\n    }\n  ]\n});\n\ntest(\"(function () {\\n 'use strict';\\n '\\0';\\n}())\", {\n  type: \"Program\",\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 4,\n      column: 4\n    }\n  },\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 4,\n          column: 4\n        }\n      },\n      expression: {\n        type: \"CallExpression\",\n        loc: {\n          start: {\n            line: 1,\n            column: 1\n          },\n          end: {\n            line: 4,\n            column: 3\n          }\n        },\n        callee: {\n          type: \"FunctionExpression\",\n          loc: {\n            start: {\n              line: 1,\n              column: 1\n            },\n            end: {\n              line: 4,\n              column: 1\n            }\n          },\n          id: null,\n          params: [],\n          body: {\n            type: \"BlockStatement\",\n            loc: {\n              start: {\n                line: 1,\n                column: 13\n              },\n              end: {\n                line: 4,\n                column: 1\n              }\n            },\n            body: [\n              {\n                type: \"ExpressionStatement\",\n                loc: {\n                  start: {\n                    line: 2,\n                    column: 1\n                  },\n                  end: {\n                    line: 2,\n                    column: 14\n                  }\n                },\n                expression: {\n                  type: \"Literal\",\n                  loc: {\n                    start: {\n                      line: 2,\n                      column: 1\n                    },\n                    end: {\n                      line: 2,\n                      column: 13\n                    }\n                  },\n                  value: \"use strict\"\n                }\n              },\n              {\n                type: \"ExpressionStatement\",\n                loc: {\n                  start: {\n                    line: 3,\n                    column: 1\n                  },\n                  end: {\n                    line: 3,\n                    column: 5\n                  }\n                },\n                expression: {\n                  type: \"Literal\",\n                  loc: {\n                    start: {\n                      line: 3,\n                      column: 1\n                    },\n                    end: {\n                      line: 3,\n                      column: 4\n                    }\n                  },\n                  value: \"\\u0000\"\n                }\n              }\n            ]\n          }\n        },\n        arguments: [],\n      }\n    }\n  ]\n});\n\ntest(\"123..toString(10)\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"Literal\",\n            value: 123\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"toString\"\n          },\n          computed: false,\n        },\n        arguments: [\n          {\n            type: \"Literal\",\n            value: 10\n          }\n        ],\n      }\n    }\n  ]\n});\n\ntest(\"123.+2\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Literal\",\n          value: 123\n        },\n        operator: \"+\",\n        right: {\n          type: \"Literal\",\n          value: 2\n        },\n      }\n    }\n  ]\n});\n\ntest(\"a\\u2028b\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Identifier\",\n        name: \"a\"\n      }\n    },\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Identifier\",\n        name: \"b\"\n      }\n    }\n  ]\n});\n\ntest(\"'a\\\\u0026b'\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"a\\u0026b\"\n      }\n    }\n  ]\n});\n\ntest(\"foo: 10; foo: 20;\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"LabeledStatement\",\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"Literal\",\n          value: 10,\n          raw: \"10\"\n        }\n      },\n      label: {\n        type: \"Identifier\",\n        name: \"foo\"\n      }\n    },\n    {\n      type: \"LabeledStatement\",\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"Literal\",\n          value: 20,\n          raw: \"20\"\n        }\n      },\n      label: {\n        type: \"Identifier\",\n        name: \"foo\"\n      }\n    }\n  ]\n});\n\ntest(\"if(1)/  foo/\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"IfStatement\",\n      test: {\n        type: \"Literal\",\n        value: 1,\n        raw: \"1\"\n      },\n      consequent: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"Literal\",\n          raw: \"/  foo/\"\n        }\n      },\n      alternate: null\n    }\n  ]\n});\n\ntest(\"price_9̶9̶_89\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Identifier\",\n        name: \"price_9̶9̶_89\",\n      }\n    }\n  ]\n});\n\n// `\\0` is valid even in strict mode\ntest(\"function hello() { 'use strict'; \\\"\\\\0\\\"; }\", {});\n\n// option tests\n\ntest(\"var a = 1;\", {\n  type: \"Program\",\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 10\n    },\n    source: \"test.js\"\n  },\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 10\n        },\n        source: \"test.js\"\n      },\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 9\n            },\n            source: \"test.js\"\n          },\n          id: {\n            type: \"Identifier\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              },\n              source: \"test.js\"\n            },\n            name: \"a\"\n          },\n          init: {\n            type: \"Literal\",\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 9\n              },\n              source: \"test.js\"\n            },\n            value: 1,\n            raw: \"1\"\n          }\n        }\n      ],\n      kind: \"var\"\n    }\n  ]\n}, {\n  locations: true,\n  sourceFile: \"test.js\"\n});\n\ntest(\"a.in / b\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"Identifier\",\n            name: \"a\"\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"in\"\n          },\n          computed: false\n        },\n        operator: \"/\",\n        right: {\n          type: \"Identifier\",\n          name: \"b\"\n        }\n      }\n    }\n  ]\n});\n\n// A number of slash-disambiguation corner cases\ntest(\"return {} / 2\", {}, {allowReturnOutsideFunction: true});\ntest(\"return\\n{}\\n/foo/\", {}, {allowReturnOutsideFunction: true});\ntest(\"+{} / 2\", {});\ntest(\"{}\\n/foo/\", {});\ntest(\"x++\\n{}\\n/foo/\", {});\ntest(\"{{}\\n/foo/}\", {});\ntest(\"while (1) /foo/\", {});\ntest(\"while (1) {} /foo/\", {});\ntest(\"(1) / 2\", {});\ntest(\"({a: [1]}+[]) / 2\", {});\ntest(\"{[1]}\\n/foo/\", {});\ntest(\"switch(a) { case 1: {}\\n/foo/ }\", {});\ntest(\"({1: {} / 2})\", {});\ntest(\"+x++ / 2\", {});\ntest(\"foo.in\\n{}\\n/foo/\", {});\ntest(\"var x = function f() {} / 3;\", {});\ntest(\"+function f() {} / 3;\", {});\ntest(\"foo: function x() {} /regexp/\", {});\ntest(\"x = {foo: function x() {} / divide}\", {});\ntest(\"foo; function f() {} /regexp/\", {});\ntest(\"{function f() {} /regexp/}\", {});\ntest(\"function fn() {return\\nfunction foo() {}\\n/42/}\", {});\ntest(\"var x\\n/foo/\", {});\n\ntest(\"{}/=/\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"BlockStatement\",\n      body: []\n    },\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        raw: \"/=/\"\n      }\n    }\n  ]\n});\n\ntest(\"foo <!--bar\\n+baz\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"BinaryExpression\",\n        left: {\n          type: \"Identifier\",\n          name: \"foo\"\n        },\n        operator: \"+\",\n        right: {\n          type: \"Identifier\",\n          name: \"baz\"\n        }\n      }\n    }\n  ]\n});\n\ntest(\"x = y-->10;\\n --> nothing\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"AssignmentExpression\",\n        operator: \"=\",\n        left: {\n          type: \"Identifier\",\n          name: \"x\"\n        },\n        right: {\n          type: \"BinaryExpression\",\n          left: {\n            type: \"UpdateExpression\",\n            operator: \"--\",\n            prefix: false,\n            argument: {\n              type: \"Identifier\",\n              name: \"y\"\n            }\n          },\n          operator: \">\",\n          right: {\n            type: \"Literal\",\n            value: 10\n          }\n        }\n      }\n    }\n  ]\n});\n\ntest(\"'use strict';\\nobject.static();\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: \"use strict\",\n        raw: \"'use strict'\"\n      }\n    },\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"CallExpression\",\n        callee: {\n          type: \"MemberExpression\",\n          object: {\n            type: \"Identifier\",\n            name: \"object\"\n          },\n          property: {\n            type: \"Identifier\",\n            name: \"static\"\n          },\n          computed: false\n        },\n        arguments: []\n      }\n    }\n  ]\n});\n\n// Failure tests\n\ntestFail(\"{\",\n         \"Unexpected token (1:1)\");\n\ntestFail(\"}\",\n         \"Unexpected token (1:0)\");\n\ntestFail(\"3ea\",\n         \"Invalid number (1:0)\");\n\ntestFail(\"3in []\",\n         \"Identifier directly after number (1:1)\");\n\ntestFail(\"3e\",\n         \"Invalid number (1:0)\");\n\ntestFail(\"3e+\",\n         \"Invalid number (1:0)\");\n\ntestFail(\"3e-\",\n         \"Invalid number (1:0)\");\n\ntestFail(\"3x\",\n         \"Identifier directly after number (1:1)\");\n\ntestFail(\"3x0\",\n         \"Identifier directly after number (1:1)\");\n\ntestFail(\"0x\",\n         \"Expected number in radix 16 (1:2)\");\n\ntestFail(\"'use strict'; 09\",\n         \"Invalid number (1:14)\");\n\ntestFail(\"'use strict'; 018\",\n         \"Invalid number (1:14)\");\n\ntestFail(\"01a\",\n         \"Identifier directly after number (1:2)\");\n\ntestFail(\"3in[]\",\n         \"Identifier directly after number (1:1)\");\n\ntestFail(\"0x3in[]\",\n         \"Identifier directly after number (1:3)\");\n\ntestFail(\"\\\"Hello\\nWorld\\\"\",\n         \"Unterminated string constant (1:0)\");\n\ntestFail(\"x\\\\\",\n         \"Expecting Unicode escape sequence \\\\uXXXX (1:2)\");\n\ntestFail(\"x\\\\u005c\",\n         \"Invalid Unicode escape (1:1)\");\n\ntestFail(\"x\\\\u002a\",\n         \"Invalid Unicode escape (1:1)\");\n\ntestFail(\"/\",\n         \"Unterminated regular expression (1:1)\");\n\ntestFail(\"/test\",\n         \"Unterminated regular expression (1:1)\");\n\ntestFail(\"var x = /[a-z]/\\\\ux\",\n         \"Bad character escape sequence (1:17)\");\n\ntestFail(\"3 = 4\",\n         \"Assigning to rvalue (1:0)\");\n\ntestFail(\"func() = 4\",\n         \"Assigning to rvalue (1:0)\");\n\ntestFail(\"(1 + 1) = 10\",\n         \"Parenthesized pattern (1:0)\");\n\ntestFail(\"1++\",\n         \"Assigning to rvalue (1:0)\");\n\ntestFail(\"1--\",\n         \"Assigning to rvalue (1:0)\");\n\ntestFail(\"++1\",\n         \"Assigning to rvalue (1:2)\");\n\ntestFail(\"--1\",\n         \"Assigning to rvalue (1:2)\");\n\ntestFail(\"for((1 + 1) in list) process(x);\",\n         \"Parenthesized pattern (1:4)\");\n\ntestFail(\"[\",\n         \"Unexpected token (1:1)\");\n\ntestFail(\"[,\",\n         \"Unexpected token (1:2)\");\n\ntestFail(\"1 + {\",\n         \"Unexpected token (1:5)\");\n\ntestFail(\"1 + { t:t \",\n         \"Unexpected token (1:10)\");\n\ntestFail(\"1 + { t:t,\",\n         \"Unexpected token (1:10)\");\n\ntestFail(\"var x = /\\n/\",\n         \"Unterminated regular expression (1:9)\");\n\ntestFail(\"var x = \\\"\\n\",\n         \"Unterminated string constant (1:8)\");\n\ntestFail(\"var if = 42\",\n         \"Unexpected keyword 'if' (1:4)\");\n\ntestFail(\"i + 2 = 42\",\n         \"Assigning to rvalue (1:0)\");\n\ntestFail(\"+i = 42\",\n         \"Assigning to rvalue (1:0)\");\n\ntestFail(\"1 + (\",\n         \"Unexpected token (1:5)\");\n\ntestFail(\"\\n\\n\\n{\",\n         \"Unexpected token (4:1)\");\n\ntestFail(\"\\n/* Some multiline\\ncomment */\\n)\",\n         \"Unexpected token (4:0)\");\n\ntestFail(\"{ set 1 }\",\n         \"Unexpected token (1:6)\");\n\ntestFail(\"{ get 2 }\",\n         \"Unexpected token (1:6)\");\n\ntestFail(\"({ set: s(if) { } })\",\n         \"Unexpected token (1:10)\");\n\ntestFail(\"({ set s(.) { } })\",\n         \"Unexpected token (1:9)\");\n\ntestFail(\"({ set: s() { } })\",\n         \"Unexpected token (1:12)\");\n\ntestFail(\"({ set: s(a, b) { } })\",\n         \"Unexpected token (1:16)\");\n\ntestFail(\"({ get: g(d) { } })\",\n         \"Unexpected token (1:13)\");\n\ntestFail(\"({ get i() { }, i: 42 })\",\n         \"Redefinition of property (1:16)\");\n\ntestFail(\"({ i: 42, get i() { } })\",\n         \"Redefinition of property (1:14)\");\n\ntestFail(\"({ set i(x) { }, i: 42 })\",\n         \"Redefinition of property (1:17)\");\n\ntestFail(\"({ i: 42, set i(x) { } })\",\n         \"Redefinition of property (1:14)\");\n\ntestFail(\"({ get i() { }, get i() { } })\",\n         \"Redefinition of property (1:20)\");\n\ntestFail(\"({ set i(x) { }, set i(x) { } })\",\n         \"Redefinition of property (1:21)\");\n\ntestFail(\"'use strict'; ({ __proto__: 1, __proto__: 2 })\",\n         \"Redefinition of property (1:31)\");\n\ntestFail(\"function t(...) { }\",\n         \"Unexpected token (1:11)\");\n\ntestFail(\"function t(...) { }\",\n         \"Unexpected token (1:14)\",\n         { ecmaVersion: 6 });\n\ntestFail(\"function t(...rest, b) { }\",\n         \"Comma is not permitted after the rest element (1:18)\",\n         { ecmaVersion: 6 });\n\ntestFail(\"function t(if) { }\",\n         \"Unexpected keyword 'if' (1:11)\");\n\ntestFail(\"function t(true) { }\",\n         \"Unexpected keyword 'true' (1:11)\");\n\ntestFail(\"function t(false) { }\",\n         \"Unexpected keyword 'false' (1:11)\");\n\ntestFail(\"function t(null) { }\",\n         \"Unexpected keyword 'null' (1:11)\");\n\ntestFail(\"function null() { }\",\n         \"Unexpected keyword 'null' (1:9)\");\n\ntestFail(\"function true() { }\",\n         \"Unexpected keyword 'true' (1:9)\");\n\ntestFail(\"function false() { }\",\n         \"Unexpected keyword 'false' (1:9)\");\n\ntestFail(\"function if() { }\",\n         \"Unexpected keyword 'if' (1:9)\");\n\ntestFail(\"a b;\",\n         \"Unexpected token (1:2)\");\n\ntestFail(\"if.a;\",\n         \"Unexpected token (1:2)\");\n\ntestFail(\"a if;\",\n         \"Unexpected token (1:2)\");\n\ntestFail(\"a class;\",\n         \"Unexpected token (1:2)\");\n\ntestFail(\"break\\n\",\n         \"Unsyntactic break (1:0)\");\n\ntestFail(\"break 1;\",\n         \"Unexpected token (1:6)\");\n\ntestFail(\"continue\\n\",\n         \"Unsyntactic continue (1:0)\");\n\ntestFail(\"continue 2;\",\n         \"Unexpected token (1:9)\");\n\ntestFail(\"throw\",\n         \"Unexpected token (1:5)\");\n\ntestFail(\"throw;\",\n         \"Unexpected token (1:5)\");\n\ntestFail(\"for (var i, i2 in {});\",\n         \"Unexpected token (1:15)\");\n\ntestFail(\"for ((i in {}));\",\n         \"Unexpected token (1:14)\");\n\ntestFail(\"for (i + 1 in {});\",\n         \"Assigning to rvalue (1:5)\");\n\ntestFail(\"for (+i in {});\",\n         \"Assigning to rvalue (1:5)\");\n\ntestFail(\"if(false)\",\n         \"Unexpected token (1:9)\");\n\ntestFail(\"if(false) doThis(); else\",\n         \"Unexpected token (1:24)\");\n\ntestFail(\"do\",\n         \"Unexpected token (1:2)\");\n\ntestFail(\"while(false)\",\n         \"Unexpected token (1:12)\");\n\ntestFail(\"for(;;)\",\n         \"Unexpected token (1:7)\");\n\ntestFail(\"with(x)\",\n         \"Unexpected token (1:7)\");\n\ntestFail(\"try { }\",\n         \"Missing catch or finally clause (1:0)\");\n\ntestFail(\"‿ = 10\",\n         \"Unexpected character '‿' (1:0)\");\n\ntestFail(\"if(true) let a = 1;\",\n         \"Unexpected token (1:13)\");\n\ntestFail(\"switch (c) { default: default: }\",\n         \"Multiple default clauses (1:22)\");\n\ntestFail(\"new X().\\\"s\\\"\",\n         \"Unexpected token (1:8)\");\n\ntestFail(\"/*\",\n         \"Unterminated comment (1:0)\");\n\ntestFail(\"/*\\n\\n\\n\",\n         \"Unterminated comment (1:0)\");\n\ntestFail(\"/**\",\n         \"Unterminated comment (1:0)\");\n\ntestFail(\"/*\\n\\n*\",\n         \"Unterminated comment (1:0)\");\n\ntestFail(\"/*hello\",\n         \"Unterminated comment (1:0)\");\n\ntestFail(\"/*hello  *\",\n         \"Unterminated comment (1:0)\");\n\ntestFail(\"\\n]\",\n         \"Unexpected token (2:0)\");\n\ntestFail(\"\\r]\",\n         \"Unexpected token (2:0)\");\n\ntestFail(\"\\r\\n]\",\n         \"Unexpected token (2:0)\");\n\ntestFail(\"\\n\\r]\",\n         \"Unexpected token (3:0)\");\n\ntestFail(\"//\\r\\n]\",\n         \"Unexpected token (2:0)\");\n\ntestFail(\"//\\n\\r]\",\n         \"Unexpected token (3:0)\");\n\ntestFail(\"/a\\\\\\n/\",\n         \"Unterminated regular expression (1:1)\");\n\ntestFail(\"//\\r \\n]\",\n         \"Unexpected token (3:0)\");\n\ntestFail(\"/*\\r\\n*/]\",\n         \"Unexpected token (2:2)\");\n\ntestFail(\"/*\\n\\r*/]\",\n         \"Unexpected token (3:2)\");\n\ntestFail(\"/*\\r \\n*/]\",\n         \"Unexpected token (3:2)\");\n\ntestFail(\"\\\\\\\\\",\n         \"Expecting Unicode escape sequence \\\\uXXXX (1:1)\");\n\ntestFail(\"\\\\u005c\",\n         \"Invalid Unicode escape (1:0)\");\n\ntestFail(\"\\\\x\",\n         \"Expecting Unicode escape sequence \\\\uXXXX (1:1)\");\n\ntestFail(\"\\\\u0000\",\n         \"Invalid Unicode escape (1:0)\");\n\ntestFail(\"‌ = []\",\n         \"Unexpected character '‌' (1:0)\");\n\ntestFail(\"‍ = []\",\n         \"Unexpected character '‍' (1:0)\");\n\ntestFail(\"\\\"\\\\\",\n         \"Unterminated string constant (1:0)\");\n\ntestFail(\"\\\"\\\\u\",\n         \"Bad character escape sequence (1:3)\");\n\ntestFail(\"return\",\n         \"'return' outside of function (1:0)\");\n\ntestFail(\"break\",\n         \"Unsyntactic break (1:0)\");\n\ntestFail(\"continue\",\n         \"Unsyntactic continue (1:0)\");\n\ntestFail(\"switch (x) { default: continue; }\",\n         \"Unsyntactic continue (1:22)\");\n\ntestFail(\"do { x } *\",\n         \"Unexpected token (1:9)\");\n\ntestFail(\"while (true) { break x; }\",\n         \"Unsyntactic break (1:15)\");\n\ntestFail(\"while (true) { continue x; }\",\n         \"Unsyntactic continue (1:15)\");\n\ntestFail(\"x: while (true) { (function () { break x; }); }\",\n         \"Unsyntactic break (1:33)\");\n\ntestFail(\"x: while (true) { (function () { continue x; }); }\",\n         \"Unsyntactic continue (1:33)\");\n\ntestFail(\"x: while (true) { (function () { break; }); }\",\n         \"Unsyntactic break (1:33)\");\n\ntestFail(\"x: while (true) { (function () { continue; }); }\",\n         \"Unsyntactic continue (1:33)\");\n\ntestFail(\"x: while (true) { x: while (true) { } }\",\n         \"Label 'x' is already declared (1:18)\");\n\ntestFail(\"(function () { 'use strict'; delete i; }())\",\n         \"Deleting local variable in strict mode (1:29)\");\n\ntestFail(\"function x() { '\\\\12'; 'use strict'; }\", \"Octal literal in strict mode (1:16)\")\n\ntestFail(\"(function () { 'use strict'; with (i); }())\",\n         \"'with' in strict mode (1:29)\");\n\ntestFail(\"function hello() {'use strict'; ({ i: 42, i: 42 }) }\",\n         \"Redefinition of property (1:42)\");\n\ntestFail(\"function hello() {'use strict'; ({ hasOwnProperty: 42, hasOwnProperty: 42 }) }\",\n         \"Redefinition of property (1:55)\");\n\ntestFail(\"function hello() {'use strict'; var eval = 10; }\",\n         \"Binding eval in strict mode (1:36)\");\n\ntestFail(\"function hello() {'use strict'; var arguments = 10; }\",\n         \"Binding arguments in strict mode (1:36)\");\n\ntestFail(\"function hello() {'use strict'; try { } catch (eval) { } }\",\n         \"Binding eval in strict mode (1:47)\");\n\ntestFail(\"function hello() {'use strict'; try { } catch (arguments) { } }\",\n         \"Binding arguments in strict mode (1:47)\");\n\ntestFail(\"function hello() {'use strict'; eval = 10; }\",\n         \"Assigning to eval in strict mode (1:32)\");\n\ntestFail(\"function hello() {'use strict'; arguments = 10; }\",\n         \"Assigning to arguments in strict mode (1:32)\");\n\ntestFail(\"function hello() {'use strict'; ++eval; }\",\n         \"Assigning to eval in strict mode (1:34)\");\n\ntestFail(\"function hello() {'use strict'; --eval; }\",\n         \"Assigning to eval in strict mode (1:34)\");\n\ntestFail(\"function hello() {'use strict'; ++arguments; }\",\n         \"Assigning to arguments in strict mode (1:34)\");\n\ntestFail(\"function hello() {'use strict'; --arguments; }\",\n         \"Assigning to arguments in strict mode (1:34)\");\n\ntestFail(\"function hello() {'use strict'; eval++; }\",\n         \"Assigning to eval in strict mode (1:32)\");\n\ntestFail(\"function hello() {'use strict'; eval--; }\",\n         \"Assigning to eval in strict mode (1:32)\");\n\ntestFail(\"function hello() {'use strict'; arguments++; }\",\n         \"Assigning to arguments in strict mode (1:32)\");\n\ntestFail(\"function hello() {'use strict'; arguments--; }\",\n         \"Assigning to arguments in strict mode (1:32)\");\n\ntestFail(\"function hello() {'use strict'; function eval() { } }\",\n         \"Binding eval in strict mode (1:41)\");\n\ntestFail(\"function hello() {'use strict'; function arguments() { } }\",\n         \"Binding arguments in strict mode (1:41)\");\n\ntestFail(\"function eval() {'use strict'; }\",\n         \"Binding eval in strict mode (1:9)\");\n\ntestFail(\"function arguments() {'use strict'; }\",\n         \"Binding arguments in strict mode (1:9)\");\n\ntestFail(\"function hello() {'use strict'; (function eval() { }()) }\",\n         \"Binding eval in strict mode (1:42)\");\n\ntestFail(\"function hello() {'use strict'; (function arguments() { }()) }\",\n         \"Binding arguments in strict mode (1:42)\");\n\ntestFail(\"(function eval() {'use strict'; })()\",\n         \"Binding eval in strict mode (1:10)\");\n\ntestFail(\"(function arguments() {'use strict'; })()\",\n         \"Binding arguments in strict mode (1:10)\");\n\ntestFail(\"function hello() {'use strict'; ({ s: function eval() { } }); }\",\n         \"Binding eval in strict mode (1:47)\");\n\ntestFail(\"(function package() {'use strict'; })()\",\n         \"Binding package in strict mode (1:10)\");\n\ntestFail(\"function hello() {'use strict'; ({ i: 10, set s(eval) { } }); }\",\n         \"Binding eval in strict mode (1:48)\");\n\ntestFail(\"function hello() {'use strict'; ({ set s(eval) { } }); }\",\n         \"Binding eval in strict mode (1:41)\");\n\ntestFail(\"function hello() {'use strict'; ({ s: function s(eval) { } }); }\",\n         \"Binding eval in strict mode (1:49)\");\n\ntestFail(\"function hello(eval) {'use strict';}\",\n         \"Binding eval in strict mode (1:15)\");\n\ntestFail(\"function hello(arguments) {'use strict';}\",\n         \"Binding arguments in strict mode (1:15)\");\n\ntestFail(\"function hello() { 'use strict'; function inner(eval) {} }\",\n         \"Binding eval in strict mode (1:48)\");\n\ntestFail(\"function hello() { 'use strict'; function inner(arguments) {} }\",\n         \"Binding arguments in strict mode (1:48)\");\n\ntestFail(\"function hello() { 'use strict'; \\\"\\\\1\\\"; }\",\n         \"Octal literal in strict mode (1:34)\");\n\ntestFail(\"function hello() { 'use strict'; \\\"\\\\00\\\"; }\",\n         \"Octal literal in strict mode (1:34)\");\n\ntestFail(\"function hello() { 'use strict'; \\\"\\\\000\\\"; }\",\n         \"Octal literal in strict mode (1:34)\");\n\ntestFail(\"function hello() { 'use strict'; 021; }\",\n         \"Invalid number (1:33)\");\n\ntestFail(\"function hello() { 'use strict'; ({ \\\"\\\\1\\\": 42 }); }\",\n         \"Octal literal in strict mode (1:37)\");\n\ntestFail(\"function hello() { 'use strict'; ({ 021: 42 }); }\",\n         \"Invalid number (1:36)\");\n\ntestFail(\"function hello() { \\\"use strict\\\"; function inner() { \\\"octal directive\\\\1\\\"; } }\",\n         \"Octal literal in strict mode (1:68)\");\n\ntestFail(\"function hello() { \\\"use strict\\\"; var implements; }\",\n         \"The keyword 'implements' is reserved (1:37)\");\n\ntestFail(\"function hello() { \\\"use strict\\\"; var interface; }\",\n         \"The keyword 'interface' is reserved (1:37)\");\n\ntestFail(\"function hello() { \\\"use strict\\\"; var package; }\",\n         \"The keyword 'package' is reserved (1:37)\");\n\ntestFail(\"function hello() { \\\"use strict\\\"; var private; }\",\n         \"The keyword 'private' is reserved (1:37)\");\n\ntestFail(\"function hello() { \\\"use strict\\\"; var protected; }\",\n         \"The keyword 'protected' is reserved (1:37)\");\n\ntestFail(\"function hello() { \\\"use strict\\\"; var public; }\",\n         \"The keyword 'public' is reserved (1:37)\");\n\ntestFail(\"function hello() { \\\"use strict\\\"; var static; }\",\n         \"The keyword 'static' is reserved (1:37)\");\n\ntestFail(\"function hello(static) { \\\"use strict\\\"; }\",\n         \"Binding static in strict mode (1:15)\");\n\ntestFail(\"function static() { \\\"use strict\\\"; }\",\n         \"Binding static in strict mode (1:9)\");\n\ntestFail(\"\\\"use strict\\\"; function static() { }\",\n         \"The keyword 'static' is reserved (1:23)\");\n\ntestFail(\"function a(t, t) { \\\"use strict\\\"; }\",\n         \"Argument name clash (1:14)\");\n\ntestFail(\"function a(eval) { \\\"use strict\\\"; }\",\n         \"Binding eval in strict mode (1:11)\");\n\ntestFail(\"function a(package) { \\\"use strict\\\"; }\",\n         \"Binding package in strict mode (1:11)\");\n\ntestFail(\"function a() { \\\"use strict\\\"; function b(t, t) { }; }\",\n         \"Argument name clash (1:43)\");\n\ntestFail(\"(function a(t, t) { \\\"use strict\\\"; })\",\n         \"Argument name clash (1:15)\");\n\ntestFail(\"function a() { \\\"use strict\\\"; (function b(t, t) { }); }\",\n         \"Argument name clash (1:44)\");\n\ntestFail(\"(function a(eval) { \\\"use strict\\\"; })\",\n         \"Binding eval in strict mode (1:12)\");\n\ntestFail(\"(function a(package) { \\\"use strict\\\"; })\",\n         \"Binding package in strict mode (1:12)\");\n\ntestFail(\"\\\"use strict\\\";function foo(){\\\"use strict\\\";}function bar(){var v = 015}\",\n         \"Invalid number (1:65)\");\n\ntestFail(\"var this = 10;\", \"Unexpected keyword 'this' (1:4)\");\n\ntestFail(\"throw\\n10;\", \"Illegal newline after throw (1:5)\");\n\n\n// ECMA < 6 mode should work as before\n\ntestFail(\"const a;\", \"The keyword 'const' is reserved (1:0)\");\n\ntestFail(\"let x;\", \"Unexpected token (1:4)\");\n\ntestFail(\"const a = 1;\", \"The keyword 'const' is reserved (1:0)\");\n\ntestFail(\"let a = 1;\", \"Unexpected token (1:4)\");\n\ntestFail(\"for(const x = 0;;);\", \"The keyword 'const' is reserved (1:4)\");\n\ntestFail(\"for(let x = 0;;);\", \"Unexpected token (1:8)\");\n\ntestFail(\"function a(b = c) {}\", \"Unexpected token (1:13)\");\n\ntestFail(\"switch (x) { something }\", \"Unexpected token (1:13)\");\n\ntestFail(\"`abc`\", \"Unexpected character '`' (1:0)\", {ecmaVersion: 5});\n\ntest(\"let++\", {\n  type: \"Program\",\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  },\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      },\n      expression: {\n        type: \"UpdateExpression\",\n        loc: {\n          start: {\n            line: 1,\n            column: 0\n          },\n          end: {\n            line: 1,\n            column: 5\n          }\n        },\n        operator: \"++\",\n        prefix: false,\n        argument: {\n          type: \"Identifier\",\n          loc: {\n            start: {\n              line: 1,\n              column: 0\n            },\n            end: {\n              line: 1,\n              column: 3\n            }\n          },\n          name: \"let\"\n        }\n      }\n    }\n  ]\n});\n\n// ECMA 6 support\n\ntest(\"let x\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        }\n      ],\n      kind: \"let\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 5\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 5\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"let x, y;\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 5\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 7\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }\n          },\n          init: null,\n          loc: {\n            start: {\n              line: 1,\n              column: 7\n            },\n            end: {\n              line: 1,\n              column: 8\n            }\n          }\n        }\n      ],\n      kind: \"let\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 9\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 9\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"let x = 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 10\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 10\n            }\n          }\n        }\n      ],\n      kind: \"let\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 10\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 10\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"let eval = 42, arguments = 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"eval\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 8\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 11\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 13\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"arguments\",\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 24\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 27\n              },\n              end: {\n                line: 1,\n                column: 29\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 15\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }\n        }\n      ],\n      kind: \"let\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 29\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 29\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"let x = 14, y = 3, z = 1977\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 4\n              },\n              end: {\n                line: 1,\n                column: 5\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 14,\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 10\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 4\n            },\n            end: {\n              line: 1,\n              column: 10\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 12\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 3,\n            loc: {\n              start: {\n                line: 1,\n                column: 16\n              },\n              end: {\n                line: 1,\n                column: 17\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 12\n            },\n            end: {\n              line: 1,\n              column: 17\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 19\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 1977,\n            loc: {\n              start: {\n                line: 1,\n                column: 23\n              },\n              end: {\n                line: 1,\n                column: 27\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 19\n            },\n            end: {\n              line: 1,\n              column: 27\n            }\n          }\n        }\n      ],\n      kind: \"let\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 27\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 27\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"for(let x = 0;;);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: {\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 8\n                },\n                end: {\n                  line: 1,\n                  column: 9\n                }\n              }\n            },\n            init: {\n              type: \"Literal\",\n              value: 0,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 12\n                },\n                end: {\n                  line: 1,\n                  column: 13\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          }\n        ],\n        kind: \"let\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 13\n          }\n        }\n      },\n      test: null,\n      update: null,\n      body: {\n        type: \"EmptyStatement\",\n        loc: {\n          start: {\n            line: 1,\n            column: 16\n          },\n          end: {\n            line: 1,\n            column: 17\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 17\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 17\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"for(let x = 0, y = 1;;);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForStatement\",\n      init: {\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 8\n                },\n                end: {\n                  line: 1,\n                  column: 9\n                }\n              }\n            },\n            init: {\n              type: \"Literal\",\n              value: 0,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 12\n                },\n                end: {\n                  line: 1,\n                  column: 13\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 8\n              },\n              end: {\n                line: 1,\n                column: 13\n              }\n            }\n          },\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"y\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 15\n                },\n                end: {\n                  line: 1,\n                  column: 16\n                }\n              }\n            },\n            init: {\n              type: \"Literal\",\n              value: 1,\n              loc: {\n                start: {\n                  line: 1,\n                  column: 19\n                },\n                end: {\n                  line: 1,\n                  column: 20\n                }\n              }\n            },\n            loc: {\n              start: {\n                line: 1,\n                column: 15\n              },\n              end: {\n                line: 1,\n                column: 20\n              }\n            }\n          }\n        ],\n        kind: \"let\",\n        loc: {\n          start: {\n            line: 1,\n            column: 4\n          },\n          end: {\n            line: 1,\n            column: 20\n          }\n        }\n      },\n      test: null,\n      update: null,\n      body: {\n        type: \"EmptyStatement\",\n        loc: {\n          start: {\n            line: 1,\n            column: 23\n          },\n          end: {\n            line: 1,\n            column: 24\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 24\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 24\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"for (let x in list) process(x);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ForInStatement\",\n      left: {\n        type: \"VariableDeclaration\",\n        declarations: [\n          {\n            type: \"VariableDeclarator\",\n            id: {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 9\n                },\n                end: {\n                  line: 1,\n                  column: 10\n                }\n              }\n            },\n            init: null,\n            loc: {\n              start: {\n                line: 1,\n                column: 9\n              },\n              end: {\n                line: 1,\n                column: 10\n              }\n            }\n          }\n        ],\n        kind: \"let\",\n        loc: {\n          start: {\n            line: 1,\n            column: 5\n          },\n          end: {\n            line: 1,\n            column: 10\n          }\n        }\n      },\n      right: {\n        type: \"Identifier\",\n        name: \"list\",\n        loc: {\n          start: {\n            line: 1,\n            column: 14\n          },\n          end: {\n            line: 1,\n            column: 18\n          }\n        }\n      },\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"CallExpression\",\n          callee: {\n            type: \"Identifier\",\n            name: \"process\",\n            loc: {\n              start: {\n                line: 1,\n                column: 20\n              },\n              end: {\n                line: 1,\n                column: 27\n              }\n            }\n          },\n          arguments: [\n            {\n              type: \"Identifier\",\n              name: \"x\",\n              loc: {\n                start: {\n                  line: 1,\n                  column: 28\n                },\n                end: {\n                  line: 1,\n                  column: 29\n                }\n              }\n            }\n          ],\n          loc: {\n            start: {\n              line: 1,\n              column: 20\n            },\n            end: {\n              line: 1,\n              column: 30\n            }\n          }\n        },\n        loc: {\n          start: {\n            line: 1,\n            column: 20\n          },\n          end: {\n            line: 1,\n            column: 31\n          }\n        }\n      },\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 31\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 31\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"const x = 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 6\n              },\n              end: {\n                line: 1,\n                column: 7\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 10\n              },\n              end: {\n                line: 1,\n                column: 12\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        }\n      ],\n      kind: \"const\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 12\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 12\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"const eval = 42, arguments = 42\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"eval\",\n            loc: {\n              start: {\n                line: 1,\n                column: 6\n              },\n              end: {\n                line: 1,\n                column: 10\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 13\n              },\n              end: {\n                line: 1,\n                column: 15\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 15\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"arguments\",\n            loc: {\n              start: {\n                line: 1,\n                column: 17\n              },\n              end: {\n                line: 1,\n                column: 26\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 42,\n            loc: {\n              start: {\n                line: 1,\n                column: 29\n              },\n              end: {\n                line: 1,\n                column: 31\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 17\n            },\n            end: {\n              line: 1,\n              column: 31\n            }\n          }\n        }\n      ],\n      kind: \"const\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 31\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 31\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntest(\"const x = 14, y = 3, z = 1977\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"VariableDeclaration\",\n      declarations: [\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"x\",\n            loc: {\n              start: {\n                line: 1,\n                column: 6\n              },\n              end: {\n                line: 1,\n                column: 7\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 14,\n            loc: {\n              start: {\n                line: 1,\n                column: 10\n              },\n              end: {\n                line: 1,\n                column: 12\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 6\n            },\n            end: {\n              line: 1,\n              column: 12\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"y\",\n            loc: {\n              start: {\n                line: 1,\n                column: 14\n              },\n              end: {\n                line: 1,\n                column: 15\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 3,\n            loc: {\n              start: {\n                line: 1,\n                column: 18\n              },\n              end: {\n                line: 1,\n                column: 19\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 14\n            },\n            end: {\n              line: 1,\n              column: 19\n            }\n          }\n        },\n        {\n          type: \"VariableDeclarator\",\n          id: {\n            type: \"Identifier\",\n            name: \"z\",\n            loc: {\n              start: {\n                line: 1,\n                column: 21\n              },\n              end: {\n                line: 1,\n                column: 22\n              }\n            }\n          },\n          init: {\n            type: \"Literal\",\n            value: 1977,\n            loc: {\n              start: {\n                line: 1,\n                column: 25\n              },\n              end: {\n                line: 1,\n                column: 29\n              }\n            }\n          },\n          loc: {\n            start: {\n              line: 1,\n              column: 21\n            },\n            end: {\n              line: 1,\n              column: 29\n            }\n          }\n        }\n      ],\n      kind: \"const\",\n      loc: {\n        start: {\n          line: 1,\n          column: 0\n        },\n        end: {\n          line: 1,\n          column: 29\n        }\n      }\n    }\n  ],\n  loc: {\n    start: {\n      line: 1,\n      column: 0\n    },\n    end: {\n      line: 1,\n      column: 29\n    }\n  }\n}, {ecmaVersion: 6, locations: true});\n\ntestFail(\"const a;\", \"Unexpected token (1:7)\", {ecmaVersion: 6});\n\ntest(\"for(const x = 0;;);\", {\n  type: \"Program\",\n  body: [{\n    type: \"ForStatement\",\n    init: {\n      type: \"VariableDeclaration\",\n      declarations: [{\n        type: \"VariableDeclarator\",\n        id: {\n          type: \"Identifier\",\n          name: \"x\",\n          range: [10, 11]\n        },\n        init: {\n          type: \"Literal\",\n          value: 0,\n          range: [14, 15]\n        },\n        range: [10, 15]\n      }],\n      kind: \"const\",\n      range: [4, 15]\n    },\n    test: null,\n    update: null,\n    body: {\n      type: \"EmptyStatement\",\n      range: [18, 19]\n    },\n    range: [0, 19]\n  }],\n  range: [0, 19]\n}, {ecmaVersion: 6, ranges: true});\n\ntestFail(\"for(x of a);\", \"Unexpected token (1:6)\");\n\ntestFail(\"for(var x of a);\", \"Unexpected token (1:10)\");\n\n// Assertion Tests\ntest(function TestComments() {\n    // Bear class\n    function Bear(x,y,z) {\n      this.position = [x||0,y||0,z||0]\n    }\n\n    Bear.prototype.roar = function(message) {\n      return 'RAWWW: ' + message; // Whatever\n    };\n\n    function Cat() {\n    /* 1\n       2\n       3*/\n    }\n\n    Cat.prototype.roar = function(message) {\n      return 'MEOOWW: ' + /*stuff*/ message;\n    };\n}.toString().replace(/\\r\\n/g, '\\n'), {}, {\n  onComment: [\n    {type: \"Line\", value: \" Bear class\"},\n    {type: \"Line\", value: \" Whatever\"},\n    {type: \"Block\",  value: [\n            \" 1\",\n      \"       2\",\n      \"       3\"\n    ].join('\\n')},\n    {type: \"Block\", value: \"stuff\"}\n  ]\n});\n\ntest(\"<!--\\n;\", {\n  type: \"Program\",\n  body: [{\n    type: \"EmptyStatement\"\n  }]\n});\n\ntest(\"\\nfunction plop() {\\n'use strict';\\n/* Comment */\\n}\", {}, {\n  locations: true,\n  onComment: [{\n    type: \"Block\",\n    value: \" Comment \",\n    loc: {\n      start: { line: 4, column: 0 },\n      end: { line: 4, column: 13 }\n    }\n  }]\n});\n\ntest(\"// line comment\", {}, {\n  locations: true,\n  onComment: [{\n    type: \"Line\",\n    value: \" line comment\",\n    loc: {\n      start: { line: 1, column: 0 },\n      end: { line: 1, column: 15 }\n    }\n  }]\n});\n\ntest(\"<!-- HTML comment\", {}, {\n  locations: true,\n  onComment: [{\n    type: \"Line\",\n    value: \" HTML comment\",\n    loc: {\n      start: { line: 1, column: 0 },\n      end: { line: 1, column: 17 }\n    }\n  }]\n});\n\ntest(\";\\n--> HTML comment\", {}, {\n  locations: true,\n  onComment: [{\n    type: \"Line\",\n    value: \" HTML comment\",\n    loc: {\n      start: { line: 2, column: 0 },\n      end: { line: 2, column: 16 }\n    }\n  }]\n});\n\nvar tokTypes = acorn.tokTypes;\n\ntest('var x = (1 + 2)', {}, {\n  locations: true,\n  loose: false,\n  onToken: [\n    {\n      type: tokTypes._var,\n      value: \"var\",\n      loc: {\n        start: {line: 1, column: 0},\n        end: {line: 1, column: 3}\n      }\n    },\n    {\n      type: tokTypes.name,\n      value: \"x\",\n      loc: {\n        start: {line: 1, column: 4},\n        end: {line: 1, column: 5}\n      }\n    },\n    {\n      type: tokTypes.eq,\n      value: \"=\",\n      loc: {\n        start: {line: 1, column: 6},\n        end: {line: 1, column: 7}\n      }\n    },\n    {\n      type: tokTypes.parenL,\n      value: undefined,\n      loc: {\n        start: {line: 1, column: 8},\n        end: {line: 1, column: 9}\n      }\n    },\n    {\n      type: tokTypes.num,\n      value: 1,\n      loc: {\n        start: {line: 1, column: 9},\n        end: {line: 1, column: 10}\n      }\n    },\n    {\n      type: tokTypes.plusMin,\n      value: \"+\",\n      loc: {\n        start: {line: 1, column: 11},\n        end: {line: 1, column: 12}\n      }\n    },\n    {\n      type: tokTypes.num,\n      value: 2,\n      loc: {\n        start: {line: 1, column: 13},\n        end: {line: 1, column: 14}\n      }\n    },\n    {\n      type: tokTypes.parenR,\n      value: undefined,\n      loc: {\n        start: {line: 1, column: 14},\n        end: {line: 1, column: 15}\n      }\n    },\n    {\n      type: tokTypes.eof,\n      value: undefined,\n      loc: {\n        start: {line: 1, column: 15},\n        end: {line: 1, column: 15}\n      }\n    }\n  ]\n});\n\ntest(\"function f(f) { 'use strict'; }\", {});\n\n// https://github.com/acornjs/acorn/issues/180\ntest(\"#!/usr/bin/node\\n;\", {}, {\n  allowHashBang: true,\n  onComment: [{\n    type: \"Line\",\n    value: \"/usr/bin/node\",\n    start: 0,\n    end: 15\n  }]\n});\n\n// https://github.com/acornjs/acorn/issues/204\ntest(\"(function () {} / 1)\", {\n  type: \"Program\",\n  body: [{\n    type: \"ExpressionStatement\",\n    expression: {\n      type: \"BinaryExpression\",\n      left: {\n        type: \"FunctionExpression\",\n        id: null,\n        params: [],\n        body: {\n          type: \"BlockStatement\",\n          body: []\n        }\n      },\n      operator: \"/\",\n      right: {type: \"Literal\", value: 1}\n    }\n  }]\n});\n\ntest(\"function f() {} / 1 /\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"FunctionDeclaration\",\n      id: {type: \"Identifier\", name: \"f\"},\n      params: [],\n      body: {\n        type: \"BlockStatement\",\n        body: []\n      }\n    },\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        regex: {pattern: \" 1 \", flags: \"\"},\n        value: / 1 /\n      }\n    }\n  ]\n});\n\n// https://github.com/acornjs/acorn/issues/320\n\ntest(\"do /x/; while (false);\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"DoWhileStatement\",\n      body: {\n        type: \"ExpressionStatement\",\n        expression: {\n          type: \"Literal\",\n          value: /x/,\n          raw: \"/x/\",\n          regex: { pattern: \"x\", flags: \"\" }\n        }\n      },\n      test: {\n        type: \"Literal\",\n        value: false,\n        raw: \"false\"\n      }\n    }\n  ]\n});\n\nvar semicolons = []\ntestAssert(\"var x\\nreturn\\n10\", function() {\n  var result = semicolons.join(\" \");\n  semicolons.length = 0;\n  if (result != \"5 12 15\")\n    return \"Unexpected result for onInsertedSemicolon: \" + result;\n}, {onInsertedSemicolon: function(pos) { semicolons.push(pos); },\n    allowReturnOutsideFunction: true,\n    loose: false})\n\nvar trailingCommas = []\ntestAssert(\"[1,2,] + {foo: 1,}\", function() {\n  var result = trailingCommas.join(\" \");\n  trailingCommas.length = 0;\n  if (result != \"4 16\")\n    return \"Unexpected result for onTrailingComma: \" + result;\n}, {onTrailingComma: function(pos) { trailingCommas.push(pos); },\n    loose: false})\n\n// https://github.com/acornjs/acorn/issues/275\n\ntestFail(\"({ get prop(x) {} })\", \"getter should have no params (1:11)\");\ntestFail(\"({ set prop() {} })\", \"setter should have exactly one param (1:11)\");\ntestFail(\"({ set prop(x, y) {} })\", \"setter should have exactly one param (1:11)\");\n\n// https://github.com/acornjs/acorn/issues/363\n\ntest(\"/[a-z]/gim\", {\n  type: \"Program\",\n  body: [\n    {\n      type: \"ExpressionStatement\",\n      expression: {\n        type: \"Literal\",\n        value: /[a-z]/gim,\n        regex: {\n          pattern: \"[a-z]\",\n          flags: \"gim\"\n        }\n      }\n    }\n  ]\n});\ntestFail(\"/[a-z]/u\", \"Invalid regular expression flag (1:1)\");\ntestFail(\"/[a-z]/y\", \"Invalid regular expression flag (1:1)\");\ntestFail(\"/[a-z]/s\", \"Invalid regular expression flag (1:1)\");\ntestFail(\"/a/gg\", \"Duplicate regular expression flag (1:1)\");\n\ntestFail(\"function(){}\", \"Unexpected token (1:8)\");\n\ntest(\"0123. in/foo/i\", {\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"expression\": {\n        \"type\": \"BinaryExpression\",\n        \"left\": {\n          \"type\": \"BinaryExpression\",\n          \"left\": {\n            \"type\": \"MemberExpression\",\n            \"object\": {\n              \"type\": \"Literal\",\n              \"value\": 83,\n              \"raw\": \"0123\"\n            },\n            \"property\": {\n              \"type\": \"Identifier\",\n              \"name\": \"in\"\n            },\n            \"computed\": false\n          },\n          \"operator\": \"/\",\n          \"right\": {\n            \"type\": \"Identifier\",\n            \"name\": \"foo\"\n          }\n        },\n        \"operator\": \"/\",\n        \"right\": {\n          \"type\": \"Identifier\",\n          \"name\": \"i\"\n        }\n      }\n    }\n  ]\n})\n\ntest(\"0128\", {\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"expression\": {\n        \"type\": \"Literal\",\n        \"value\": 128,\n        \"raw\": \"0128\"\n      }\n    }\n  ]\n})\n\ntestFail(\"07.5\", \"Unexpected token (1:2)\")\n\ntest(\"08.5\", {\n  \"type\": \"Program\",\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"expression\": {\n        \"type\": \"Literal\",\n        \"value\": 8.5,\n        \"raw\": \"08.5\"\n      }\n    }\n  ]\n})\n\ntest(\"undefined\", {}, { ecmaVersion: 8 })\n\ntestFail(\"\\\\u{74}rue\", \"Escape sequence in keyword true (1:0)\", {ecmaVersion: 6})\ntestFail(\"export { X \\\\u0061s Y }\", \"Unexpected token (1:11)\", {ecmaVersion: 7, sourceType: \"module\"})\ntestFail(\"import X fro\\\\u006d 'x'\", \"Unexpected token (1:9)\", {ecmaVersion: 7, sourceType: \"module\"})\ntestFail(\"le\\\\u0074 x = 5\", \"Unexpected token (1:9)\", {ecmaVersion: 6})\ntestFail(\"(function* () { y\\\\u0069eld 10 })\", \"Cannot use 'yield' as identifier inside a generator (1:16)\", {ecmaVersion: 6})\ntestFail(\"(async function() { aw\\\\u0061it x })\", \"Cannot use 'await' as identifier inside an async function (1:20)\", {ecmaVersion: 8})\ntestFail(\"(\\\\u0061sync function() { await x })\", \"Unexpected token (1:12)\", {ecmaVersion: 8})\ntestFail(\"(\\\\u0061sync () => { await x })\", \"Unexpected token (1:15)\", {ecmaVersion: 8})\ntestFail(\"\\\\u0061sync x => { await x }\", \"Unexpected token (1:11)\", {ecmaVersion: 8})\ntestFail(\"class X { \\\\u0061sync x() { await x } }\", \"Unexpected token (1:21)\", {ecmaVersion: 8})\ntestFail(\"class X { static \\\\u0061sync x() { await x } }\", \"Unexpected token (1:28)\", {ecmaVersion: 8})\ntestFail(\"({ ge\\\\u0074 x() {} })\", \"Unexpected token (1:12)\")\ntestFail(\"export \\\\u0061sync function y() { await x }\", \"Unexpected token (1:7)\", {ecmaVersion: 8, sourceType: \"module\"})\ntestFail(\"export default \\\\u0061sync function () { await x }\", \"Unexpected token (1:26)\", {ecmaVersion: 8, sourceType: \"module\"})\ntest(\"(\\\\u0061sync ())\", {\n  \"type\": \"Program\",\n  \"start\": 0,\n  \"end\": 15,\n  \"body\": [\n    {\n      \"type\": \"ExpressionStatement\",\n      \"start\": 0,\n      \"end\": 15,\n      \"expression\": {\n        \"type\": \"CallExpression\",\n        \"start\": 1,\n        \"end\": 14,\n        \"callee\": {\n          \"type\": \"Identifier\",\n          \"start\": 1,\n          \"end\": 11,\n          \"name\": \"async\"\n        },\n        \"arguments\": []\n      }\n    }\n  ],\n  \"sourceType\": \"script\"\n}, {ecmaVersion: 8})\ntestFail(\"({ \\\\u0061sync x() { await x } })\", \"Unexpected token (1:14)\", {ecmaVersion: 8})\ntestFail(\"for (x \\\\u006ff y) {}\", \"Unexpected token (1:7)\", {ecmaVersion: 6})\ntestFail(\"function x () { new.ta\\\\u0072get }\", \"The only valid meta property for new is new.target (1:20)\", {ecmaVersion: 6})\ntestFail(\"class X { st\\\\u0061tic y() {} }\", \"Unexpected token (1:22)\", {ecmaVersion: 6})\n\ntestFail(\"(x=1)=2\", \"Parenthesized pattern (1:0)\")\n\ntest(\"(foo = [])[0] = 4;\", {})\n\ntest(\"for ((foo = []).bar in {}) {}\", {})\n\ntest(\"((b), a=1)\", {})\n\ntest(\"(x) = 1\", {})\n\ntest(\"try {} catch (foo) { var foo; }\", {}, {ecmaVersion: 6})\ntestFail(\"try {} catch (foo) { let foo; }\", \"Identifier 'foo' has already been declared (1:25)\", {ecmaVersion: 6})\ntest(\"try {} catch (foo) { try {} catch (_) { var foo; } }\", {}, {ecmaVersion: 6})\ntestFail(\"try {} catch ([foo]) { var foo; }\", \"Identifier 'foo' has already been declared (1:27)\", {ecmaVersion: 6})\ntestFail(\"try {} catch ({ foo }) { var foo; }\", \"Identifier 'foo' has already been declared (1:29)\", {ecmaVersion: 6})\ntestFail(\"try {} catch ([foo, foo]) {}\", \"Identifier 'foo' has already been declared (1:20)\", {ecmaVersion: 6})\ntestFail(\"try {} catch ({ a: foo, b: { c: [foo] } }) {}\", \"Identifier 'foo' has already been declared (1:33)\", {ecmaVersion: 6})\ntestFail(\"let foo; try {} catch (foo) {} let foo;\", \"Identifier 'foo' has already been declared (1:35)\", {ecmaVersion: 6})\ntestFail(\"try {} catch (foo) { function foo() {} }\", \"Identifier 'foo' has already been declared (1:30)\")\ntest(\"try {} catch (foo) { if (1) function foo() {} }\", {}, {ecmaVersion: 6})\n\ntest(\"try {} catch (foo) {} var foo;\", {})\ntest(\"try {} catch (foo) {} let foo;\", {}, {ecmaVersion: 6})\ntest(\"try {} catch (foo) { { let foo; } }\", {}, {ecmaVersion: 6})\ntest(\"try {} catch (foo) { function x() { var foo; } }\", {}, {ecmaVersion: 6})\ntest(\"try {} catch (foo) { function x(foo) {} }\", {}, {ecmaVersion: 6})\n\ntest(\"'use strict'; let foo = function foo() {}\", {}, {ecmaVersion: 6})\n\ntest(\"/**/ --> comment\\n\", {})\ntest(\"x.class++\", {})\n\ntestFail(\"½\", \"Unexpected character '½' (1:0)\")\n","/Users/saba/Documents/northeastern/research/nodeprof/dynamic-analysis/nodeprof.js/test/input/acorn/test/driver.js":"var tests = [];\n\nexports.test = function(code, ast, options) {\n  tests.push({code: code, ast: ast, options: options});\n};\nexports.testFail = function(code, message, options) {\n  tests.push({code: code, error: message, options: options});\n};\nexports.testAssert = function(code, assert, options) {\n  tests.push({code: code, assert: assert, options: options});\n};\n\nexports.runTests = function(config, callback) {\n  var parse = config.parse;\n\n  for (var i = 0; i < tests.length; ++i) {\n    var test = tests[i];\n    if (config.filter && !config.filter(test)) continue;\n    var testOpts = test.options || {locations: true};\n    if (!testOpts.ecmaVersion) testOpts.ecmaVersion = 5;\n    var expected = {};\n    if (expected.onComment = testOpts.onComment)\n      testOpts.onComment = []\n    if (expected.onToken = testOpts.onToken)\n      testOpts.onToken = [];\n\n    try {\n      var ast = parse(test.code, testOpts);\n    } catch(e) {\n      if (!(e instanceof SyntaxError)) { console.log(e.stack); throw e; }\n      if (test.error) {\n        if (test.error.charAt(0) == \"~\" ? e.message.indexOf(test.error.slice(1)) > -1 : e.message == test.error)\n          callback(\"ok\", test.code);\n        else\n          callback(\"fail\", test.code, \"Expected error message: \" + test.error + \"\\nGot error message: \" + e.message);\n      } else {\n        callback(\"error\", test.code, e.message || e.toString());\n      }\n      continue\n    }\n\n    if (test.error) {\n      if (config.loose) callback(\"ok\", test.code);\n      else callback(\"fail\", test.code, \"Expected error message: \" + test.error + \"\\nBut parsing succeeded.\");\n    } else if (test.assert) {\n      var error = test.assert(ast);\n      if (error) callback(\"fail\", test.code, \"\\n  Assertion failed:\\n \" + error);\n      else callback(\"ok\", test.code);\n    } else {\n      var mis = misMatch(test.ast, ast);\n      for (var name in expected) {\n        if (mis) break;\n        if (expected[name]) {\n          mis = misMatch(expected[name], testOpts[name]);\n          testOpts[name] = expected[name];\n        }\n      }\n      if (mis) callback(\"fail\", test.code, mis);\n      else callback(\"ok\", test.code);\n    }\n  }\n};\n\nfunction ppJSON(v) { return v instanceof RegExp ? v.toString() : (typeof v == \"bigint\" ? v.toString() : JSON.stringify(v, null, 2)); }\nfunction addPath(str, pt) {\n  if (str.charAt(str.length-1) == \")\")\n    return str.slice(0, str.length-1) + \"/\" + pt + \")\";\n  return str + \" (\" + pt + \")\";\n}\n\nvar misMatch = exports.misMatch = function(exp, act) {\n  if (!exp || !act || (typeof exp != \"object\") || (typeof act != \"object\")) {\n    if (exp !== act && typeof exp != \"function\")\n      return ppJSON(exp) + \" !== \" + ppJSON(act);\n  } else if (exp instanceof RegExp || act instanceof RegExp) {\n    var left = ppJSON(exp), right = ppJSON(act);\n    if (left !== right) return left + \" !== \" + right;\n  } else if (exp.splice) {\n    if (!act.slice) return ppJSON(exp) + \" != \" + ppJSON(act);\n    if (act.length != exp.length) return \"array length mismatch \" + exp.length + \" != \" + act.length;\n    for (var i = 0; i < act.length; ++i) {\n      var mis = misMatch(exp[i], act[i]);\n      if (mis) return addPath(mis, i);\n    }\n  } else {\n    for (var prop in exp) {\n      var mis = misMatch(exp[prop], act[prop]);\n      if (mis) return addPath(mis, prop);\n    }\n  }\n};\n\nfunction mangle(ast) {\n  if (typeof ast != \"object\" || !ast) return;\n  if (ast.slice) {\n    for (var i = 0; i < ast.length; ++i) mangle(ast[i]);\n  } else {\n    var loc = ast.start && ast.end && {start: ast.start, end: ast.end};\n    if (loc) { delete ast.start; delete ast.end; }\n    for (var name in ast) if (ast.hasOwnProperty(name)) mangle(ast[name]);\n    if (loc) ast.loc = loc;\n  }\n}\n\n"}